Timer unit: 1e-06 s

Total time: 7253.86 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: runForecast at line 2040

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2040                                               @profile
  2041                                               def runForecast(self, log_level='WARNING', play_notification_sound=False):
  2042                                                   #print('Starting Forecast #'+str(self.unique_id))
  2043         1         35.0     35.0      0.0          self.start_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2044                                           
  2045         1          2.0      2.0      0.0          if log_level == 'DEBUG':
  2046                                                       loglevel = logging.DEBUG
  2047         1          2.0      2.0      0.0          elif log_level == 'INFO':
  2048                                                       loglevel = logging.INFO
  2049         1          1.0      1.0      0.0          elif log_level == 'WARNING':
  2050         1          1.0      1.0      0.0              loglevel = logging.WARNING
  2051                                                   elif log_level == 'ERROR':
  2052                                                       loglevel = logging.ERROR
  2053                                                   elif log_level == 'CRITICAL':
  2054                                                       loglevel = logging.CRITICAL
  2055                                                   else:
  2056                                                       loglevel = logging.WARNING
  2057         1         29.0     29.0      0.0          logger.setLevel(loglevel)
  2058                                           
  2059         1         39.0     39.0      0.0          log_in_color(logger, 'white', 'info', 'Starting Forecast '+str(self.unique_id))
  2060                                           
  2061                                                   # this is the place to estimate runtime to appropriately update progress bar
  2062                                                   # It could be for each day each priority, but then priority > 1 would have thr bar stop every time it looks ahead
  2063                                                   # I think the way to do it is have the bar be relative to the worst case
  2064                                                   # deferrable are really fucky. we will assume a deferral cadence of 2 weeks though this can be accounted for
  2065                                                   # if a deferral cadence is implemented #todo
  2066                                                   # I'm not sold that it would be that useful though. A look-ahead on income seems reasonable
  2067                                                   # therefore, each p2+ txn may fail, and each partial_payment may fail twice, and each deferrable may fail n times (where n is accounting for every 2 weeks
  2068                                                   #
  2069         1        103.0    103.0      0.0          sd = datetime.datetime.strptime(self.start_date_YYYYMMDD, '%Y%m%d')
  2070         1         64.0     64.0      0.0          ed = datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d')
  2071         1          3.0      3.0      0.0          predicted_satisfice_runtime_in_simulated_days = (ed - sd).days
  2072                                                   # p2plus_txns_max_runtime_in_simulated_days = 0
  2073                                                   # for index, row in self.initial_proposed_df.iterrows():
  2074                                                   #     num_of_lookahead_days = ( ed - datetime.datetime.strptime(row.date.iat[0],'%Y%m%d') ).days
  2075                                                   #     if row.Deferrable:
  2076                                                   #         max_number_of_retries = math.floor(num_of_lookahead_days / 14)
  2077                                                   #         #each retry would be 2 weeks shorter. I'm thinking of it making a triangle shape
  2078                                                   #         #therefore, we add time * n / 2
  2079                                                   #         p2plus_txns_max_runtime_in_simulated_days += max_number_of_retries * num_of_lookahead_days / 2
  2080                                                   #     elif row.Partial_Payment_Allowed:
  2081                                                   #         p2plus_txns_max_runtime_in_simulated_days += 2 * num_of_lookahead_days
  2082                                                   #     else:
  2083                                                   #         p2plus_txns_max_runtime_in_simulated_days += num_of_lookahead_days
  2084                                                   # total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + p2plus_txns_max_runtime_in_simulated_days
  2085                                                   #
  2086                                                   # On second thought, I would rather deal wit ha stilted progress bar than figuring out how to track progress in recursion
  2087         1        182.0    182.0      0.0          no_of_p2plus_priority_levels = len(set(self.initial_proposed_df.Priority))
  2088         1          1.0      1.0      0.0          total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + predicted_satisfice_runtime_in_simulated_days * no_of_p2plus_priority_levels
  2089         1      43768.0  43768.0      0.0          progress_bar = tqdm.tqdm(range(total_predicted_max_runtime_in_simulated_days),total=total_predicted_max_runtime_in_simulated_days, desc=self.unique_id, disable=True) #disabled tqdm
  2090                                           
  2091         2 7251141409.0    4e+09    100.0          forecast_df, skipped_df, confirmed_df, deferred_df = self.computeOptimalForecast(
  2092         1          5.0      5.0      0.0              start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2093         1          0.0      0.0      0.0              end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2094         1       1397.0   1397.0      0.0              confirmed_df=pd.DataFrame(self.initial_confirmed_df, copy=True),
  2095         1        152.0    152.0      0.0              proposed_df=pd.DataFrame(self.initial_proposed_df, copy=True),
  2096         1        126.0    126.0      0.0              deferred_df=pd.DataFrame(self.initial_deferred_df, copy=True),
  2097         1        120.0    120.0      0.0              skipped_df=pd.DataFrame(self.initial_skipped_df, copy=True),
  2098         1       1282.0   1282.0      0.0              account_set=copy.deepcopy(self.initial_account_set),
  2099         1       1013.0   1013.0      0.0              memo_rule_set=copy.deepcopy(self.initial_memo_rule_set),
  2100         1          1.0      1.0      0.0              raise_satisfice_failed_exception=False,progress_bar=progress_bar)
  2101                                           
  2102         1          1.0      1.0      0.0          self.forecast_df = forecast_df
  2103         1          0.0      0.0      0.0          self.skipped_df = skipped_df
  2104         1          0.0      0.0      0.0          self.confirmed_df = confirmed_df
  2105         1          0.0      0.0      0.0          self.deferred_df = deferred_df
  2106                                           
  2107         1         25.0     25.0      0.0          self.end_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2108         1    2601761.0    3e+06      0.0          self.appendSummaryLines()
  2109         1         10.0     10.0      0.0          self.evaluateMilestones()
  2110                                           
  2111         1         19.0     19.0      0.0          log_in_color(logger, 'white', 'info','Finished Forecast '+str(self.unique_id))
  2112         1      69845.0  69845.0      0.0          log_in_color(logger, 'white', 'info', self.forecast_df.to_string())
  2113                                                   # if play_notification_sound:
  2114                                                   #     notification_sounds.play_notification_sound()
  2115                                           
  2116                                                   #self.forecast_df.to_csv('./out//Forecast_' + self.unique_id + '.csv') #this is only the forecast not the whole ExpenseForecast object
  2117                                                   #self.writeToJSONFile() #this is the whole ExpenseForecast object #todo this should accept a path parameter

Total time: 6829.16 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: attemptTransaction at line 2412

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2412                                               @profile
  2413                                               def attemptTransaction(self, forecast_df, account_set, memo_set, confirmed_df, proposed_row_df):
  2414                                                   """
  2415                                                   Attempts to execute a proposed transaction and returns the hypothetical future state of the forecast
  2416                                                   if the transaction is permitted.
  2417                                           
  2418                                                   Parameters:
  2419                                                   - forecast_df: DataFrame containing the current forecast.
  2420                                                   - account_set: AccountSet object representing the current state of accounts.
  2421                                                   - memo_set: MemoSet object containing memo rules.
  2422                                                   - confirmed_df: DataFrame of confirmed transactions.
  2423                                                   - proposed_row: Series representing the proposed transaction.
  2424                                           
  2425                                                   Returns:
  2426                                                   - hypothetical_future_forecast: DataFrame representing the updated forecast if the transaction is permitted.
  2427                                           
  2428                                                   Raises:
  2429                                                   - ValueError: If an exception occurs that is not due to account boundary violations.
  2430                                                   """
  2431        19         25.0      1.3      0.0          self.log_stack_depth += 1
  2432                                           
  2433        19          5.0      0.3      0.0          try:
  2434                                                       # Prepare the proposed transaction DataFrame
  2435        19       9649.0    507.8      0.0              single_proposed_transaction_df = proposed_row_df.to_frame().T.copy()
  2436                                           
  2437                                                       # Combine the confirmed transactions with the proposed transaction
  2438        19       5729.0    301.5      0.0              updated_confirmed_df = pd.concat([confirmed_df, single_proposed_transaction_df], ignore_index=True)
  2439                                           
  2440                                                       # Create an empty DataFrame for proposed, deferred, and skipped transactions
  2441        38      29383.0    773.2      0.0              empty_df = pd.DataFrame(
  2442        19         12.0      0.6      0.0                  columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  2443                                           
  2444                                                       # Determine the transaction date and previous date
  2445        19        346.0     18.2      0.0              txn_date = proposed_row_df['Date']
  2446        19       5857.0    308.3      0.0              txn_datetime = pd.to_datetime(txn_date, format='%Y%m%d')
  2447                                           
  2448                                                       # Find the previous date for synchronization
  2449        19         21.0      1.1      0.0              previous_date = self.start_date_YYYYMMDD  # Optimization removed due to credit card prepayment considerations
  2450                                           
  2451                                                       # Synchronize the account set with the forecast on the previous date
  2452        19     566588.0  29820.4      0.0              synced_account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, previous_date)
  2453                                           
  2454                                                       # Compute the hypothetical future forecast starting from the previous date
  2455        47 6828527185.0    1e+08    100.0              hypothetical_future_forecast = self.computeOptimalForecast(
  2456        19          6.0      0.3      0.0                  start_date_YYYYMMDD=previous_date,
  2457        19         15.0      0.8      0.0                  end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2458        19         10.0      0.5      0.0                  confirmed_df=updated_confirmed_df,
  2459        19          6.0      0.3      0.0                  proposed_df=empty_df,
  2460        19          5.0      0.3      0.0                  deferred_df=empty_df,
  2461        19          6.0      0.3      0.0                  skipped_df=empty_df,
  2462        19          2.0      0.1      0.0                  account_set=synced_account_set,
  2463        19          7.0      0.4      0.0                  memo_rule_set=memo_set
  2464         9          4.0      0.4      0.0              )[0]
  2465                                           
  2466                                                       # Exclude the first row since it's considered final and not part of the new forecast
  2467         9       1316.0    146.2      0.0              hypothetical_future_forecast = hypothetical_future_forecast.iloc[1:].copy()
  2468                                           
  2469                                                       # Extract past forecast rows before the transaction date
  2470         9       4366.0    485.1      0.0              past_forecast = forecast_df[forecast_df['Date'] < txn_date].copy()
  2471                                           
  2472                                                       # Combine past forecast with the hypothetical future forecast
  2473         9       2826.0    314.0      0.0              updated_forecast = pd.concat([past_forecast, hypothetical_future_forecast], ignore_index=True)
  2474                                           
  2475         9         10.0      1.1      0.0              self.log_stack_depth -= 1
  2476                                           
  2477         9          6.0      0.7      0.0              return updated_forecast  # Transaction is permitted
  2478                                           
  2479        10         12.0      1.2      0.0          except ValueError as e:
  2480                                                       # Log the exception
  2481        10        288.0     28.8      0.0              log_in_color(logger, 'red', 'debug', str(e), self.log_stack_depth)
  2482                                           
  2483                                                       # Reraise the exception if it's not due to account boundary violations
  2484        10         12.0      1.2      0.0              if 'Account boundaries were violated' not in str(e):
  2485                                                           raise e
  2486                                           
  2487        10         11.0      1.1      0.0              self.log_stack_depth -= 1
  2488                                           
  2489                                                       # Return None to indicate that the transaction is not permitted
  2490        10       1464.0    146.4      0.0              return None
  2491                                           
  2492                                           
  2493                                                   # #print('ENTER attemptTransaction '+proposed_row_df.Memo.iat[0])
  2494                                                   # # log_in_color(logger,'green','info','ENTER attemptTransaction( C:'+str(confirmed_df.shape[0])+' P:'+str(proposed_row_df.Memo)+')',self.log_stack_depth)
  2495                                                   # # log_in_color(logger, 'magenta', 'debug', 'forecast_df BEFORE:')
  2496                                                   # # log_in_color(logger, 'magenta', 'debug', forecast_df.to_string() )
  2497                                                   # self.log_stack_depth += 1
  2498                                                   # try:
  2499                                                   #     single_proposed_transaction_df = pd.DataFrame(copy.deepcopy(proposed_row_df)).T
  2500                                                   #     # print('single_proposed_transaction_df:')
  2501                                                   #     # print(single_proposed_transaction_df.to_string())
  2502                                                   #     not_yet_validated_confirmed_df = copy.deepcopy(pd.concat([confirmed_df, single_proposed_transaction_df]))
  2503                                                   #     empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  2504                                                   #
  2505                                                   #     # hypothetical_future_state_of_forecast = \
  2506                                                   #     #     self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2507                                                   #     #                                 end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2508                                                   #     #                                 confirmed_df=not_yet_validated_confirmed_df,
  2509                                                   #     #                                 proposed_df=empty_df,
  2510                                                   #     #                                 deferred_df=empty_df,
  2511                                                   #     #                                 skipped_df=empty_df,
  2512                                                   #     #                                 account_set=copy.deepcopy(
  2513                                                   #     #                                     self.sync_account_set_w_forecast_day(account_set, forecast_df,
  2514                                                   #     #                                                                          self.start_date_YYYYMMDD)),
  2515                                                   #     #                                 memo_rule_set=memo_set)[0]
  2516                                                   #
  2517                                                   #     txn_date = proposed_row_df.Date
  2518                                                   #     d_sel_vec = ( datetime.datetime.strptime(d,'%Y%m%d') <= datetime.datetime.strptime(txn_date,'%Y%m%d') for d in forecast_df.Date )
  2519                                                   #     previous_row_df = forecast_df.loc[ d_sel_vec, : ].tail(2).head(1)
  2520                                                   #
  2521                                                   #     # log_in_color(logger, 'white', 'debug', 'previous_row_df:',self.log_stack_depth)
  2522                                                   #     # log_in_color(logger, 'white', 'debug', previous_row_df.to_string(),self.log_stack_depth)
  2523                                                   #
  2524                                                   #     #previous_date = previous_row_df.Date.iat[0]
  2525                                                   #     previous_date = self.start_date_YYYYMMDD #todo this optimization had to be removed bc of cc prepayment
  2526                                                   #
  2527                                                   #     #note that there may also be confirmed txns on the same day as the proposed txn
  2528                                                   #     # print('attempt transaction case 1 sync')
  2529                                                   #
  2530                                                   #     hypothetical_future_state_of_forecast_future_rows_only = \
  2531                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=previous_date,
  2532                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2533                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  2534                                                   #                                     proposed_df=empty_df,
  2535                                                   #                                     deferred_df=empty_df,
  2536                                                   #                                     skipped_df=empty_df,
  2537                                                   #                                     account_set=copy.deepcopy(
  2538                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,previous_date)),
  2539                                                   #                                     memo_rule_set=memo_set)[0]
  2540                                                   #
  2541                                                   #     #we started the sub-forecast on the previous date, bc that day is considered final
  2542                                                   #     #therefore, we can drop it from the concat bc it is not new
  2543                                                   #     hypothetical_future_state_of_forecast_future_rows_only = hypothetical_future_state_of_forecast_future_rows_only.iloc[1:,:]
  2544                                                   #
  2545                                                   #     # log_in_color(logger,'white','debug','hypothetical_future_state_of_forecast_future_rows_only:',self.log_stack_depth)
  2546                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2547                                                   #
  2548                                                   #     date_array = [ datetime.datetime.strptime(d,'%Y%m%d') for d in forecast_df.Date ]
  2549                                                   #     row_sel_vec = [ d < datetime.datetime.strptime(txn_date,'%Y%m%d') for d in date_array ]
  2550                                                   #
  2551                                                   #     past_confirmed_forecast_rows_df = forecast_df[ row_sel_vec ]
  2552                                                   #
  2553                                                   #     # log_in_color(logger, 'white', 'debug', 'past_confirmed_forecast_rows_df:', self.log_stack_depth)
  2554                                                   #     # log_in_color(logger, 'white', 'debug', past_confirmed_forecast_rows_df.to_string(), self.log_stack_depth)
  2555                                                   #     # log_in_color(logger, 'white', 'debug', 'hypothetical_future_state_of_forecast_future_rows_only:', self.log_stack_depth)
  2556                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2557                                                   #
  2558                                                   #     hypothetical_future_state_of_forecast = pd.concat([past_confirmed_forecast_rows_df,hypothetical_future_state_of_forecast_future_rows_only])
  2559                                                   #     # log_in_color(logger, 'green', 'info', hypothetical_future_state_of_forecast.to_string(), self.log_stack_depth)
  2560                                                   #
  2561                                                   #     self.log_stack_depth -= 1
  2562                                                   #
  2563                                                   #     #log_in_color(logger, 'green', 'debug',hypothetical_future_state_of_forecast.to_string())
  2564                                                   #     # log_in_color(logger, 'magenta', 'debug', 'forecast_df AFTER:')
  2565                                                   #     # log_in_color(logger, 'magenta', 'debug', hypothetical_future_state_of_forecast.to_string())
  2566                                                   #     # log_in_color(logger, 'green', 'info', 'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (SUCCESS)', self.log_stack_depth)
  2567                                                   #     #print('EXIT attemptTransaction')
  2568                                                   #     return hypothetical_future_state_of_forecast #transaction is permitted
  2569                                                   # except ValueError as e:
  2570                                                   #     self.log_stack_depth -= 5  # several decrements were skipped over by the exception
  2571                                                   #     # log_in_color(logger, 'white', 'debug', 'forecast_df AFTER:')
  2572                                                   #     # log_in_color(logger, 'white', 'debug', forecast_df.to_string())
  2573                                                   #     log_in_color(logger, 'red', 'debug',str(e), self.log_stack_depth)
  2574                                                   #     # log_in_color(logger, 'red', 'debug', account_set.getAccounts().to_string(), self.log_stack_depth)
  2575                                                   #     # log_in_color(logger, 'red', 'info',
  2576                                                   #     #              'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (FAIL)', self.log_stack_depth)
  2577                                                   #     # print(e.args)
  2578                                                   #     #print('EXIT attemptTransaction')
  2579                                                   #     if re.search('.*Account boundaries were violated.*',str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  2580                                                   #         raise e

Total time: 2482.57 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processConfirmedTransactions at line 2582

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2582                                               @profile
  2583                                               def processConfirmedTransactions(self, forecast_df, relevant_confirmed_df, memo_set, account_set, date_YYYYMMDD):
  2584                                                   # log_in_color(logger, 'green', 'debug', 'ENTER processConfirmedTransactions( C:'+str(relevant_confirmed_df.shape[0])+' ) '+str(date_YYYYMMDD), self.log_stack_depth)
  2585     11283      15120.0      1.3      0.0          self.log_stack_depth += 1
  2586                                                   # print('BEGIN processConfirmedTransactions('+date_YYYYMMDD+')')
  2587                                           
  2588     20414    1059159.0     51.9      0.0          for confirmed_index, confirmed_row in relevant_confirmed_df.iterrows():
  2589                                                       # print('    '+str(confirmed_row.Memo)+' '+str(confirmed_row.Amount))
  2590      9141  169951454.0  18592.2      6.8              relevant_memo_rule_set = memo_set.findMatchingMemoRule(confirmed_row.Memo, confirmed_row.Priority)
  2591      9141   14517116.0   1588.1      0.6              memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  2592                                           
  2593      9141     319157.0     34.9      0.0              income_flag = self.checkIfTxnIsIncome(confirmed_row)
  2594                                           
  2595     18282  254772351.0  13935.7     10.3              account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  2596      9141     168470.0     18.4      0.0                                             Account_To=memo_rule_row.Account_To,
  2597      9141     140816.0     15.4      0.0                                             Amount=confirmed_row.Amount,
  2598      9141       3002.0      0.3      0.0                                             income_flag=income_flag)
  2599                                           
  2600     18262 2041598989.0 111794.9     82.2              forecast_df = self.updateBalancesAndMemo(forecast_df, account_set, confirmed_row, memo_rule_row,
  2601      9131       3695.0      0.4      0.0                                                       date_YYYYMMDD)
  2602                                           
  2603     11273      17024.0      1.5      0.0          self.log_stack_depth -= 1
  2604                                                   # log_in_color(logger, 'green', 'debug', 'EXIT processConfirmedTransactions()', self.log_stack_depth)
  2605                                                   # print('EXIT processConfirmedTransactions(' + date_YYYYMMDD + ')')
  2606     11273       3781.0      0.3      0.0          return forecast_df

Total time: 9.13458 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getTotalPrepaidInCreditCardBillingCycle at line 2963

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2963                                               @profile
  2964                                               def getTotalPrepaidInCreditCardBillingCycle(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  2965                                                   """
  2966                                                   Calculates the total prepaid amount made towards a credit card in the billing cycle up to the given date.
  2967                                           
  2968                                                   Parameters:
  2969                                                   - account_name (str): The name of the credit card account.
  2970                                                   - account_set (AccountSet): The account set containing account information.
  2971                                                   - forecast_df (pd.DataFrame): The forecast DataFrame with financial data.
  2972                                                   - date_YYYYMMDD (str): The current date in 'YYYYMMDD' format.
  2973                                           
  2974                                                   Returns:
  2975                                                   - float: The total prepaid amount in the current billing cycle.
  2976                                                   """
  2977                                                   # Extract the base account name (without sub-accounts)
  2978       291        454.0      1.6      0.0          base_account_name = account_name.split(':')[0]
  2979                                           
  2980                                                   # Filter the account row for the given account name and type
  2981       291    8016108.0  27546.8     87.8          accounts_df = account_set.getAccounts()
  2982       582     167990.0    288.6      1.8          account_row = accounts_df[
  2983       582     157279.0    270.2      1.7              (accounts_df['Name'].str.startswith(base_account_name)) &
  2984       291      72331.0    248.6      0.8              (accounts_df['Account_Type'] == 'credit prev stmt bal')
  2985                                                       ]
  2986                                           
  2987       291       2770.0      9.5      0.0          if account_row.empty:
  2988                                                       raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  2989                                           
  2990                                                   # Get the billing start date
  2991       291      23625.0     81.2      0.3          billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  2992       291     100881.0    346.7      1.1          billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  2993                                           
  2994                                                   # Convert the current date to datetime
  2995       291      72653.0    249.7      0.8          current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  2996                                           
  2997                                                   # Generate billing dates up to the current date
  2998       582        799.0      1.4      0.0          num_months = (current_date.year - billing_start_date.year) * 12 + (
  2999       291        212.0      0.7      0.0                      current_date.month - billing_start_date.month)
  3000       291     178570.0    613.6      2.0          billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 1, freq='MS').strftime('%Y%m%d')
  3001                                           
  3002                                                   # Determine the start and end of the billing cycle
  3003       291       1186.0      4.1      0.0          if billing_dates.empty:
  3004                                                       billing_cycle_start_date = billing_start_date_str
  3005                                                   else:
  3006       291       1169.0      4.0      0.0              billing_cycle_start_date = billing_dates[-1]
  3007                                           
  3008                                                   # Define the time window to search for payments
  3009       291      15352.0     52.8      0.2          lookback_period_start = (current_date - pd.Timedelta(days=35)).strftime('%Y%m%d')
  3010       291        116.0      0.4      0.0          lookback_period_end = date_YYYYMMDD
  3011                                           
  3012                                                   # Filter forecast_df for the relevant date range
  3013       582      62992.0    108.2      0.7          date_filtered_df = forecast_df[
  3014       582      99611.0    171.2      1.1              (forecast_df['Date'] > billing_cycle_start_date) &
  3015       291      49902.0    171.5      0.5              (forecast_df['Date'] <= lookback_period_end)
  3016                                                       ]
  3017                                           
  3018                                                   # Check for additional credit card payments in the memo directives
  3019       291        337.0      1.2      0.0          def extract_payment_amount(memo):
  3020                                                       matches = re.findall(r'ADDTL CC PAYMENT \((.*?)\$\s*([0-9]*\.[0-9]{1,2})\)', memo)
  3021                                                       total = 0.0
  3022                                                       for acc_name, amount_str in matches:
  3023                                                           acc_name = acc_name.replace('-', '').strip()
  3024                                                           if acc_name == account_row['Name'].iloc[0].replace('-', '').strip():
  3025                                                               try:
  3026                                                                   amount = float(amount_str)
  3027                                                                   total += amount
  3028                                                               except ValueError:
  3029                                                                   continue
  3030                                                       return total
  3031                                           
  3032                                                   # Calculate the total prepaid amount
  3033       291     110109.0    378.4      1.2          total_prepaid_amount = date_filtered_df['Memo Directives'].apply(extract_payment_amount).sum()
  3034                                           
  3035       291        130.0      0.4      0.0          return total_prepaid_amount

Total time: 0.270659 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getFutureMinPaymentAmount at line 3118

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3118                                               @profile
  3119                                               def getFutureMinPaymentAmount(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  3120                                                   """
  3121                                                   Calculates the future minimum payment amount for a given credit card account starting from a specific date.
  3122                                           
  3123                                                   Parameters:
  3124                                                   - account_name (str): The name of the credit card account.
  3125                                                   - account_set (AccountSet): The account set containing account information.
  3126                                                   - forecast_df (pd.DataFrame): The forecast DataFrame containing financial data.
  3127                                                   - date_YYYYMMDD (str): The date from which to start the calculation, in 'YYYYMMDD' format.
  3128                                           
  3129                                                   Returns:
  3130                                                   - float: The minimum payment amount due in the future, or 0.0 if no payment is due.
  3131                                                   """
  3132                                           
  3133                                                   # Extract the base account name (before any colons)
  3134         9         15.0      1.7      0.0          base_account_name = account_name.split(':')[0]
  3135                                           
  3136                                                   # Get the account row for the specified account name and account type 'credit prev stmt bal'
  3137         9     236804.0  26311.6     87.5          accounts_df = account_set.getAccounts()
  3138        18       5044.0    280.2      1.9          account_row = accounts_df[
  3139        18       4895.0    271.9      1.8              (accounts_df['Name'].str.startswith(base_account_name)) &
  3140         9       2081.0    231.2      0.8              (accounts_df['Account_Type'] == 'credit prev stmt bal')
  3141                                                       ]
  3142                                           
  3143         9         87.0      9.7      0.0          if account_row.empty:
  3144                                                       raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  3145                                           
  3146                                                   # Get the forecast row for the specified date
  3147         9       3628.0    403.1      1.3          current_forecast_row_df = forecast_df[forecast_df['Date'] == date_YYYYMMDD]
  3148                                           
  3149         9         68.0      7.6      0.0          if current_forecast_row_df.empty:
  3150                                                       raise ValueError(f"Date '{date_YYYYMMDD}' not found in forecast DataFrame.")
  3151                                           
  3152                                                   # Check if there is a minimum payment on the current date
  3153         9        539.0     59.9      0.2          memo_directives = current_forecast_row_df['Memo Directives'].iat[0]
  3154         9        164.0     18.2      0.1          min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3155                                           
  3156         9          7.0      0.8      0.0          if min_payment_amount > 0:
  3157                                                       return min_payment_amount
  3158                                           
  3159                                                   # If no minimum payment on the current date, find the next billing date
  3160                                           
  3161                                                   # Convert dates to datetime objects
  3162         9       2884.0    320.4      1.1          current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3163         9        735.0     81.7      0.3          billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  3164         9       2254.0    250.4      0.8          billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  3165                                           
  3166                                                   # Generate billing dates starting from the billing start date
  3167         9         16.0      1.8      0.0          if current_date < billing_start_date:
  3168                                                       next_billing_date = billing_start_date
  3169                                                   else:
  3170                                                       # Calculate the number of months between the billing start date and current date
  3171        18         22.0      1.2      0.0              num_months = (current_date.year - billing_start_date.year) * 12 + (
  3172         9          9.0      1.0      0.0                          current_date.month - billing_start_date.month)
  3173         9       2758.0    306.4      1.0              billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 2, freq='MS')
  3174                                           
  3175                                                       # Find the next billing date after the current date
  3176         9       1583.0    175.9      0.6              future_billing_dates = billing_dates[billing_dates > current_date]
  3177         9         34.0      3.8      0.0              if not future_billing_dates.empty:
  3178         9        581.0     64.6      0.2                  next_billing_date = future_billing_dates.min()
  3179                                                       else:
  3180                                                           # If no future billing dates are found, set next billing date to billing start date
  3181                                                           next_billing_date = billing_start_date
  3182                                           
  3183                                                   # Check if next billing date is beyond the forecast end date
  3184         9       2340.0    260.0      0.9          forecast_end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3185         9         10.0      1.1      0.0          if next_billing_date > forecast_end_date:
  3186         1          1.0      1.0      0.0              return 0.0
  3187                                           
  3188                                                   # Get the forecast row for the next billing date
  3189         8        165.0     20.6      0.1          next_billing_date_str = next_billing_date.strftime('%Y%m%d')
  3190         8       3251.0    406.4      1.2          next_forecast_row_df = forecast_df[forecast_df['Date'] == next_billing_date_str]
  3191                                           
  3192         8         61.0      7.6      0.0          if next_forecast_row_df.empty:
  3193                                                       return 0.0
  3194                                           
  3195                                                   # Extract minimum payment amount from the memo directives on the next billing date
  3196         8        494.0     61.8      0.2          memo_directives = next_forecast_row_df['Memo Directives'].iat[0]
  3197         8        128.0     16.0      0.0          min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3198                                           
  3199         8          1.0      0.1      0.0          return min_payment_amount

Total time: 8.5e-05 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _extract_min_payment_amount at line 3201

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3201                                               @profile
  3202                                               def _extract_min_payment_amount(self, memo_directives, base_account_name):
  3203                                                   """
  3204                                                   Helper function to extract the minimum payment amount from memo directives.
  3205                                           
  3206                                                   Parameters:
  3207                                                   - memo_directives (str): The memo directives string.
  3208                                                   - base_account_name (str): The base account name.
  3209                                           
  3210                                                   Returns:
  3211                                                   - float: The total minimum payment amount found in the memo directives.
  3212                                                   """
  3213                                           
  3214        17         10.0      0.6     11.8          min_payment_amount = 0.0
  3215        17         17.0      1.0     20.0          memo_items = memo_directives.split(';')
  3216        36         20.0      0.6     23.5          for memo in memo_items:
  3217        19         17.0      0.9     20.0              memo = memo.strip()
  3218        19          7.0      0.4      8.2              if not memo:
  3219        17          5.0      0.3      5.9                  continue
  3220                                                       # Check for minimum payment directives for both previous and current statement balances
  3221         4          2.0      0.5      2.4              if (f'CC MIN PAYMENT ({base_account_name}: Prev Stmt Bal' in memo or
  3222         2          1.0      0.5      1.2                      f'CC MIN PAYMENT ({base_account_name}: Curr Stmt Bal' in memo):
  3223                                                           match = re.search(r'\(.*-\$(\d+(\.\d{1,2})?)\)', memo)
  3224                                                           if match:
  3225                                                               amount = float(match.group(1))
  3226                                                               min_payment_amount += amount
  3227        17          6.0      0.4      7.1          return min_payment_amount

Total time: 5602.02 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processProposedTransactions at line 3534

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3534                                               @profile
  3535                                               def processProposedTransactions(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df,
  3536                                                                                 relevant_proposed_df, priority_level):
  3537                                                   """
  3538                                                   Processes proposed transactions by attempting to execute them, handling partial payments, deferrals,
  3539                                                   and updating the forecast accordingly.
  3540                                           
  3541                                                   Parameters:
  3542                                                   - account_set: AccountSet object representing the current state of accounts.
  3543                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3544                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3545                                                   - memo_set: MemoSet object containing memo rules.
  3546                                                   - confirmed_df: DataFrame of confirmed transactions.
  3547                                                   - relevant_proposed_df: DataFrame of proposed transactions for the current date.
  3548                                                   - priority_level: Integer representing the priority level.
  3549                                           
  3550                                                   Returns:
  3551                                                   - forecast_df: Updated forecast DataFrame.
  3552                                                   - new_confirmed_df: DataFrame of newly confirmed transactions.
  3553                                                   - new_deferred_df: DataFrame of newly deferred transactions.
  3554                                                   - new_skipped_df: DataFrame of newly skipped transactions.
  3555                                                   """
  3556                                                   # Increment the log stack depth
  3557      4833       3451.0      0.7      0.0          self.log_stack_depth += 1
  3558                                           
  3559                                                   # Initialize DataFrames to hold new deferred, skipped, and confirmed transactions
  3560      4833     534054.0    110.5      0.0          new_deferred_df = relevant_proposed_df.iloc[0:0].copy()  # Empty DataFrame with the same schema
  3561      4833     394173.0     81.6      0.0          new_skipped_df = relevant_proposed_df.iloc[0:0].copy()
  3562      4833     370534.0     76.7      0.0          new_confirmed_df = relevant_proposed_df.iloc[0:0].copy()
  3563                                           
  3564                                                   # If there are no proposed transactions, return early
  3565      4833      35650.0      7.4      0.0          if relevant_proposed_df.empty:
  3566      4823       3960.0      0.8      0.0              self.log_stack_depth -= 1
  3567      4823       2318.0      0.5      0.0              return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df
  3568                                           
  3569                                                   # Iterate over each proposed transaction
  3570        20       1013.0     50.6      0.0          for proposed_index, proposed_row in relevant_proposed_df.iterrows():
  3571                                                       # Find the matching memo rule for the proposed transaction
  3572        10     149544.0  14954.4      0.0              memo_rule_set = memo_set.findMatchingMemoRule(proposed_row['Memo'], proposed_row['Priority'])
  3573        10      14573.0   1457.3      0.0              memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  3574                                           
  3575                                                       # Attempt to execute the transaction
  3576        20 2947348497.0    1e+08     52.6              result = self.attemptTransaction(
  3577        10          4.0      0.4      0.0                  forecast_df=forecast_df,
  3578        10       4736.0    473.6      0.0                  account_set=copy.deepcopy(account_set),
  3579        10          4.0      0.4      0.0                  memo_set=memo_set,
  3580        10          2.0      0.2      0.0                  confirmed_df=confirmed_df,
  3581        10          4.0      0.4      0.0                  proposed_row_df=proposed_row
  3582                                                       )
  3583                                           
  3584                                           
  3585                                                       # Check if the transaction is permitted (returns a DataFrame if successful)
  3586        10         16.0      1.6      0.0              transaction_permitted = isinstance(result, pd.DataFrame)
  3587                                           
  3588        10          5.0      0.5      0.0              if transaction_permitted:
  3589                                                           # Transaction is permitted; update the hypothetical future forecast and account set
  3590         1          0.0      0.0      0.0                  hypothetical_forecast = result
  3591         1      28857.0  28857.0      0.0                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3592                                                       else:
  3593         9          4.0      0.4      0.0                  hypothetical_forecast = None
  3594                                           
  3595                                                       # Handle partial payments if transaction is not permitted and partial payments are allowed
  3596        10        177.0     17.7      0.0              if not transaction_permitted and proposed_row['Partial_Payment_Allowed']:
  3597                                                           # Get the minimum future available balances
  3598         9     341865.0  37985.0      0.0                  min_future_balances = self.getMinimumFutureAvailableBalances(account_set, forecast_df, date_YYYYMMDD)
  3599         9        324.0     36.0      0.0                  max_available_funds = min_future_balances.get(memo_rule_row['Account_From'], 0.0)
  3600                                           
  3601                                                           # Determine the maximum amount that can be transferred to the destination account
  3602        18     755691.0  41982.8      0.0                  reduced_amount = self.calculate_reduced_amount(
  3603         9          1.0      0.1      0.0                      account_set=account_set,
  3604         9          3.0      0.3      0.0                      memo_rule_row=memo_rule_row,
  3605         9          4.0      0.4      0.0                      max_available_funds=max_available_funds,
  3606         9          2.0      0.2      0.0                      forecast_df=forecast_df,
  3607         9          3.0      0.3      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3608                                                           )
  3609                                           
  3610                                                           # Attempt the transaction with the reduced amount if it's greater than zero
  3611         9          6.0      0.7      0.0                  if reduced_amount > 0:
  3612         9        347.0     38.6      0.0                      proposed_row['Amount'] = reduced_amount
  3613                                           
  3614        18 2650518234.0    1e+08     47.3                      result = self.attemptTransaction(
  3615         9          4.0      0.4      0.0                          forecast_df=forecast_df,
  3616         9       4200.0    466.7      0.0                          account_set=copy.deepcopy(account_set),
  3617         9          5.0      0.6      0.0                          memo_set=memo_set,
  3618         9          3.0      0.3      0.0                          confirmed_df=confirmed_df,
  3619         9          3.0      0.3      0.0                          proposed_row_df=proposed_row
  3620                                                               )
  3621                                           
  3622         9         12.0      1.3      0.0                      transaction_permitted = isinstance(result, pd.DataFrame)
  3623                                           
  3624         9          8.0      0.9      0.0                      if transaction_permitted:
  3625         8          5.0      0.6      0.0                          hypothetical_forecast = result
  3626         8     234960.0  29370.0      0.0                          account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3627                                                               else:
  3628         1          1.0      1.0      0.0                          hypothetical_forecast = None
  3629                                           
  3630                                                       # Handle deferrable transactions if not permitted
  3631        10         24.0      2.4      0.0              if not transaction_permitted and proposed_row['Deferrable']:
  3632                                                           # Find the next income date
  3633                                                           next_income_date = self.find_next_income_date(forecast_df, date_YYYYMMDD)
  3634                                           
  3635                                                           # Update the date of the proposed transaction to the next income date
  3636                                                           proposed_row['Date'] = next_income_date
  3637                                           
  3638                                                           # Add the transaction to the deferred DataFrame
  3639                                                           new_deferred_df = pd.concat([new_deferred_df, proposed_row.to_frame().T], ignore_index=True)
  3640                                           
  3641        10         17.0      1.7      0.0              elif not transaction_permitted and not proposed_row['Deferrable']:
  3642                                                           # Add the transaction to the skipped DataFrame
  3643         1        749.0    749.0      0.0                  new_skipped_df = pd.concat([new_skipped_df, proposed_row.to_frame().T], ignore_index=True)
  3644                                           
  3645         9          3.0      0.3      0.0              elif transaction_permitted:
  3646                                                           # Transaction is permitted; execute it and update the forecast and account set
  3647         9          3.0      0.3      0.0                  if priority_level > 1:
  3648         9     262110.0  29123.3      0.0                      account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3649                                           
  3650        18     702284.0  39015.8      0.0                  account_set.executeTransaction(
  3651         9        177.0     19.7      0.0                      Account_From=memo_rule_row['Account_From'],
  3652         9         95.0     10.6      0.0                      Account_To=memo_rule_row['Account_To'],
  3653         9        101.0     11.2      0.0                      Amount=proposed_row['Amount'],
  3654         9          6.0      0.7      0.0                      income_flag=False
  3655                                                           )
  3656                                           
  3657                                                           # Add the transaction to the confirmed DataFrame
  3658         9       6398.0    710.9      0.0                  new_confirmed_df = pd.concat([new_confirmed_df, proposed_row.to_frame().T], ignore_index=True)
  3659                                           
  3660                                                           # Update the forecast DataFrame with the hypothetical future forecast
  3661        18      24057.0   1336.5      0.0                  forecast_df = self.update_forecast_with_hypothetical(
  3662         9          7.0      0.8      0.0                      forecast_df=forecast_df,
  3663         9          6.0      0.7      0.0                      hypothetical_forecast=hypothetical_forecast,
  3664         9          6.0      0.7      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3665                                                           )
  3666                                           
  3667                                                           # Update the account balances in the forecast DataFrame for the current date
  3668        18     272060.0  15114.4      0.0                  self.update_forecast_balances(
  3669         9          3.0      0.3      0.0                      forecast_df=forecast_df,
  3670         9          3.0      0.3      0.0                      account_set=account_set,
  3671         9          3.0      0.3      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3672                                                           )
  3673                                                       else:
  3674                                                           # This case should not occur; raise an error
  3675                                                           raise ValueError(
  3676                                                               "Unexpected case in process_proposed_transactions:\n"
  3677                                                               f"transaction_permitted: {transaction_permitted}\n"
  3678                                                               f"Deferrable: {proposed_row['Deferrable']}\n"
  3679                                                               f"Partial_Payment_Allowed: {proposed_row['Partial_Payment_Allowed']}\n"
  3680                                                           )
  3681                                           
  3682                                                   # Decrement the log stack depth
  3683        10         17.0      1.7      0.0          self.log_stack_depth -= 1
  3684                                           
  3685        10          8.0      0.8      0.0          return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df

Total time: 0.755382 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculate_reduced_amount at line 3687

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3687                                               @profile
  3688                                               def calculate_reduced_amount(self, account_set, memo_rule_row, max_available_funds, forecast_df, date_YYYYMMDD):
  3689                                                   """
  3690                                                   Calculates the maximum amount that can be transferred based on available funds and account types.
  3691                                           
  3692                                                   Parameters:
  3693                                                   - account_set: AccountSet object representing the current state of accounts.
  3694                                                   - memo_rule_row: Series representing the memo rule for the transaction.
  3695                                                   - max_available_funds: Float representing the maximum available funds from the source account.
  3696                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3697                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3698                                           
  3699                                                   Returns:
  3700                                                   - reduced_amount: Float representing the reduced transaction amount.
  3701                                                   """
  3702                                                   # Get the account types for the destination account
  3703         9     237377.0  26375.2     31.4          account_base_names = account_set.getAccounts()['Name'].apply(lambda x: x.split(':')[0])
  3704         9     244033.0  27114.8     32.3          destination_accounts = account_set.getAccounts()[account_base_names == memo_rule_row['Account_To']]
  3705         9        770.0     85.6      0.1          account_types = destination_accounts['Account_Type'].tolist()
  3706                                           
  3707                                                   # Determine the account type
  3708         9          9.0      1.0      0.0          if 'credit curr stmt bal' in account_types and 'credit prev stmt bal' in account_types:
  3709         9          4.0      0.4      0.0              account_type = 'credit'
  3710                                                   elif 'principal balance' in account_types and 'interest' in account_types:
  3711                                                       account_type = 'loan'
  3712                                                   elif len(account_types) == 1 and account_types[0] == 'checking':
  3713                                                       account_type = 'checking'
  3714                                                   else:
  3715                                                       account_type = 'none'
  3716                                           
  3717                                                   # Calculate the maximum amount that can be transferred to the destination account
  3718         9          5.0      0.6      0.0          if account_type == 'credit':
  3719         9       1851.0    205.7      0.2              total_balance = destination_accounts['Balance'].sum()
  3720        18     271156.0  15064.2     35.9              future_min_payment = self.getFutureMinPaymentAmount(
  3721         9        138.0     15.3      0.0                  account_name=memo_rule_row['Account_To'],
  3722         9          4.0      0.4      0.0                  account_set=account_set,
  3723         9          6.0      0.7      0.0                  forecast_df=forecast_df,
  3724         9          5.0      0.6      0.0                  date_YYYYMMDD=date_YYYYMMDD
  3725                                                       )
  3726         9         20.0      2.2      0.0              reduced_amount = min(max_available_funds, total_balance)
  3727                                                   elif account_type in ['checking', 'loan']:
  3728                                                       total_balance = destination_accounts['Balance'].sum()
  3729                                                       reduced_amount = min(max_available_funds, total_balance)
  3730                                                   elif account_type == 'none':
  3731                                                       reduced_amount = max_available_funds
  3732                                                   else:
  3733                                                       raise ValueError('Invalid account type in calculate_reduced_amount')
  3734                                           
  3735         9          4.0      0.4      0.0          return reduced_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: find_next_income_date at line 3737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3737                                               @profile
  3738                                               def find_next_income_date(self, forecast_df, date_YYYYMMDD):
  3739                                                   """
  3740                                                   Finds the next income date after the given date.
  3741                                           
  3742                                                   Parameters:
  3743                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3744                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3745                                           
  3746                                                   Returns:
  3747                                                   - next_income_date: String representing the next income date in 'YYYYMMDD' format.
  3748                                                   """
  3749                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3750                                           
  3751                                                   # Filter future dates
  3752                                                   future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  3753                                           
  3754                                                   # Filter rows where the memo indicates income
  3755                                                   income_rows = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  3756                                           
  3757                                                   if not income_rows.empty:
  3758                                                       next_income_date = income_rows['Date'].iloc[0]
  3759                                                   else:
  3760                                                       # If no future income dates, set to one day after the forecast end date
  3761                                                       end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3762                                                       next_income_date = (end_date + pd.Timedelta(days=1)).strftime('%Y%m%d')
  3763                                           
  3764                                                   return next_income_date

Total time: 0.023787 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_with_hypothetical at line 3766

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3766                                               @profile
  3767                                               def update_forecast_with_hypothetical(self, forecast_df, hypothetical_forecast, date_YYYYMMDD):
  3768                                                   """
  3769                                                   Updates the forecast DataFrame with the hypothetical future forecast starting from the given date.
  3770                                           
  3771                                                   Parameters:
  3772                                                   - forecast_df: DataFrame containing the current forecast data.
  3773                                                   - hypothetical_forecast: DataFrame containing the hypothetical future forecast.
  3774                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3775                                           
  3776                                                   Returns:
  3777                                                   - Updated forecast_df.
  3778                                                   """
  3779                                                   # Split the forecast into past and future
  3780         9       4142.0    460.2     17.4          past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  3781         9       4355.0    483.9     18.3          future_forecast = hypothetical_forecast[hypothetical_forecast['Date'] >= date_YYYYMMDD]
  3782                                           
  3783                                                   # Concatenate the past and updated future forecasts
  3784         9       2585.0    287.2     10.9          updated_forecast = pd.concat([past_forecast, future_forecast], ignore_index=True)
  3785                                           
  3786                                                   # Ensure no duplicate dates
  3787         9      12699.0   1411.0     53.4          updated_forecast = updated_forecast.drop_duplicates(subset=['Date'])
  3788                                           
  3789         9          6.0      0.7      0.0          return updated_forecast

Total time: 0.271641 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_balances at line 3791

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3791                                               @profile
  3792                                               def update_forecast_balances(self, forecast_df, account_set, date_YYYYMMDD):
  3793                                                   """
  3794                                                   Updates the account balances in the forecast DataFrame for the current date based on the account set.
  3795                                           
  3796                                                   Parameters:
  3797                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3798                                                   - account_set: AccountSet object representing the current state of accounts.
  3799                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3800                                                   """
  3801                                                   # Update each account balance in the forecast
  3802        72     243123.0   3376.7     89.5          for index, account_row in account_set.getAccounts().iterrows():
  3803        63       1220.0     19.4      0.4              account_name = account_row['Name']
  3804        63        601.0      9.5      0.2              balance = account_row['Balance']
  3805                                           
  3806        63        161.0      2.6      0.1              if account_name in forecast_df.columns:
  3807        63      26536.0    421.2      9.8                  forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = balance

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processDeferredTransactions at line 4104

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4104                                               @profile
  4105                                               def processDeferredTransactions(self,account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df, priority_level, confirmed_df):
  4106                                                   """
  4107                                                       Processes deferred transactions by attempting to execute them, updating the forecast,
  4108                                                       and handling further deferrals if necessary.
  4109                                           
  4110                                                       Parameters:
  4111                                                       - account_set: AccountSet object representing the current state of accounts.
  4112                                                       - forecast_df: DataFrame containing the forecasted financial data.
  4113                                                       - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  4114                                                       - memo_set: MemoSet object containing memo rules.
  4115                                                       - relevant_deferred_df: DataFrame of deferred transactions relevant to the current date.
  4116                                                       - priority_level: Integer representing the priority level.
  4117                                                       - confirmed_df: DataFrame of confirmed transactions.
  4118                                           
  4119                                                       Returns:
  4120                                                       - forecast_df: Updated forecast DataFrame.
  4121                                                       - new_confirmed_df: DataFrame of newly confirmed transactions.
  4122                                                       - new_deferred_df: DataFrame of transactions that remain deferred.
  4123                                                       """
  4124                                                   # Increment log stack depth for logging purposes
  4125                                                   self.log_stack_depth += 1
  4126                                           
  4127                                                   # Initialize DataFrames for new confirmed and deferred transactions, preserving the schema
  4128                                                   new_confirmed_df = confirmed_df.iloc[0:0].copy()
  4129                                                   new_deferred_df = relevant_deferred_df.iloc[0:0].copy()
  4130                                           
  4131                                                   # Return early if there are no deferred transactions to process
  4132                                                   if relevant_deferred_df.empty:
  4133                                                       self.log_stack_depth -= 1
  4134                                                       return forecast_df, new_confirmed_df, new_deferred_df
  4135                                           
  4136                                                   # Iterate over each deferred transaction
  4137                                                   for deferred_index, deferred_row in relevant_deferred_df.iterrows():
  4138                                                       # Skip if the deferred date is beyond the forecast end date
  4139                                                       deferred_date = deferred_row['Date']
  4140                                                       if datetime.datetime.strptime(deferred_date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD,
  4141                                                                                                                                           '%Y%m%d'):
  4142                                                           continue
  4143                                           
  4144                                                       # Find the matching memo rule for the deferred transaction
  4145                                                       memo_rule_set = memo_set.findMatchingMemoRule(deferred_row['Memo'], deferred_row['Priority'])
  4146                                                       memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  4147                                           
  4148                                                       # Initialize an empty forecast DataFrame for the hypothetical future state
  4149                                                       hypothetical_future_forecast = forecast_df.iloc[0:0].copy()
  4150                                           
  4151                                                       try:
  4152                                                           # Combine the confirmed transactions with the deferred transaction
  4153                                                           updated_confirmed_df = pd.concat([confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4154                                           
  4155                                                           # Create empty DataFrames for proposed, deferred, and skipped transactions
  4156                                                           empty_df = pd.DataFrame(
  4157                                                               columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  4158                                           
  4159                                                           # Compute the optimal forecast including the deferred transaction
  4160                                                           hypothetical_future_forecast = self.computeOptimalForecast(
  4161                                                               start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4162                                                               end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4163                                                               confirmed_df=updated_confirmed_df,
  4164                                                               proposed_df=empty_df,
  4165                                                               deferred_df=empty_df,
  4166                                                               skipped_df=empty_df,
  4167                                                               account_set=copy.deepcopy(
  4168                                                                   self.sync_account_set_w_forecast_day(account_set, forecast_df, self.start_date_YYYYMMDD)
  4169                                                               ),
  4170                                                               memo_rule_set=memo_set
  4171                                                           )[0]
  4172                                           
  4173                                                           transaction_permitted = True
  4174                                                       except ValueError as e:
  4175                                                           # Check if the exception is due to account boundary violations
  4176                                                           if 'Account boundaries were violated' not in str(e):
  4177                                                               # Reraise the exception if it's not expected
  4178                                                               raise e
  4179                                                           transaction_permitted = False
  4180                                           
  4181                                                       if not transaction_permitted and deferred_row['Deferrable']:
  4182                                                           # Look ahead for the next income date
  4183                                                           future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  4184                                                           income_dates = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  4185                                                           if not income_dates.empty:
  4186                                                               next_income_date = income_dates['Date'].iloc[0]
  4187                                                           else:
  4188                                                               # If no future income date, set to one day after forecast end date
  4189                                                               next_income_date = (
  4190                                                                           datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(
  4191                                                                       days=1)).strftime('%Y%m%d')
  4192                                           
  4193                                                           # Update the deferred transaction's date
  4194                                                           deferred_row['Date'] = next_income_date
  4195                                           
  4196                                                           # Add the deferred transaction to the new deferred DataFrame
  4197                                                           new_deferred_df = pd.concat([new_deferred_df, deferred_row.to_frame().T], ignore_index=True)
  4198                                                       elif transaction_permitted:
  4199                                                           # If priority level is greater than 1, sync the account set with the forecast
  4200                                                           if priority_level > 1:
  4201                                                               account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4202                                           
  4203                                                           # Execute the transaction
  4204                                                           account_set.executeTransaction(
  4205                                                               Account_From=memo_rule_row['Account_From'],
  4206                                                               Account_To=memo_rule_row['Account_To'],
  4207                                                               Amount=deferred_row['Amount'],
  4208                                                               income_flag=False
  4209                                                           )
  4210                                           
  4211                                                           # Add the transaction to the new confirmed DataFrame
  4212                                                           new_confirmed_df = pd.concat([new_confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4213                                           
  4214                                                           # Remove the transaction from relevant deferred transactions
  4215                                                           relevant_deferred_df = relevant_deferred_df.drop(deferred_index)
  4216                                           
  4217                                                           # Update the forecast DataFrame with the hypothetical future forecast
  4218                                                           past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  4219                                                           future_forecast = hypothetical_future_forecast[hypothetical_future_forecast['Date'] >= date_YYYYMMDD]
  4220                                                           forecast_df = pd.concat([past_forecast, future_forecast], ignore_index=True)
  4221                                                           forecast_df.drop_duplicates(subset=['Date'], inplace=True)
  4222                                                           forecast_df.reset_index(drop=True, inplace=True)
  4223                                           
  4224                                                           # Update the account balances in the forecast DataFrame for the current date
  4225                                                           for account_row in account_set.getAccounts().itertuples():
  4226                                                               account_name = account_row.Name
  4227                                                               account_balance = account_row.Balance
  4228                                                               if account_name in forecast_df.columns:
  4229                                                                   forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = account_balance
  4230                                                       else:
  4231                                                           # This case should not occur; raise an error
  4232                                                           raise ValueError(f"""This is an edge case that should not be possible
  4233                                                                   transaction_permitted...............: {transaction_permitted}
  4234                                                                   deferred_row.Deferrable.............: {deferred_row['Deferrable']}
  4235                                                                   deferred_row.Partial_Payment_Allowed: {deferred_row['Partial_Payment_Allowed']}
  4236                                                                   """)
  4237                                           
  4238                                                   # Decrement log stack depth
  4239                                                   self.log_stack_depth -= 1
  4240                                           
  4241                                                   # Return the updated forecast and DataFrames
  4242                                                   return forecast_df, new_confirmed_df, new_deferred_df
  4243                                           
  4244                                                   # # log_in_color(logger, 'green', 'debug','ENTER processDeferredTransactions( D:'+str(relevant_deferred_df.shape[0])+' )', self.log_stack_depth)
  4245                                                   # self.log_stack_depth += 1
  4246                                                   #
  4247                                                   # #new_confirmed_df = pd.DataFrame(
  4248                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4249                                                   # #new_deferred_df = pd.DataFrame(
  4250                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4251                                                   # new_confirmed_df = confirmed_df.head(0) #to preserve schema
  4252                                                   # new_deferred_df = relevant_deferred_df.head(0)  # to preserve schema. same as above line btw
  4253                                                   #
  4254                                                   # if relevant_deferred_df.shape[0] == 0:
  4255                                                   #
  4256                                                   #     self.log_stack_depth -= 1
  4257                                                   #     # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4258                                                   #     return forecast_df, new_confirmed_df, new_deferred_df
  4259                                                   #
  4260                                                   # for deferred_item_index, deferred_row_df in relevant_deferred_df.iterrows():
  4261                                                   #     if datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d'):
  4262                                                   #         continue
  4263                                                   #
  4264                                                   #     relevant_memo_rule_set = memo_set.findMatchingMemoRule(deferred_row_df.Memo, deferred_row_df.Priority)
  4265                                                   #     memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  4266                                                   #
  4267                                                   #     hypothetical_future_state_of_forecast = copy.deepcopy(forecast_df.head(0))
  4268                                                   #
  4269                                                   #     try:
  4270                                                   #
  4271                                                   #         not_yet_validated_confirmed_df = pd.concat([confirmed_df, pd.DataFrame(deferred_row_df).T])
  4272                                                   #         #not_yet_validated_confirmed_df = confirmed_df.append(deferred_row_df)
  4273                                                   #
  4274                                                   #         empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  4275                                                   #
  4276                                                   #         # print('process deferred case 1 sync')
  4277                                                   #         hypothetical_future_state_of_forecast = \
  4278                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4279                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4280                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  4281                                                   #                                     proposed_df=empty_df,
  4282                                                   #                                     deferred_df=empty_df,
  4283                                                   #                                     skipped_df=empty_df,
  4284                                                   #                                     account_set=copy.deepcopy(
  4285                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,
  4286                                                   #                                                                              self.start_date_YYYYMMDD)),
  4287                                                   #                                     memo_rule_set=memo_set)[0]
  4288                                                   #
  4289                                                   #         transaction_is_permitted = True
  4290                                                   #     except ValueError as e:
  4291                                                   #         # log_in_color(logger, 'red', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4292                                                   #         if re.search('.*Account boundaries were violated.*',
  4293                                                   #                      str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  4294                                                   #             raise e
  4295                                                   #
  4296                                                   #         transaction_is_permitted = False
  4297                                                   #
  4298                                                   #     if not transaction_is_permitted and deferred_row_df.Deferrable:
  4299                                                   #
  4300                                                   #         # deferred_row_df.Date = (datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') + datetime.timedelta(
  4301                                                   #         #     days=1)).strftime('%Y%m%d')
  4302                                                   #
  4303                                                   #         #look ahead for next income date
  4304                                                   #         future_date_sel_vec = ( d > datetime.datetime.strptime(date_YYYYMMDD,'%Y%m%d') for d in forecast_df.Date )
  4305                                                   #         income_date_sel_vec = ( 'income' in m for m in forecast_df.Memo )
  4306                                                   #         next_income_date = forecast_df[ future_date_sel_vec & income_date_sel_vec ].head(1)['Date']
  4307                                                   #
  4308                                                   #         deferred_row_df.Date = next_income_date
  4309                                                   #         # print('new deferred row')
  4310                                                   #         # print(deferred_row_df.to_string())
  4311                                                   #
  4312                                                   #         #todo what is no future income date
  4313                                                   #
  4314                                                   #         new_deferred_df = pd.concat([new_deferred_df,pd.DataFrame(deferred_row_df).T])
  4315                                                   #
  4316                                                   #     elif transaction_is_permitted:
  4317                                                   #
  4318                                                   #         if priority_level > 1:
  4319                                                   #             # print('process deferred sync case 2')
  4320                                                   #             account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4321                                                   #
  4322                                                   #         account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  4323                                                   #                                        Account_To=memo_rule_row.Account_To, Amount=deferred_row_df.Amount,
  4324                                                   #                                        income_flag=False)
  4325                                                   #
  4326                                                   #
  4327                                                   #         new_confirmed_df = pd.concat([new_confirmed_df, pd.DataFrame(deferred_row_df).T])
  4328                                                   #
  4329                                                   #         remaining_unproposed_deferred_transactions_df = relevant_deferred_df[
  4330                                                   #             ~relevant_deferred_df.index.isin(deferred_row_df.index)]
  4331                                                   #         relevant_deferred_df = remaining_unproposed_deferred_transactions_df
  4332                                                   #
  4333                                                   #         # forecast_df, skipped_df, confirmed_df, deferred_df
  4334                                                   #         forecast_with_accurately_updated_future_rows = hypothetical_future_state_of_forecast
  4335                                                   #
  4336                                                   #         row_sel_vec = [
  4337                                                   #             datetime.datetime.strptime(d, '%Y%m%d') < datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4338                                                   #             in forecast_df.Date]
  4339                                                   #         forecast_rows_to_keep_df = forecast_df.loc[row_sel_vec, :]
  4340                                                   #
  4341                                                   #         row_sel_vec = [
  4342                                                   #             datetime.datetime.strptime(d, '%Y%m%d') >= datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4343                                                   #             in forecast_with_accurately_updated_future_rows.Date]
  4344                                                   #         new_forecast_rows_df = forecast_with_accurately_updated_future_rows.loc[row_sel_vec, :]
  4345                                                   #
  4346                                                   #         forecast_df = pd.concat([forecast_rows_to_keep_df, new_forecast_rows_df])
  4347                                                   #         assert forecast_df.shape[0] == forecast_df.drop_duplicates().shape[0]
  4348                                                   #         forecast_df.reset_index(drop=True, inplace=True)
  4349                                                   #
  4350                                                   #         for account_index, account_row in account_set.getAccounts().iterrows():
  4351                                                   #             if (account_index + 1) == account_set.getAccounts().shape[1]:
  4352                                                   #                 break
  4353                                                   #             relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  4354                                                   #
  4355                                                   #             row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  4356                                                   #             col_sel_vec = (forecast_df.columns == account_row.Name)
  4357                                                   #             forecast_df.iloc[row_sel_vec, col_sel_vec] = relevant_balance
  4358                                                   #     else:
  4359                                                   #         raise ValueError("""This is an edge case that should not be possible
  4360                                                   #                 transaction_is_permitted...............:""" + str(transaction_is_permitted) + """
  4361                                                   #                 budget_item_row.Deferrable.............:""" + str(deferred_row_df.Deferrable) + """
  4362                                                   #                 budget_item_row.Partial_Payment_Allowed:""" + str(deferred_row_df.Partial_Payment_Allowed) + """
  4363                                                   #                 """)
  4364                                                   #
  4365                                                   # self.log_stack_depth -= 1
  4366                                                   # # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4367                                                   # return forecast_df, new_confirmed_df, new_deferred_df

Total time: 2681.75 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeTransactionsForDay at line 4498

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4498                                               @profile
  4499                                               def executeTransactionsForDay(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, proposed_df,
  4500                                                                             deferred_df, skipped_df, priority_level):
  4501     11283       7910.0      0.7      0.0          isP1 = (priority_level == 1)
  4502                                           
  4503                                                   # Filter transactions relevant to the current day and priority level
  4504     22566    2928797.0    129.8      0.1          relevant_proposed_df = proposed_df[
  4505     11283    6418863.0    568.9      0.2              (proposed_df.Priority == priority_level) & (proposed_df.Date == date_YYYYMMDD)]
  4506     22566    2286876.0    101.3      0.1          relevant_confirmed_df = confirmed_df[
  4507     11283    5925724.0    525.2      0.2              (confirmed_df.Priority == priority_level) & (confirmed_df.Date == date_YYYYMMDD)]
  4508     22566    2722626.0    120.7      0.1          relevant_deferred_df = deferred_df[
  4509     11283    6015918.0    533.2      0.2              (deferred_df.Priority <= priority_level) & (deferred_df.Date == date_YYYYMMDD)]
  4510                                           
  4511     11283      17153.0      1.5      0.0          self.log_stack_depth += 1
  4512                                           
  4513                                                   # Ensure no proposed transactions exist for priority 1
  4514     11283       4103.0      0.4      0.0          if isP1:
  4515      6440      54137.0      8.4      0.0              assert relevant_proposed_df.empty
  4516                                           
  4517                                                   # Check if there are pending confirmed transactions
  4518     11283      81029.0      7.2      0.0          thereArePendingConfirmedTransactions = not relevant_confirmed_df.empty
  4519                                           
  4520                                                   # Check if the current day exists in the forecast and if it's within the forecast range
  4521     11283    2037951.0    180.6      0.1          date_sel_vec = forecast_df['Date'] == date_YYYYMMDD
  4522     11283    2313050.0    205.0      0.1          noMatchingDayInForecast = forecast_df.loc[date_sel_vec].empty
  4523     22566    1124112.0     49.8      0.0          notPastEndOfForecast = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') <= datetime.datetime.strptime(
  4524     11283       8545.0      0.8      0.0              self.end_date_YYYYMMDD, '%Y%m%d')
  4525                                           
  4526                                                   # Add a new day to the forecast if required
  4527     11283       5049.0      0.4      0.0          if isP1 and noMatchingDayInForecast and notPastEndOfForecast:
  4528      6440    8569818.0   1330.7      0.3              forecast_df = self.addANewDayToTheForecast(forecast_df, date_YYYYMMDD)
  4529                                           
  4530                                                   # Sort transactions to prioritize income first
  4531     11283       6143.0      0.5      0.0          if isP1 and thereArePendingConfirmedTransactions:
  4532      6440    8138546.0   1263.7      0.3              relevant_confirmed_df = self.sortTxnsToPutIncomeFirst(relevant_confirmed_df)
  4533                                           
  4534                                                   # Sync account set with the forecast for non-priority 1 transactions
  4535     11283       7415.0      0.7      0.0          if priority_level > 1:
  4536      4843  141212513.0  29158.1      5.3              account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4537                                           
  4538                                                   # Process confirmed transactions
  4539     22566 2482916429.0 110029.1     92.6          forecast_df = self.processConfirmedTransactions(forecast_df, relevant_confirmed_df, memo_set, account_set,
  4540     11283       3698.0      0.3      0.0                                                          date_YYYYMMDD)
  4541                                           
  4542                                                   # Process proposed transactions for priority levels greater than 1
  4543     11273       6713.0      0.6      0.0          if priority_level > 1:
  4544      9666    2252741.0    233.1      0.1              forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df = self.processProposedTransactions(
  4545      4833       2656.0      0.5      0.0                  account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, relevant_proposed_df, priority_level
  4546                                                       )
  4547                                           
  4548                                                       # Update confirmed, deferred, and skipped DataFrames
  4549      4833    2413865.0    499.5      0.1              confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4550      4833    2107615.0    436.1      0.1              deferred_df = pd.concat([deferred_df, new_deferred_df]).reset_index(drop=True)
  4551      4833    2106404.0    435.8      0.1              skipped_df = pd.concat([skipped_df, new_skipped_df]).reset_index(drop=True)
  4552                                           
  4553                                                       # Process deferred transactions if any exist
  4554      4833      31835.0      6.6      0.0              if not deferred_df.empty:
  4555                                                           relevant_deferred_before_processing = relevant_deferred_df.copy()  # Keep original for comparison
  4556                                           
  4557                                                           forecast_df, new_confirmed_df, new_deferred_df = self.processDeferredTransactions(
  4558                                                               account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df.copy(), priority_level,
  4559                                                               confirmed_df
  4560                                                           )
  4561                                           
  4562                                                           # Update confirmed DataFrame with newly confirmed transactions
  4563                                                           confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4564                                           
  4565                                                           # Adjust deferred DataFrame by removing processed transactions and adding new deferred ones
  4566                                                           not_relevant_deferred_df = deferred_df[
  4567                                                               (deferred_df.Priority > priority_level) | (deferred_df.Date != date_YYYYMMDD)]
  4568                                                           deferred_df = pd.concat([not_relevant_deferred_df, new_deferred_df]).reset_index(drop=True)
  4569                                           
  4570     11273      15309.0      1.4      0.0          self.log_stack_depth -= 1
  4571                                           
  4572     11273       7120.0      0.6      0.0          return [forecast_df, confirmed_df, deferred_df, skipped_df]

Total time: 591.258 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculateLoanInterestAccrualsForDay at line 5426

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5426                                               @profile
  5427                                               def calculateLoanInterestAccrualsForDay(self, account_set, current_forecast_row_df):
  5428                                                   """
  5429                                                   Calculates and applies interest accruals for loans on the current day.
  5430                                           
  5431                                                   Parameters:
  5432                                                   - account_set: AccountSet object containing account information.
  5433                                                   - current_forecast_row_df: DataFrame containing the forecast row for the current date.
  5434                                           
  5435                                                   Returns:
  5436                                                   - Updated current_forecast_row_df with applied interest accruals.
  5437                                                   """
  5438                                                   # Increment log stack depth for logging purposes
  5439      6440      10948.0      1.7      0.0          self.log_stack_depth += 1
  5440                                           
  5441                                                   # print('PRE INTEREST ACCRUAL FORECAST ROW')
  5442                                                   # print(current_forecast_row_df.to_string())
  5443                                           
  5444                                                   # Extract the current date
  5445      6440     404815.0     62.9      0.1          current_date = current_forecast_row_df['Date'].iat[0]
  5446                                           
  5447                                                   # Iterate over each account to calculate interest accruals
  5448     51520  179196483.0   3478.2     30.3          for account_index, account_row in account_set.getAccounts().iterrows():
  5449                                                       # Skip accounts that are not interest-bearing or are previous statement balances
  5450     45080     825782.0     18.3      0.1              if account_row['Account_Type'] == 'credit prev stmt bal':
  5451      6440       2071.0      0.3      0.0                  continue
  5452                                           
  5453                                                       # Get the interest cadence and type
  5454     38640     423114.0     11.0      0.1              if account_row.get('Interest_Cadence', '') is not None:
  5455     12880     128973.0     10.0      0.0                  interest_cadence = account_row.get('Interest_Cadence', '').lower()
  5456                                                       else:
  5457                                                           continue
  5458                                           
  5459     12880     122484.0      9.5      0.0              if account_row.get('Interest_Type', '') is not None:
  5460     12880     121896.0      9.5      0.0                  interest_type = account_row.get('Interest_Type', '').lower()
  5461                                                       else:
  5462                                                           continue
  5463                                           
  5464                                                       # # Skip if interest cadence or type is not defined
  5465                                                       # if not interest_cadence or interest_cadence == 'none' or not interest_type:
  5466                                                       #     continue
  5467                                           
  5468                                                       # Calculate the number of days since the billing start date
  5469     12880     109944.0      8.5      0.0              billing_start_date = account_row['Billing_Start_Date']
  5470     25760    7756149.0    301.1      1.3              num_days = (pd.to_datetime(current_date, format='%Y%m%d') - pd.to_datetime(billing_start_date,
  5471     12880       6862.0      0.5      0.0                                                                                         format='%Y%m%d')).days
  5472                                           
  5473                                                       # Skip if current date is before billing start date
  5474     12880       9116.0      0.7      0.0              if num_days < 0:
  5475                                                           continue
  5476                                           
  5477                                                       # Generate date sequence based on billing start date and interest cadence
  5478                                                       # Assume generate_date_sequence is a function that returns a set of dates
  5479     25760   20739216.0    805.1      3.5              dseq = generate_date_sequence(start_date_YYYYMMDD=billing_start_date, num_days=num_days,
  5480     12880       4147.0      0.3      0.0                                            cadence=interest_cadence)
  5481                                           
  5482                                                       # Include billing start date if current date matches
  5483     12880       9984.0      0.8      0.0              if current_date == billing_start_date:
  5484                                                           dseq.append(current_date)
  5485                                           
  5486                                                       # Check if current date is in the interest accrual dates
  5487     12880      87613.0      6.8      0.0              if current_date in dseq:
  5488     12880     255490.0     19.8      0.0                  apr = account_row['APR']
  5489     12880     129623.0     10.1      0.0                  balance = account_row['Balance']
  5490                                           
  5491                                                           # Calculate interest based on type and cadence
  5492     12880       7932.0      0.6      0.0                  if interest_type == 'compound':
  5493                                                               if interest_cadence == 'monthly':
  5494                                                                   # Compound interest, monthly accrual
  5495                                                                   interest_accrued = balance * (apr / 12)
  5496                                                                   # Update account balance
  5497                                                                   account_set.accounts[account_index].balance += interest_accrued
  5498                                           
  5499                                                                   # # Move current statement balance to previous statement balance for credit accounts
  5500                                                                   # if account_row['Account_Type'] == 'credit curr stmt bal':
  5501                                                                   #     prev_account_index = account_index - 1
  5502                                                                   #     prev_stmt_balance = account_set.accounts[prev_account_index].balance
  5503                                                                   #     account_set.accounts[account_index].balance += prev_stmt_balance
  5504                                                                   #     account_set.accounts[prev_account_index].balance = 0
  5505                                                               else:
  5506                                                                   # Other compound interest cadences not implemented
  5507                                                                   raise NotImplementedError(
  5508                                                                       f"Compound interest with '{interest_cadence}' cadence is not implemented.")
  5509     12880       8999.0      0.7      0.0                  elif interest_type == 'simple':
  5510     12880       6309.0      0.5      0.0                      if interest_cadence == 'daily':
  5511                                                                   # Simple interest, daily accrual
  5512     12880      12599.0      1.0      0.0                          interest_accrued = balance * (apr / 365.25)
  5513                                           
  5514                                                                   # print('current_date, Name, interest '+str(current_date)+' '+str(account_row.Name)+' '+str(round(interest_accrued,2)))
  5515                                           
  5516                                                                   # Update interest account balance (assuming it's the next account)
  5517     12880       7195.0      0.6      0.0                          interest_account_index = account_index + 1
  5518     12880      17333.0      1.3      0.0                          if interest_account_index < len(account_set.accounts):
  5519     12880      19635.0      1.5      0.0                              account_set.accounts[interest_account_index].balance += interest_accrued
  5520                                                                       # Round small balances to zero
  5521     12880      14592.0      1.1      0.0                              if abs(account_set.accounts[interest_account_index].balance) < 0.01:
  5522      6440       6356.0      1.0      0.0                                  account_set.accounts[interest_account_index].balance = 0.0
  5523                                                               else:
  5524                                                                   # Other simple interest cadences not implemented
  5525                                                                   raise NotImplementedError(
  5526                                                                       f"Simple interest with '{interest_cadence}' cadence is not implemented.")
  5527                                                           else:
  5528                                                               raise ValueError(f"Unknown interest type '{interest_type}' for account '{account_row['Name']}'.")
  5529                                           
  5530                                                       # print('PRE-UPDATE ACCRUAL FORECAST ROW')
  5531                                                       # print(current_forecast_row_df.to_string())
  5532                                           
  5533                                                       # Update the current forecast row with the updated account balances
  5534    103040  359500444.0   3488.9     60.8              for idx, acc_row in account_set.getAccounts().iterrows():
  5535     90160    1770309.0     19.6      0.3                  account_name = acc_row['Name']
  5536     90160     870143.0      9.7      0.1                  balance = acc_row['Balance']
  5537     90160     241855.0      2.7      0.0                  if account_name in current_forecast_row_df.columns:
  5538     90160   18413746.0    204.2      3.1                      current_forecast_row_df.iloc[0,current_forecast_row_df.columns == account_name] = round(balance,2)
  5539                                                               #current_forecast_row_df.at[0, account_name] = balance
  5540                                           
  5541                                                       # print('POST-UPDATE ACCRUAL FORECAST ROW')
  5542                                                       # print(current_forecast_row_df.to_string())
  5543                                           
  5544                                                   # Decrement log stack depth
  5545      6440      12916.0      2.0      0.0          self.log_stack_depth -= 1
  5546                                           
  5547                                                   # print('POST INTEREST ACCRUAL FORECAST ROW')
  5548                                                   # print(current_forecast_row_df.to_string())
  5549                                           
  5550                                                   # Return the updated forecast row DataFrame
  5551      6440       2711.0      0.4      0.0          return current_forecast_row_df

Total time: 421.415 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeCreditCardMinimumPayments at line 5691

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5691                                               @profile
  5692                                               def executeCreditCardMinimumPayments(self, forecast_df, account_set, current_forecast_row_df):
  5693                                                   """
  5694                                                   Executes minimum payments for credit card accounts.
  5695                                           
  5696                                                   Parameters:
  5697                                                   - forecast_df: DataFrame containing forecasted financial data.
  5698                                                   - account_set: The current set of accounts.
  5699                                                   - current_forecast_row_df: The forecast row for the current date.
  5700                                           
  5701                                                   Returns:
  5702                                                   - Updated current_forecast_row_df after executing credit card minimum payments.
  5703                                                   """
  5704                                                   #log_in_color(logger, 'cyan', 'debug', 'ENTER executeMinimumPayments() ', self.log_stack_depth)
  5705      6440      10866.0      1.7      0.0          self.log_stack_depth += 1
  5706      6440      16332.0      2.5      0.0          primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5707                                           
  5708                                                   # Loop through accounts to process credit card minimum payments
  5709     51520  179872087.0   3491.3     42.7          for account_index, account_row in account_set.getAccounts().iterrows():
  5710     45080    1271139.0     28.2      0.3              if account_row.Account_Type != 'credit prev stmt bal':
  5711     38640      12417.0      0.3      0.0                  continue
  5712                                           
  5713                                                       # Skip accounts without a billing start date
  5714      6440     103278.0     16.0      0.0              billing_start_date = account_row.Billing_Start_Date
  5715      6440      25338.0      3.9      0.0              if pd.isnull(billing_start_date) or billing_start_date == 'None':
  5716                                                           continue
  5717                                           
  5718      6440     552994.0     85.9      0.1              current_date_str = current_forecast_row_df.Date.iloc[0]
  5719      6440     434130.0     67.4      0.1              current_date = datetime.datetime.strptime(current_date_str, '%Y%m%d')
  5720                                           
  5721      6440     235584.0     36.6      0.1              billing_start_datetime = datetime.datetime.strptime(billing_start_date, '%Y%m%d')
  5722      6440       9967.0      1.5      0.0              num_days = (current_date - billing_start_datetime).days
  5723                                           
  5724                                                       # Generate billing days
  5725      6440       2923.0      0.5      0.0              if num_days >= 0:
  5726      6440    5634662.0    874.9      1.3                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5727                                                       else:
  5728                                                           billing_days = set()
  5729                                           
  5730      6440       5131.0      0.8      0.0              if current_date_str == billing_start_date:
  5731                                                           billing_days.add(current_date_str)
  5732                                           
  5733      6440       3324.0      0.5      0.0              if current_date_str not in billing_days:
  5734      6240       2113.0      0.3      0.0                  continue
  5735                                           
  5736                                                       # Calculate advance payments made during the billing cycle
  5737       400    6425198.0  16063.0      1.5              advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  5738       200       5886.0     29.4      0.0                  account_row.Name, account_set, forecast_df, current_date_str
  5739                                                       )
  5740                                           
  5741                                                       # Determine the earliest billing date within the forecast range
  5742       200       9097.0     45.5      0.0              first_day_of_forecast_str = forecast_df.Date.iloc[0]
  5743       200      11969.0     59.8      0.0              first_day_of_forecast = datetime.datetime.strptime(first_day_of_forecast_str, '%Y%m%d')
  5744                                           
  5745       400      99302.0    248.3      0.0              relevant_billing_days = [
  5746       200         73.0      0.4      0.0                  d for d in billing_days
  5747                                                           if datetime.datetime.strptime(d, '%Y%m%d') > first_day_of_forecast
  5748                                                       ]
  5749                                           
  5750       200        111.0      0.6      0.0              if not relevant_billing_days:
  5751                                                           continue
  5752                                           
  5753       200        284.0      1.4      0.0              earliest_billing_date_within_forecast_range = min(relevant_billing_days)
  5754       200        150.0      0.8      0.0              if current_date_str == earliest_billing_date_within_forecast_range:
  5755                                                           # First billing date in forecast range
  5756        20       3208.0    160.4      0.0                  current_prev_stmt_balance = forecast_df.iloc[0][account_row.Name]
  5757        20         11.0      0.6      0.0                  prev_prev_stmt_balance = current_prev_stmt_balance
  5758        20     536720.0  26836.0      0.1                  current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5759                                                       else:
  5760                                                           # Get previous billing cycle data
  5761       180        700.0      3.9      0.0                  left_check_bound = current_date - datetime.timedelta(days=35)
  5762       180    1103145.0   6128.6      0.3                  forecast_dates = forecast_df['Date'].apply(lambda d: datetime.datetime.strptime(d, '%Y%m%d'))
  5763       360      40965.0    113.8      0.0                  check_region = forecast_df[
  5764       180     100038.0    555.8      0.0                      (forecast_dates > left_check_bound) & (forecast_dates <= current_date)
  5765                                                               ]
  5766                                           
  5767       180      67257.0    373.6      0.0                  previous_min_payment_dates = check_region['Memo Directives'].str.contains('CC MIN PAYMENT')
  5768       180      14960.0     83.1      0.0                  if previous_min_payment_dates.any():
  5769       180      56921.0    316.2      0.0                      prev_prev_stmt_balance = check_region.loc[previous_min_payment_dates, account_row.Name].iat[0]
  5770                                                           else:
  5771                                                               prev_prev_stmt_balance = 0
  5772                                           
  5773       180       4282.0     23.8      0.0                  current_prev_stmt_balance = account_row.Balance
  5774       180    5188658.0  28825.9      1.2                  current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5775                                           
  5776                                                       # Calculate interest and principal to be charged
  5777       200       4915.0     24.6      0.0              interest_rate_monthly = account_row.APR / 12
  5778       200       1463.0      7.3      0.0              interest_charged = round(prev_prev_stmt_balance * interest_rate_monthly, 2)
  5779       200        130.0      0.7      0.0              principal_charged = prev_prev_stmt_balance * 0.01
  5780       200        133.0      0.7      0.0              current_due = principal_charged + interest_charged
  5781                                           
  5782                                           
  5783                                                       # blindly copied from gpt
  5784       200         93.0      0.5      0.0              min_payment = (
  5785       200       3752.0     18.8      0.0                  current_due if current_due > 0 and current_due > account_row.Minimum_Payment else
  5786                                                           (
  5787                                                               account_row.Minimum_Payment if (current_prev_stmt_balance + current_curr_stmt_balance) > account_row.Minimum_Payment else (current_prev_stmt_balance + current_curr_stmt_balance)) if current_due > 0 else 0
  5788                                                       )
  5789                                           
  5790       200        160.0      0.8      0.0              total_payment_due = min_payment - advance_payment_amount
  5791       200        114.0      0.6      0.0              if total_payment_due <= 0:
  5792                                                           payment_toward_prev = 0
  5793                                                           payment_toward_curr = 0
  5794                                                       else:
  5795       200        134.0      0.7      0.0                  if current_prev_stmt_balance >= total_payment_due:
  5796       200         98.0      0.5      0.0                      payment_toward_prev = total_payment_due
  5797       200        101.0      0.5      0.0                      payment_toward_curr = 0
  5798                                                           else:
  5799                                                               payment_toward_prev = current_prev_stmt_balance
  5800                                                               payment_toward_curr = total_payment_due - payment_toward_prev
  5801                                           
  5802                                                       # Update account balances and memo directives
  5803       200        112.0      0.6      0.0              if interest_charged > 0:
  5804       200        576.0      2.9      0.0                  account_set.accounts[account_index].balance += interest_charged
  5805       200       4121.0     20.6      0.0                  interest_md_text = f'; CC INTEREST ({account_row.Name} +${interest_charged:.2f}); '
  5806       200      12984.0     64.9      0.0                  if interest_md_text not in current_forecast_row_df['Memo Directives'].iat[0]:
  5807       200      83551.0    417.8      0.0                      current_forecast_row_df['Memo Directives'] += interest_md_text
  5808                                           
  5809       200        223.0      1.1      0.0              total_payment = payment_toward_prev + payment_toward_curr
  5810       200        137.0      0.7      0.0              if total_payment > 0:
  5811       400   16861654.0  42154.1      4.0                  account_set.executeTransaction(
  5812       200         77.0      0.4      0.0                      Account_From=primary_checking_account_name,
  5813       200       5115.0     25.6      0.0                      Account_To=account_row.Name.split(':')[0],
  5814       200         88.0      0.4      0.0                      Amount=total_payment
  5815                                                           )
  5816                                           
  5817       200        178.0      0.9      0.0                  memo_parts = []
  5818       200        159.0      0.8      0.0                  if payment_toward_prev > 0:
  5819       400        348.0      0.9      0.0                      memo_parts.append(
  5820       200       7168.0     35.8      0.0                          f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Prev Stmt Bal -${payment_toward_prev:.2f}); '
  5821                                                               )
  5822       200        153.0      0.8      0.0                  if payment_toward_curr > 0:
  5823                                                               memo_parts.append(
  5824                                                                   f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Curr Stmt Bal -${payment_toward_curr:.2f}); '
  5825                                                               )
  5826       200        162.0      0.8      0.0                  if total_payment > 0:
  5827       400        246.0      0.6      0.0                      memo_parts.append(
  5828       200        252.0      1.3      0.0                          f'CC MIN PAYMENT ({primary_checking_account_name} -${total_payment:.2f}); '
  5829                                                               )
  5830       200      77380.0    386.9      0.0                  current_forecast_row_df['Memo Directives'] += ''.join(memo_parts)
  5831                                                       elif 'CC MIN PAYMENT' in current_forecast_row_df['Memo Directives'] or advance_payment_amount > 0:
  5832                                                               current_forecast_row_df['Memo Directives'] += (
  5833                                                                   f'CC MIN PAYMENT ALREADY MADE ({account_row.Name.split(":")[0]}: Prev Stmt Bal -$0.00); '
  5834                                                                   f'CC MIN PAYMENT ALREADY MADE ({primary_checking_account_name} -$0.00); '
  5835                                                               )
  5836                                                       #else:  there was no min payment, and one is not necessary now
  5837                                           
  5838                                                       # Clean up memo directives
  5839       400       1370.0      3.4      0.0              memo_directives = [
  5840       200      12514.0     62.6      0.0                  md.strip() for md in current_forecast_row_df['Memo Directives'].iat[0].split(';') if md.strip()
  5841                                                       ]
  5842       200      17808.0     89.0      0.0              current_forecast_row_df['Memo Directives'] = '; '.join(memo_directives)
  5843                                           
  5844                                                   # Update balances in current forecast row
  5845     51520  180469484.0   3502.9     42.8          for account_index, account_row in account_set.getAccounts().iterrows():
  5846     45080     855205.0     19.0      0.2              current_balance = account_row['Balance']
  5847     45080     435697.0      9.7      0.1              account_name = account_row['Name']
  5848     45080    8303527.0    184.2      2.0              current_forecast_row_df[account_name] = current_balance
  5849                                           
  5850                                                       # Move current statement balance to previous if it's a billing day
  5851     45080    1096854.0     24.3      0.3              if account_row.Account_Type == 'credit prev stmt bal':
  5852      6440     106918.0     16.6      0.0                  billing_start_date = account_row.Billing_Start_Date
  5853      6440    5492064.0    852.8      1.3                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5854      6440       6484.0      1.0      0.0                  if current_date_str in billing_days:
  5855       200    5630490.0  28152.5      1.3                      curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5856       200        542.0      2.7      0.0                      account_set.accounts[account_index].balance += curr_stmt_balance
  5857       200        288.0      1.4      0.0                      account_set.accounts[account_index - 1].balance = 0
  5858       200      25358.0    126.8      0.0                      current_forecast_row_df[account_row.Name] = account_set.accounts[account_index].balance
  5859       200      18091.0     90.5      0.0                      current_forecast_row_df[account_set.accounts[account_index - 1].name] = 0
  5860                                           
  5861      6440      12540.0      1.9      0.0          self.log_stack_depth -= 1
  5862      6440       2628.0      0.4      0.0          return current_forecast_row_df

Total time: 1668.73 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeLoanMinimumPayments at line 5864

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5864                                               @profile
  5865                                               def executeLoanMinimumPayments(self, account_set, current_forecast_row_df):
  5866                                           
  5867      6440     154391.0     24.0      0.0          primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5868                                           
  5869                                                   #logger.debug('self.log_stack_depth += 1')
  5870      6440       8135.0      1.3      0.0          self.log_stack_depth += 1
  5871                                           
  5872                                                   # the branch logic here assumes the sort order of accounts in account list
  5873     51520  179358967.0   3481.3     10.7          for account_index, account_row in account_set.getAccounts().iterrows():
  5874                                           
  5875     45080    1208554.0     26.8      0.1              if account_row.Account_Type == 'prev smt bal':
  5876                                                           continue
  5877                                           
  5878                                                       #not sure why both of these checks are necessary
  5879     45080     739414.0     16.4      0.0              if account_row.Billing_Start_Date == 'None':
  5880                                                           continue
  5881                                           
  5882     45080     772464.0     17.1      0.0              if pd.isnull(account_row.Billing_Start_Date):
  5883     25760       8266.0      0.3      0.0                  continue
  5884                                           
  5885                                                       # print(BEGIN_GREEN + row.to_string() + RESET_COLOR)
  5886                                                       # print('current_forecast_row_df.Date - row.Billing_Start_Date:')
  5887                                                       # print('current_forecast_row_df.Date:')
  5888                                                       # print(current_forecast_row_df.Date)
  5889                                                       # print('row.Billing_Start_Date:')
  5890                                                       # print(row.Billing_Start_Date)
  5891                                           
  5892     19320    3141878.0    162.6      0.2              num_days = (datetime.datetime.strptime(current_forecast_row_df.Date.iloc[0],'%Y%m%d') - datetime.datetime.strptime(account_row.Billing_Start_Date,'%Y%m%d')).days
  5893                                                       #billing_days = set(generate_date_sequence(account_row.Billing_Start_Date.strftime('%Y%m%d'), num_days, account_row.Interest_Cadence))
  5894     19320   14141083.0    731.9      0.8              billing_days = set(generate_date_sequence(account_row.Billing_Start_Date, num_days, 'monthly'))
  5895                                           
  5896                                                       # if the input date matches the start date, add it to the set (bc range where start = end == null set)
  5897     19320    1331041.0     68.9      0.1              if current_forecast_row_df.Date.iloc[0] == account_row.Billing_Start_Date:
  5898                                                           billing_days = set(current_forecast_row_df.Date).union(billing_days)
  5899                                           
  5900     19320     594642.0     30.8      0.0              if current_forecast_row_df.Date.iloc[0] in billing_days:
  5901                                                           # log_in_color(logger,'green', 'debug', 'Processing minimum payments', self.log_stack_depth)
  5902                                                           # log_in_color(logger,'green', 'debug', 'account_row:', self.log_stack_depth)
  5903                                                           # log_in_color(logger,'green', 'debug', account_row.to_string(), self.log_stack_depth)
  5904                                           
  5905                                                           # print(row)
  5906                                                           # if account_row.Account_Type == 'credit prev stmt bal':  # cc min payment
  5907                                                           #
  5908                                                           #     #minimum_payment_amount = max(40, account_row.Balance * 0.033) #this is an estimate
  5909                                                           #     minimum_payment_amount = max(40, account_row.Balance * account_row.APR/12)
  5910                                                           #     #todo it turns out that the way this really works is that Chase uses 1% PLUS the interest accrued to be charged immediately, not added to the principal
  5911                                                           #     #very much not how I designed this but not earth-shatteringly different
  5912                                                           #
  5913                                                           #
  5914                                                           #     payment_toward_prev = round(min(minimum_payment_amount, account_row.Balance),2)
  5915                                                           #     payment_toward_curr = round(min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev),2)
  5916                                                           #
  5917                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  5918                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  5919                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  5920                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  5921                                                           #
  5922                                                           #         if payment_toward_prev > 0:
  5923                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Prev Stmt Bal -$'+str(payment_toward_prev) + '); '
  5924                                                           #         if payment_toward_curr > 0:
  5925                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Curr Stmt Bal -$' + str(payment_toward_curr) + '); '
  5926                                                           #         #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' cc min payment ($' + str(minimum_payment_amount) + ') ; '
  5927                                                           #
  5928                                                           # el
  5929       600      10441.0     17.4      0.0                  if account_row.Account_Type == 'principal balance':  # loan min payment
  5930                                           
  5931       400   10923938.0  27309.8      0.7                      minimum_payment_amount = account_set.getAccounts().loc[account_index, :].Minimum_Payment
  5932                                           
  5933                                                               #todo I notice that this depends on the order of accounts
  5934                                                               #if an accountset was created by manually adding sub accounts, and this is done in the wrong order
  5935                                                               #there will be unexpected behavior BECAUSE OF this part of the code
  5936                                           
  5937                                                               #new
  5938       400       8312.0     20.8      0.0                      current_pbal_balance = account_row.Balance
  5939       400   10900916.0  27252.3      0.7                      current_interest_balance = account_set.getAccounts().loc[account_index + 1, :].Balance
  5940       400        536.0      1.3      0.0                      current_debt_balance = current_pbal_balance + current_interest_balance
  5941                                           
  5942                                                               # payment_toward_interest = round(min(minimum_payment_amount, current_interest_balance),2)
  5943                                                               # payment_toward_principal = round(min(current_pbal_balance, minimum_payment_amount - payment_toward_interest),2)
  5944                                           
  5945       400        882.0      2.2      0.0                      payment_toward_interest = min(minimum_payment_amount, current_interest_balance)
  5946       400        403.0      1.0      0.0                      payment_toward_principal = min(current_pbal_balance, minimum_payment_amount - payment_toward_interest)
  5947                                           
  5948                                                               #old
  5949                                                               #current_debt_balance = account_set.getBalances()[account_row.Name.split(':')[0]]
  5950                                           
  5951                                           
  5952       400        325.0      0.8      0.0                      loan_payment_amount = min(current_debt_balance,minimum_payment_amount)
  5953                                           
  5954       400        239.0      0.6      0.0                      if loan_payment_amount > 0:
  5955       800   32345281.0  40431.6      1.9                          account_set.executeTransaction(Account_From=primary_checking_account_name, Account_To=account_row.Name.split(':')[0],
  5956                                                                                                  # Note that the execute transaction method will split the amount paid between the 2 accounts
  5957       400        150.0      0.4      0.0                                                         Amount=loan_payment_amount)
  5958                                           
  5959       400       1170.0      2.9      0.0                          if payment_toward_interest > 0:
  5960                                                                       #current_forecast_row_df.Memo += ' loan min payment (' + account_row.Name.split(':')[0] + ': Interest -$' + str(round(payment_toward_interest,2)) + '); ' #
  5961       200     102529.0    512.6      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Interest -$' + str(f'{payment_toward_interest:.2f}') + '); '
  5962                                           
  5963       400        576.0      1.4      0.0                          if payment_toward_principal > 0:
  5964                                                                       #current_forecast_row_df.Memo += ' loan min payment ('+account_row.Name.split(':')[0] +': Principal Balance -$' + str(round(payment_toward_principal,2)) + '); '
  5965       400     170858.0    427.1      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Principal Balance -$' + str(f'{payment_toward_principal:.2f}') + '); '
  5966                                           
  5967                                                                   #add checking note
  5968       400        870.0      2.2      0.0                          if ( payment_toward_interest + payment_toward_principal ) > 0 :
  5969       400     126005.0    315.0      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT ('+primary_checking_account_name+' -$' + str(f'{( payment_toward_interest + payment_toward_principal ):.2f}') + '); '
  5970                                           
  5971                                                                   #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' loan min payment ($' + str(minimum_payment_amount) + '); '
  5972                                           
  5973                                           
  5974                                                           # if account_row.Account_Type == 'credit prev stmt bal' or account_row.Account_Type == 'interest':
  5975                                                           #
  5976                                                           #     payment_toward_prev = min(minimum_payment_amount, account_row.Balance)
  5977                                                           #     payment_toward_curr = min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev)
  5978                                                           #     surplus_payment = minimum_payment_amount - (payment_toward_prev + payment_toward_curr)
  5979                                                           #
  5980                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  5981                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  5982                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  5983                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  5984                                           
  5985                                                   # print('current_forecast_row_df pre-update')
  5986                                                   # print(current_forecast_row_df.to_string())
  5987     51520  179799968.0   3489.9     10.8          for account_index, account_row in account_set.getAccounts().iterrows():
  5988     45080 1219637489.0  27055.0     73.1              relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  5989     45080    4856436.0    107.7      0.3              col_sel_vec = (current_forecast_row_df.columns == account_row.Name)
  5990                                                       #print('Setting '+account_row.Name+' to '+str(relevant_balance))
  5991     45080    8367531.0    185.6      0.5              current_forecast_row_df.iloc[0, col_sel_vec] = round(relevant_balance,2)
  5992                                           
  5993                                                   # print('current_forecast_row_df post-update')
  5994                                                   # print(current_forecast_row_df.to_string())
  5995                                           
  5996                                                   # log_in_color(logger,'green', 'debug', 'return this row:', self.log_stack_depth)
  5997                                                   # log_in_color(logger,'green', 'debug', current_forecast_row_df.to_string(), self.log_stack_depth)
  5998      6440      12379.0      1.9      0.0          self.log_stack_depth -= 1
  5999                                                   #log_in_color(logger,'cyan', 'debug', 'EXIT  executeMinimumPayments() ', self.log_stack_depth)
  6000                                                   #logger.debug('self.log_stack_depth -= 1')
  6001                                           
  6002      6440       2375.0      0.4      0.0          return current_forecast_row_df

Total time: 0.341263 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getMinimumFutureAvailableBalances at line 6004

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6004                                               @profile
  6005                                               def getMinimumFutureAvailableBalances(self, account_set, forecast_df, date_YYYYMMDD):
  6006                                                   """
  6007                                                   Calculates the minimum future available balances for each account starting from the specified date.
  6008                                           
  6009                                                   Parameters:
  6010                                                   - account_set: AccountSet object containing account information.
  6011                                                   - forecast_df: DataFrame containing the forecasted financial data.
  6012                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  6013                                           
  6014                                                   Returns:
  6015                                                   - future_available_balances: Dictionary mapping account names to their minimum future available balances.
  6016                                                   """
  6017                                           
  6018                                                   # Increment log stack depth (if used for logging)
  6019         9          9.0      1.0      0.0          self.log_stack_depth += 1
  6020                                           
  6021                                                   # Convert date string to datetime object for comparison
  6022         9        582.0     64.7      0.2          current_date = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d')
  6023                                           
  6024                                                   # Ensure 'Date' column is in datetime format
  6025                                                   #forecast_df['Date_dt'] = pd.to_datetime(forecast_df['Date'], format='%Y%m%d')
  6026                                           
  6027                                                   # Filter forecast_df for current and future dates
  6028         9      90751.0  10083.4     26.6          current_and_future_forecast_df = forecast_df[ [ datetime.datetime.strptime(d,'%Y%m%d') >= current_date for d in forecast_df['Date'] ] ]
  6029                                           
  6030                                                   # Get the account information
  6031         9     238513.0  26501.4     69.9          accounts_df = account_set.getAccounts()
  6032         9          5.0      0.6      0.0          future_available_balances = {}
  6033                                           
  6034        72       7440.0    103.3      2.2          for account_index, account_row in accounts_df.iterrows():
  6035        63       1029.0     16.3      0.3              full_account_name = account_row['Name']
  6036        63         73.0      1.2      0.0              account_name = full_account_name.split(':')[0]
  6037        63        597.0      9.5      0.2              account_type = account_row['Account_Type'].lower()
  6038                                           
  6039                                                       # Check if account exists in forecast_df columns
  6040        63        136.0      2.2      0.0              if account_name not in forecast_df.columns:
  6041        54         18.0      0.3      0.0                  continue
  6042                                           
  6043         9          6.0      0.7      0.0              if account_type == 'checking':
  6044                                                           # Calculate minimum future balance minus minimum required balance
  6045         9       1950.0    216.7      0.6                  min_future_balance = current_and_future_forecast_df[account_name].min()
  6046         9        133.0     14.8      0.0                  min_available_balance = min_future_balance - account_row['Min_Balance']
  6047         9          3.0      0.3      0.0                  future_available_balances[account_name] = min_available_balance
  6048                                           
  6049                                                       elif account_type == 'credit prev stmt bal':
  6050                                                           # Get indices for previous and current statement balance accounts
  6051                                                           prev_index = account_index
  6052                                                           curr_index = account_index - 1
  6053                                           
  6054                                                           # Ensure the current index is valid
  6055                                                           if curr_index < 0:
  6056                                                               continue
  6057                                           
  6058                                                           prev_stmt_account_name = accounts_df.iloc[prev_index]['Name']
  6059                                                           curr_stmt_account_name = accounts_df.iloc[curr_index]['Name']
  6060                                           
  6061                                                           # Check if both accounts exist in forecast_df columns
  6062                                                           if prev_stmt_account_name not in forecast_df.columns or curr_stmt_account_name not in forecast_df.columns:
  6063                                                               continue
  6064                                           
  6065                                                           # Sum the balances of previous and current statement balances
  6066                                                           total_credit_balance = current_and_future_forecast_df[prev_stmt_account_name] + \
  6067                                                                                  current_and_future_forecast_df[curr_stmt_account_name]
  6068                                           
  6069                                                           # Calculate the minimum total credit balance
  6070                                                           min_total_credit_balance = total_credit_balance.min()
  6071                                           
  6072                                                           # Calculate available credit
  6073                                                           max_balance = account_row['Max_Balance']
  6074                                                           min_available_credit = max_balance - min_total_credit_balance - account_row['Min_Balance']
  6075                                                           future_available_balances[account_name] = min_available_credit
  6076                                           
  6077                                                   # Decrement log stack depth
  6078         9         15.0      1.7      0.0          self.log_stack_depth -= 1
  6079                                           
  6080         9          3.0      0.3      0.0          return future_available_balances

Total time: 1472.65 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: sync_account_set_w_forecast_day at line 6082

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6082                                               @profile
  6083                                               def sync_account_set_w_forecast_day(self, account_set, forecast_df, date_YYYYMMDD):
  6084                                           
  6085     49670 1320653982.0  26588.6     89.7          Accounts_df = account_set.getAccounts()
  6086     49670   23614953.0    475.4      1.6          relevant_forecast_day = forecast_df[forecast_df.Date == date_YYYYMMDD]
  6087                                           
  6088    397360   42669589.0    107.4      2.9          for account_index, account_row in Accounts_df.iterrows():
  6089    347690    1157666.0      3.3      0.1              if (account_index + 1) == Accounts_df.shape[1]:
  6090                                                           break
  6091                                           
  6092    347690   62214344.0    178.9      4.2              row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  6093                                           
  6094    347690     151758.0      0.4      0.0              try:
  6095    347690    7299433.0     21.0      0.5                  assert sum(row_sel_vec) > 0
  6096                                                       except Exception as e:
  6097                                                           error_msg = "error in sync_account_set_w_forecast_day\n"
  6098                                                           error_msg += "date_YYYYMMDD: "+date_YYYYMMDD+"\n"
  6099                                                           error_msg += "min date of forecast:"+min(forecast_df.Date)+"\n"
  6100                                                           error_msg += "max date of forecast:"+max(forecast_df.Date)+"\n"
  6101                                                           raise AssertionError(error_msg)
  6102                                           
  6103    347690   14515486.0     41.7      1.0              relevant_balance = relevant_forecast_day.iat[0, account_index + 1]
  6104    347690     355643.0      1.0      0.0              account_set.accounts[account_index].balance = relevant_balance
  6105                                           
  6106     49670      17091.0      0.3      0.0          return account_set

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_stmt_balance at line 7239

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7239                                               @profile
  7240                                               def _propagate_credit_curr_stmt_balance(self, relevant_account_info_df,
  7241                                                                                       account_deltas_list,
  7242                                                                                       future_rows_only_df,
  7243                                                                                       forecast_df):
  7244                                                   """
  7245                                                   Propagates changes to the credit card current statement balance into the future forecast.
  7246                                           
  7247                                                   Parameters:
  7248                                                   - relevant_account_info_df: DataFrame containing account information.
  7249                                                   - account_deltas_list: List of deltas for each account (excluding 'Date' column).
  7250                                                   - future_rows_only_df: DataFrame containing future forecast rows.
  7251                                                   - forecast_df: The original forecast DataFrame.
  7252                                           
  7253                                                   Returns:
  7254                                                   - Updated future_rows_only_df DataFrame.
  7255                                                   """
  7256                                                   # Extract the account name for the current statement balance
  7257                                                   curr_stmt_bal_account_series = relevant_account_info_df[
  7258                                                       relevant_account_info_df['Account_Type'] == 'credit curr stmt bal']['Name']
  7259                                                   if curr_stmt_bal_account_series.empty:
  7260                                                       # Handle the case where the account type is not found
  7261                                                       raise ValueError("Account type 'credit curr stmt bal' not found in relevant_account_info_df")
  7262                                                   curr_stmt_bal_account_name = curr_stmt_bal_account_series.iat[0]
  7263                                           
  7264                                                   # Create a Series mapping account names to deltas
  7265                                                   account_names = forecast_df.columns[1:]  # Exclude 'Date' column
  7266                                                   account_deltas_series = pd.Series(account_deltas_list, index=account_names)
  7267                                           
  7268                                                   # Get the delta for the current statement balance account
  7269                                                   try:
  7270                                                       curr_stmt_delta = account_deltas_series[curr_stmt_bal_account_name]
  7271                                                   except KeyError:
  7272                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in account_deltas_list")
  7273                                           
  7274                                                   # Update the future forecast DataFrame
  7275                                                   if curr_stmt_bal_account_name in future_rows_only_df.columns:
  7276                                                       future_rows_only_df[curr_stmt_bal_account_name] += curr_stmt_delta
  7277                                                   else:
  7278                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in future_rows_only_df columns")
  7279                                           
  7280                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_only at line 7283

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7283                                               @profile
  7284                                               def _propagate_credit_curr_only(self, relevant_account_info_df,
  7285                                                                                       account_deltas_list,
  7286                                                                                       future_rows_only_df,
  7287                                                                                       forecast_df,
  7288                                                                                       account_set_before_p2_plus_txn,
  7289                                                                                       billing_dates_dict,
  7290                                                                                       date_string_YYYYMMDD,
  7291                                                                                       post_txn_row_df):
  7292                                                   """
  7293                                                   Propagates credit card payments involving only the current statement balance into the future forecast.
  7294                                           
  7295                                                   Parameters:
  7296                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7297                                                   - account_deltas_list: List of account balance changes (deltas).
  7298                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7299                                                   - forecast_df: The original forecast DataFrame.
  7300                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7301                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7302                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7303                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7304                                           
  7305                                                   Returns:
  7306                                                   - Updated future_rows_only_df DataFrame.
  7307                                                   """
  7308                                           
  7309                                                   # Extract relevant account names
  7310                                                   checking_account_name = relevant_account_info_df[
  7311                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7312                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  7313                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  7314                                                   # Construct the previous statement balance account name
  7315                                                   prev_stmt_bal_account_name = curr_stmt_bal_account_name.replace('Curr Stmt Bal', 'Prev Stmt Bal')
  7316                                           
  7317                                                   # Get billing dates and next billing date
  7318                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7319                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7320                                                   if future_billing_dates:
  7321                                                       next_billing_date = str(min(future_billing_dates))
  7322                                                   else:
  7323                                                       next_billing_date = None
  7324                                           
  7325                                                   # Get account indices in forecast_df
  7326                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7327                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7328                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  7329                                           
  7330                                                   # Get account deltas
  7331                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  7332                                                   checking_delta = curr_stmt_delta
  7333                                                   previous_stmt_delta = 0.0
  7334                                           
  7335                                                   # Iterate over future forecast rows
  7336                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7337                                                       date_iat = f_row['Date']
  7338                                                       md_to_keep = []
  7339                                           
  7340                                                       if date_iat == next_billing_date:
  7341                                                           # At the next billing date, process memo directives
  7342                                           
  7343                                                           # Initialize memo variables
  7344                                                           og_curr_memo = ''
  7345                                                           og_check_memo = ''
  7346                                                           og_curr_amount = 0.0
  7347                                                           og_check_amount = 0.0
  7348                                           
  7349                                                           # Parse memo directives
  7350                                                           for md in f_row['Memo Directives'].split(';'):
  7351                                                               md = md.strip()
  7352                                                               if not md:
  7353                                                                   continue
  7354                                           
  7355                                                               if f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  7356                                                                   og_curr_memo = md
  7357                                                                   og_curr_amount = self._parse_memo_amount(md)
  7358                                                                   curr_stmt_delta += og_curr_amount
  7359                                                                   checking_delta += og_curr_amount
  7360                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7361                                                                   og_check_memo = md
  7362                                                                   og_check_amount = self._parse_memo_amount(md)
  7363                                                               else:
  7364                                                                   md_to_keep.append(md)
  7365                                           
  7366                                                           # Move curr_stmt_delta to previous_stmt_delta as the current balance moves to previous
  7367                                                           previous_stmt_delta += curr_stmt_delta
  7368                                                           curr_stmt_delta = 0.0
  7369                                           
  7370                                                           # Update memo directives
  7371                                                           new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  7372                                                           md_to_keep.append(new_curr_memo)
  7373                                           
  7374                                                           if og_check_memo:
  7375                                                               # Adjust the checking memo amount
  7376                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - og_curr_amount)
  7377                                                               md_to_keep.append(new_check_memo)
  7378                                           
  7379                                                       else:
  7380                                                           # No adjustments needed on other dates
  7381                                                           pass
  7382                                           
  7383                                                       # Update balances
  7384                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7385                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  7386                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7387                                           
  7388                                                       # Clean and update memo directives
  7389                                                       md_to_keep = [md for md in md_to_keep if md]
  7390                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7391                                           
  7392                                                       # Reset deltas for the next iteration
  7393                                                       checking_delta = 0.0
  7394                                                       curr_stmt_delta = 0.0
  7395                                                       previous_stmt_delta = 0.0
  7396                                           
  7397                                                   return future_rows_only_df

Total time: 96.4953 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_only at line 7399

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7399                                               @profile
  7400                                               def _propagate_credit_payment_prev_only(self, relevant_account_info_df,
  7401                                                                                       account_deltas_list,
  7402                                                                                       future_rows_only_df,
  7403                                                                                       forecast_df,
  7404                                                                                       account_set_before_p2_plus_txn,
  7405                                                                                       billing_dates_dict,
  7406                                                                                       date_string_YYYYMMDD,
  7407                                                                                       post_txn_row_df):
  7408                                                   """
  7409                                                   Propagates credit card payments involving only the previous statement balance into the future forecast.
  7410                                           
  7411                                                   Parameters:
  7412                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7413                                                   - account_deltas_list: List of account balance changes (deltas).
  7414                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7415                                                   - forecast_df: The original forecast DataFrame.
  7416                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7417                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7418                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7419                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7420                                           
  7421                                                   Returns:
  7422                                                   - Updated future_rows_only_df DataFrame.
  7423                                                   """
  7424                                           
  7425                                                   # Extract relevant account names
  7426       273      48558.0    177.9      0.1          checking_account_name = relevant_account_info_df[
  7427       182      20660.0    113.5      0.0              relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7428       273      27960.0    102.4      0.0          prev_stmt_bal_account_name = relevant_account_info_df[
  7429       182      18622.0    102.3      0.0              relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  7430                                           
  7431                                                   # Get billing dates and next billing date
  7432        91         56.0      0.6      0.0          cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7433        91       1437.0     15.8      0.0          future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7434        91         45.0      0.5      0.0          if future_billing_dates:
  7435        91        186.0      2.0      0.0              next_billing_date = str(min(future_billing_dates))
  7436                                                   else:
  7437                                                       next_billing_date = None
  7438                                           
  7439                                                   # Get account indices in forecast_df
  7440        91        546.0      6.0      0.0          checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7441        91        286.0      3.1      0.0          prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7442                                           
  7443                                                   # Get account deltas
  7444        91         74.0      0.8      0.0          previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  7445        91         36.0      0.4      0.0          checking_delta = previous_stmt_delta
  7446                                           
  7447                                                   # Initialize previous previous statement balance
  7448        91         40.0      0.4      0.0          previous_prev_stmt_bal = 0.0
  7449                                           
  7450                                                   # Iterate over future forecast rows
  7451     19794    1380775.0     69.8      1.4          for f_i, f_row in future_rows_only_df.iterrows():
  7452     19703     260129.0     13.2      0.3              date_iat = f_row['Date']
  7453     19703       8895.0      0.5      0.0              md_to_keep = []
  7454                                           
  7455     19703      11582.0      0.6      0.0              if date_iat == next_billing_date:
  7456                                                           # Handle next billing date (payment due date)
  7457                                           
  7458                                                           # Initialize memo variables
  7459        91         24.0      0.3      0.0                  og_check_memo = ''
  7460        91         30.0      0.3      0.0                  og_prev_memo = ''
  7461        91         31.0      0.3      0.0                  og_min_payment_amount = 0.0
  7462                                           
  7463                                                           # Parse memo directives
  7464       364       1143.0      3.1      0.0                  for md in f_row['Memo Directives'].split(';'):
  7465       273        194.0      0.7      0.0                      md = md.strip()
  7466       273        114.0      0.4      0.0                      if not md:
  7467                                                                   continue
  7468                                           
  7469       273        230.0      0.8      0.0                      if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7470        91         33.0      0.4      0.0                          og_prev_memo = md
  7471       182        118.0      0.6      0.0                      elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7472        91         34.0      0.4      0.0                          og_check_memo = md
  7473                                                               else:
  7474        91         59.0      0.6      0.0                          md_to_keep.append(md)
  7475                                           
  7476                                                           # Get advance payment amount
  7477       182    2724403.0  14969.2      2.8                  advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  7478        91         32.0      0.4      0.0                      prev_stmt_bal_account_name,
  7479        91         37.0      0.4      0.0                      account_set_before_p2_plus_txn,
  7480        91         32.0      0.4      0.0                      forecast_df,
  7481        91         29.0      0.3      0.0                      date_iat
  7482                                                           )
  7483                                           
  7484                                                           # Get minimum payment amount
  7485        91       2473.0     27.2      0.0                  og_min_payment_amount = self._parse_memo_amount(og_check_memo)
  7486                                           
  7487                                                           # Adjust deltas
  7488        91        156.0      1.7      0.0                  payment_to_apply = min(og_min_payment_amount, advance_payment_amount)
  7489        91         76.0      0.8      0.0                  previous_stmt_delta += payment_to_apply
  7490        91         41.0      0.5      0.0                  checking_delta += payment_to_apply
  7491                                           
  7492                                                           # Update previous_prev_stmt_bal
  7493        91       2068.0     22.7      0.0                  previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7494                                           
  7495                                                           # Adjust memo directives
  7496        91         71.0      0.8      0.0                  if advance_payment_amount >= og_min_payment_amount:
  7497                                                               new_check_memo = self._update_memo_amount(og_check_memo, 0.00)
  7498                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  7499                                                           else:
  7500        91         56.0      0.6      0.0                      remaining_payment = og_min_payment_amount - advance_payment_amount
  7501        91       2721.0     29.9      0.0                      new_check_memo = self._update_memo_amount(og_check_memo, remaining_payment)
  7502        91       1232.0     13.5      0.0                      new_prev_memo = self._update_memo_amount(og_prev_memo, remaining_payment)
  7503                                           
  7504        91        124.0      1.4      0.0                  md_to_keep.extend([new_check_memo, new_prev_memo])
  7505                                           
  7506     19612      20293.0      1.0      0.0              elif date_iat in cc_billing_dates and previous_prev_stmt_bal != 0:
  7507                                                           # Handle other billing dates after payment has been made
  7508                                           
  7509                                                           # Initialize memo variables
  7510       571        330.0      0.6      0.0                  og_min_payment_amount = 0.0
  7511                                           
  7512                                                           # Parse memo directives
  7513      2284       7408.0      3.2      0.0                  for md in f_row['Memo Directives'].split(';'):
  7514      1713       2181.0      1.3      0.0                      md = md.strip()
  7515      1713        884.0      0.5      0.0                      if not md:
  7516                                                                   continue
  7517                                           
  7518      1713       2097.0      1.2      0.0                      if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7519       571       7709.0     13.5      0.0                          og_min_payment_amount = self._parse_memo_amount(md)
  7520                                           
  7521                                                                   # Calculate interest and current due
  7522      1142   15119138.0  13239.2     15.7                          account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7523       571   14967963.0  26213.6     15.5                              account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7524                                                                       ]
  7525       571      50065.0     87.7      0.1                          apr = account_row['APR'].iat[0]
  7526       571       2929.0      5.1      0.0                          interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7527       571        420.0      0.7      0.0                          principal_due = previous_prev_stmt_bal * 0.01
  7528       571        405.0      0.7      0.0                          current_due = principal_due + interest_to_be_charged
  7529                                           
  7530       571        663.0      1.2      0.0                          new_min_payment_amount = round(current_due, 2)
  7531                                           
  7532                                                                   # Adjust deltas
  7533       571        355.0      0.6      0.0                          previous_stmt_delta += new_min_payment_amount
  7534       571        347.0      0.6      0.0                          checking_delta += new_min_payment_amount
  7535                                           
  7536                                                                   # Update memo directive
  7537       571      22938.0     40.2      0.0                          new_md = self._update_memo_amount(md, new_min_payment_amount)
  7538       571        482.0      0.8      0.0                          md_to_keep.append(new_md)
  7539                                           
  7540      1142       1106.0      1.0      0.0                      elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  7541      1142   15173403.0  13286.7     15.7                          account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7542       571   14984706.0  26242.9     15.5                              account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7543                                                                       ]
  7544       571      50317.0     88.1      0.1                          apr = account_row['APR'].iat[0]
  7545       571       3135.0      5.5      0.0                          interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7546                                           
  7547       571      12407.0     21.7      0.0                          og_interest_amount = self._parse_memo_amount(md)
  7548       571        415.0      0.7      0.0                          previous_stmt_delta += interest_to_be_charged
  7549                                           
  7550                                                                   # Update memo directive
  7551       571      13742.0     24.1      0.0                          new_md = self._update_memo_amount(md, interest_to_be_charged)
  7552       571        620.0      1.1      0.0                          md_to_keep.append(new_md)
  7553                                           
  7554       571        547.0      1.0      0.0                      elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7555       571       8856.0     15.5      0.0                          og_check_amount = self._parse_memo_amount(md)
  7556                                           
  7557                                                                   # Calculate interest and current due
  7558      1142   15127274.0  13246.3     15.7                          account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7559       571   14989071.0  26250.6     15.5                              account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7560                                                                       ]
  7561       571      50522.0     88.5      0.1                          apr = account_row['APR'].iat[0]
  7562       571       2987.0      5.2      0.0                          interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7563       571        466.0      0.8      0.0                          principal_due = previous_prev_stmt_bal * 0.01
  7564       571        397.0      0.7      0.0                          current_due = principal_due + interest_to_be_charged
  7565                                           
  7566       571        689.0      1.2      0.0                          new_min_payment_amount = round(current_due, 2)
  7567                                           
  7568                                                                   # Update memo directive
  7569       571      20468.0     35.8      0.0                          new_md = self._update_memo_amount(md, new_min_payment_amount)
  7570       571        584.0      1.0      0.0                          md_to_keep.append(new_md)
  7571                                           
  7572                                                               else:
  7573                                                                   md_to_keep.append(md)
  7574                                           
  7575                                                           # Update previous_prev_stmt_bal
  7576       571      14085.0     24.7      0.0                  previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7577                                           
  7578                                                       else:
  7579                                                           # No adjustments needed
  7580                                                           pass
  7581                                           
  7582                                                       # Update balances
  7583     19703     550490.0     27.9      0.6              future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7584     19703     454848.0     23.1      0.5              future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7585                                           
  7586                                                       # Clean and update memo directives
  7587     19703      24097.0      1.2      0.0              md_to_keep = [md for md in md_to_keep if md]
  7588     19703     287992.0     14.6      0.3              future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7589                                           
  7590        91         40.0      0.4      0.0          return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_interest_only at line 7592

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7592                                               @profile
  7593                                               def _propagate_loan_payment_interest_only(self, relevant_account_info_df,
  7594                                                                                         account_deltas_list,
  7595                                                                                         future_rows_only_df,
  7596                                                                                         forecast_df,
  7597                                                                                         account_set_before_p2_plus_txn,
  7598                                                                                         billing_dates_dict,
  7599                                                                                         date_string_YYYYMMDD,
  7600                                                                                         post_txn_row_df):
  7601                                                   """
  7602                                                   Propagates loan payments involving only the interest into the future forecast.
  7603                                           
  7604                                                   Parameters:
  7605                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7606                                                   - account_deltas_list: List of account balance changes (deltas).
  7607                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7608                                                   - forecast_df: The original forecast DataFrame.
  7609                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7610                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7611                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7612                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7613                                           
  7614                                                   Returns:
  7615                                                   - Updated future_rows_only_df DataFrame.
  7616                                                   """
  7617                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_interest_only', self.log_stack_depth)
  7618                                                   self.log_stack_depth += 1
  7619                                                   # log_in_color(logger, 'cyan', 'debug', 'BEFORE future_rows_only_df', self.log_stack_depth)
  7620                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7621                                           
  7622                                                   # Extract relevant account names
  7623                                                   checking_account_name = relevant_account_info_df[
  7624                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7625                                                   interest_account_name = relevant_account_info_df[
  7626                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  7627                                                   # Construct the principal balance account name based on the interest account name
  7628                                                   pbal_account_name = interest_account_name.split(':')[0] + ': Principal Balance'
  7629                                           
  7630                                                   # Get the APR for the principal balance account
  7631                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7632                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7633                                                   apr = pbal_row_df['APR'].iat[0]
  7634                                           
  7635                                                   # Get billing dates and next billing date
  7636                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7637                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7638                                                   if future_billing_dates:
  7639                                                       next_billing_date = str(min(future_billing_dates))
  7640                                                   else:
  7641                                                       next_billing_date = None
  7642                                           
  7643                                                   # Get account indices in forecast_df
  7644                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7645                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7646                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7647                                           
  7648                                                   # Get account deltas
  7649                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  7650                                                   checking_delta = interest_delta  # Since only interest is involved
  7651                                           
  7652                                                   # Iterate over future forecast rows
  7653                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7654                                                       date_iat = f_row['Date']
  7655                                                       md_to_keep = []
  7656                                           
  7657                                                       if date_iat == next_billing_date:
  7658                                                           # Handle next billing date (payment due date)
  7659                                           
  7660                                                           # Initialize amounts
  7661                                                           interest_amount = 0.0
  7662                                           
  7663                                                           # Parse memo directives
  7664                                                           for md in f_row['Memo Directives'].split(';'):
  7665                                                               md = md.strip()
  7666                                                               if not md:
  7667                                                                   continue
  7668                                           
  7669                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7670                                                                   interest_amount = self._parse_memo_amount(md)
  7671                                                                   interest_delta += interest_amount
  7672                                                                   checking_delta += interest_amount
  7673                                                               else:
  7674                                                                   md_to_keep.append(md)
  7675                                           
  7676                                                           # Remove the checking memo directive
  7677                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${interest_amount:.2f})'
  7678                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7679                                           
  7680                                                       elif date_iat in loan_billing_dates:
  7681                                                           # Handle other billing dates
  7682                                           
  7683                                                           # Initialize variables
  7684                                                           interest_paid_amount = 0.0
  7685                                                           og_interest_md = ''
  7686                                           
  7687                                                           # Parse memo directives
  7688                                                           for md in f_row['Memo Directives'].split(';'):
  7689                                                               md = md.strip()
  7690                                                               if not md:
  7691                                                                   continue
  7692                                           
  7693                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7694                                                                   interest_paid_amount = self._parse_memo_amount(md)
  7695                                                                   og_interest_md = md
  7696                                                               else:
  7697                                                                   md_to_keep.append(md)
  7698                                           
  7699                                                           # Get interest balance at the time of charge
  7700                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  7701                                           
  7702                                                           # Adjust interest memo
  7703                                                           if interest_balance <= interest_paid_amount:
  7704                                                               new_interest_amount = interest_balance
  7705                                                               og_interest_surplus = interest_paid_amount - interest_balance
  7706                                                               new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  7707                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7708                                                           else:
  7709                                                               new_interest_amount = interest_paid_amount
  7710                                                               og_interest_surplus = 0.0
  7711                                                               new_interest_md = og_interest_md
  7712                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7713                                           
  7714                                                           # Update memo directives
  7715                                                           md_to_keep.extend([new_interest_md, new_checking_interest_md])
  7716                                           
  7717                                                           # Adjust deltas
  7718                                                           checking_delta += og_interest_surplus
  7719                                                           interest_delta += og_interest_surplus
  7720                                           
  7721                                                       else:
  7722                                                           # No adjustments needed for other dates
  7723                                                           pass
  7724                                           
  7725                                                       # Apply daily interest accrual
  7726                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  7727                                                           if f_i == 0:
  7728                                                               # Set interest to the value after the transaction
  7729                                           
  7730                                                               #this is the OG line, but I think this keeps the OG index so this fails
  7731                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  7732                                                               #instead of reindexing (bc expensive) lets try this:
  7733                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  7734                                                           else:
  7735                                                               # Set interest equal to the previous day's interest
  7736                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  7737                                                                   f_i - 1, interest_account_name]
  7738                                           
  7739                                                           # Calculate interest accrued on this day
  7740                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7741                                                           interest_accrued = pbal_balance * (apr / 365.25)
  7742                                           
  7743                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  7744                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  7745                                           
  7746                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  7747                                           
  7748                                                       # Update balances
  7749                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7750                                           
  7751                                                       # Clean and update memo directives
  7752                                                       md_to_keep = [md for md in md_to_keep if md]
  7753                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7754                                           
  7755                                                       log_in_color(logger, 'cyan', 'debug', 'f_i:'+str(f_i), self.log_stack_depth)
  7756                                           
  7757                                                   # log_in_color(logger, 'cyan', 'debug', 'AFTER future_rows_only_df', self.log_stack_depth)
  7758                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7759                                                   self.log_stack_depth -= 1
  7760                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_interest_only', self.log_stack_depth)
  7761                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_only at line 7763

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7763                                               @profile
  7764                                               def _propagate_loan_payment_pbal_only(self, relevant_account_info_df,
  7765                                                                                     account_deltas_list,
  7766                                                                                     future_rows_only_df,
  7767                                                                                     forecast_df,
  7768                                                                                     account_set_before_p2_plus_txn,
  7769                                                                                     billing_dates_dict,
  7770                                                                                     date_string_YYYYMMDD,
  7771                                                                                     post_txn_row_df):
  7772                                                   """
  7773                                                   Propagates loan payments involving only the principal balance into the future forecast.
  7774                                           
  7775                                                   Parameters:
  7776                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7777                                                   - account_deltas_list: List of account balance changes (deltas).
  7778                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7779                                                   - forecast_df: The original forecast DataFrame.
  7780                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7781                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7782                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7783                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7784                                           
  7785                                                   Returns:
  7786                                                   - Updated future_rows_only_df DataFrame.
  7787                                                   """
  7788                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_only', self.log_stack_depth)
  7789                                                   self.log_stack_depth += 1
  7790                                           
  7791                                                   # Extract relevant account names
  7792                                                   checking_account_name = relevant_account_info_df[
  7793                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7794                                                   pbal_account_name = relevant_account_info_df[
  7795                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  7796                                                   # Construct the interest account name based on the principal balance account name
  7797                                                   interest_account_name = pbal_account_name.split(':')[0] + ': Interest'
  7798                                           
  7799                                                   # Get the APR for the principal balance account
  7800                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7801                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7802                                                   apr = pbal_row_df['APR'].iat[0]
  7803                                           
  7804                                                   # Get billing dates and next billing date
  7805                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7806                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7807                                                   if future_billing_dates:
  7808                                                       next_billing_date = str(min(future_billing_dates))
  7809                                                   else:
  7810                                                       next_billing_date = None
  7811                                           
  7812                                                   # Get account indices in forecast_df
  7813                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7814                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7815                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7816                                           
  7817                                                   # Get account deltas
  7818                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  7819                                                   checking_delta = pbal_delta  # Since only principal balance is involved
  7820                                           
  7821                                                   # Iterate over future forecast rows
  7822                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7823                                                       date_iat = f_row['Date']
  7824                                                       md_to_keep = []
  7825                                           
  7826                                                       if date_iat == next_billing_date:
  7827                                                           # Handle next billing date (payment due date)
  7828                                           
  7829                                                           # Initialize amounts
  7830                                                           pbal_amount = 0.0
  7831                                           
  7832                                                           # Parse memo directives
  7833                                                           for md in f_row['Memo Directives'].split(';'):
  7834                                                               md = md.strip()
  7835                                                               if not md:
  7836                                                                   continue
  7837                                           
  7838                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7839                                                                   pbal_amount = self._parse_memo_amount(md)
  7840                                                                   pbal_delta += pbal_amount
  7841                                                                   checking_delta += pbal_amount
  7842                                                               else:
  7843                                                                   md_to_keep.append(md)
  7844                                           
  7845                                                           # Remove the checking memo directive
  7846                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${pbal_amount:.2f})'
  7847                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7848                                           
  7849                                                       elif date_iat in loan_billing_dates:
  7850                                                           # Handle other billing dates
  7851                                           
  7852                                                           # Initialize variables
  7853                                                           pbal_paid_amount = 0.0
  7854                                                           og_pbal_md = ''
  7855                                           
  7856                                                           # Parse memo directives
  7857                                                           for md in f_row['Memo Directives'].split(';'):
  7858                                                               md = md.strip()
  7859                                                               if not md:
  7860                                                                   continue
  7861                                           
  7862                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7863                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  7864                                                                   og_pbal_md = md
  7865                                                               else:
  7866                                                                   md_to_keep.append(md)
  7867                                           
  7868                                                           # Get balance at the time of charge
  7869                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7870                                           
  7871                                                           # Adjust principal balance memo
  7872                                                           if pbal_balance <= pbal_paid_amount:
  7873                                                               new_pbal_amount = pbal_balance
  7874                                                               og_pbal_surplus = pbal_paid_amount - pbal_balance
  7875                                                               final_recredit_checking = og_pbal_surplus
  7876                                                               new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  7877                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7878                                                           else:
  7879                                                               new_pbal_amount = pbal_paid_amount
  7880                                                               og_pbal_surplus = 0.0
  7881                                                               final_recredit_checking = 0.0
  7882                                                               new_pbal_md = og_pbal_md
  7883                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7884                                           
  7885                                                           # Update memo directives
  7886                                                           md_to_keep.extend([new_pbal_md, new_checking_pbal_md])
  7887                                           
  7888                                                           # Adjust deltas
  7889                                                           checking_delta += final_recredit_checking
  7890                                                           pbal_delta += og_pbal_surplus
  7891                                           
  7892                                                       else:
  7893                                                           # No adjustments needed for other dates
  7894                                                           pass
  7895                                           
  7896                                                       # Update balances
  7897                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7898                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  7899                                           
  7900                                                       # Apply daily interest accrual
  7901                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  7902                                                           if f_i == 0:
  7903                                                               # Set interest to the value after the transaction
  7904                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  7905                                                           else:
  7906                                                               # Set interest equal to the previous day's interest
  7907                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  7908                                                                   f_i - 1, interest_account_name]
  7909                                           
  7910                                                           # Calculate interest accrued on this day
  7911                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7912                                                           interest_accrued = pbal_balance * (apr / 365.25)
  7913                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  7914                                           
  7915                                                       # Clean and update memo directives
  7916                                                       md_to_keep = [md for md in md_to_keep if md]
  7917                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7918                                           
  7919                                                   self.log_stack_depth -= 1
  7920                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_only', self.log_stack_depth)
  7921                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_interest at line 7923

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7923                                               @profile
  7924                                               def _propagate_loan_payment_pbal_interest(self, relevant_account_info_df,
  7925                                                                                         account_deltas_list,
  7926                                                                                         future_rows_only_df,
  7927                                                                                         forecast_df,
  7928                                                                                         account_set_before_p2_plus_txn,
  7929                                                                                         billing_dates_dict,
  7930                                                                                         date_string_YYYYMMDD,
  7931                                                                                         post_txn_row_df):
  7932                                                   """
  7933                                                   Propagates loan payments involving principal balance and interest into the future forecast.
  7934                                           
  7935                                                   Parameters:
  7936                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7937                                                   - account_deltas_list: List of account balance changes (deltas).
  7938                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7939                                                   - forecast_df: The original forecast DataFrame.
  7940                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7941                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7942                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7943                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7944                                           
  7945                                                   Returns:
  7946                                                   - Updated future_rows_only_df DataFrame.
  7947                                                   """
  7948                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  7949                                                   self.log_stack_depth += 1
  7950                                           
  7951                                                   # Extract relevant account names
  7952                                                   checking_account_name = relevant_account_info_df[
  7953                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7954                                                   pbal_account_name = relevant_account_info_df[
  7955                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  7956                                                   interest_account_name = relevant_account_info_df[
  7957                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  7958                                           
  7959                                                   # Get the APR for the principal balance account
  7960                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7961                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7962                                                   apr = pbal_row_df['APR'].iat[0]
  7963                                           
  7964                                                   # Get billing dates and next billing date
  7965                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7966                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7967                                                   if future_billing_dates:
  7968                                                       next_billing_date = str(min(future_billing_dates))
  7969                                                   else:
  7970                                                       next_billing_date = None
  7971                                           
  7972                                                   # Get account indices in forecast_df
  7973                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7974                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7975                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7976                                           
  7977                                                   # Get account deltas
  7978                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  7979                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  7980                                                   checking_delta = pbal_delta + interest_delta
  7981                                           
  7982                                                   # Iterate over future forecast rows
  7983                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7984                                                       date_iat = f_row['Date']
  7985                                                       md_to_keep = []
  7986                                           
  7987                                                       if date_iat == next_billing_date:
  7988                                                           # Handle next billing date (payment due date)
  7989                                           
  7990                                                           # Initialize amounts
  7991                                                           pbal_amount = 0.0
  7992                                                           interest_amount = 0.0
  7993                                           
  7994                                                           # Parse memo directives
  7995                                                           for md in f_row['Memo Directives'].split(';'):
  7996                                                               md = md.strip()
  7997                                                               if not md:
  7998                                                                   continue
  7999                                           
  8000                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8001                                                                   pbal_amount = self._parse_memo_amount(md)
  8002                                                                   pbal_delta += pbal_amount
  8003                                                                   checking_delta += pbal_amount
  8004                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8005                                                                   interest_amount = self._parse_memo_amount(md)
  8006                                                                   interest_delta += interest_amount
  8007                                                                   checking_delta += interest_amount
  8008                                                               else:
  8009                                                                   md_to_keep.append(md)
  8010                                           
  8011                                                           # Remove the checking memo directive
  8012                                                           total_payment = pbal_amount + interest_amount
  8013                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${total_payment:.2f})'
  8014                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  8015                                           
  8016                                                       elif date_iat in loan_billing_dates:
  8017                                                           # Handle other billing dates (interest accrual)
  8018                                           
  8019                                                           # Initialize variables
  8020                                                           pbal_paid_amount = 0.0
  8021                                                           interest_paid_amount = 0.0
  8022                                                           og_pbal_md = ''
  8023                                                           og_interest_md = ''
  8024                                           
  8025                                                           # Parse memo directives
  8026                                                           for md in f_row['Memo Directives'].split(';'):
  8027                                                               md = md.strip()
  8028                                                               if not md:
  8029                                                                   continue
  8030                                           
  8031                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8032                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  8033                                                                   og_pbal_md = md
  8034                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8035                                                                   interest_paid_amount = self._parse_memo_amount(md)
  8036                                                                   og_interest_md = md
  8037                                                               else:
  8038                                                                   md_to_keep.append(md)
  8039                                           
  8040                                                           # Get balances at the time of charge
  8041                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8042                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  8043                                           
  8044                                                           # Adjust interest memo
  8045                                                           if interest_balance <= interest_paid_amount:
  8046                                                               new_interest_amount = interest_balance
  8047                                                               og_interest_surplus = interest_paid_amount - interest_balance
  8048                                                           else:
  8049                                                               new_interest_amount = interest_paid_amount
  8050                                                               og_interest_surplus = 0.0
  8051                                                           new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  8052                                                           new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  8053                                           
  8054                                                           # Adjust principal balance memo
  8055                                                           total_pbal_payment = pbal_paid_amount + og_interest_surplus
  8056                                                           if pbal_balance <= total_pbal_payment:
  8057                                                               new_pbal_amount = pbal_balance
  8058                                                               og_pbal_surplus = total_pbal_payment - pbal_balance
  8059                                                               final_recredit_checking = og_pbal_surplus
  8060                                                           else:
  8061                                                               new_pbal_amount = total_pbal_payment
  8062                                                               og_pbal_surplus = 0.0
  8063                                                               final_recredit_checking = 0.0
  8064                                                           new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  8065                                                           new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  8066                                           
  8067                                                           # Update memo directives
  8068                                                           md_to_keep.extend([new_interest_md, new_pbal_md, new_checking_pbal_md, new_checking_interest_md])
  8069                                           
  8070                                                           # Adjust deltas
  8071                                                           checking_delta += (og_pbal_surplus + og_interest_surplus)
  8072                                                           pbal_delta += og_pbal_surplus
  8073                                                           interest_delta += og_interest_surplus
  8074                                           
  8075                                                       else:
  8076                                                           # No adjustments needed for other dates
  8077                                                           pass
  8078                                           
  8079                                                       # Update balances
  8080                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8081                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  8082                                           
  8083                                                       # Apply daily interest accrual
  8084                                                       if date_iat >= min(loan_billing_dates):
  8085                                                           if f_i == 0:
  8086                                                               # Set interest to the value after the transaction
  8087                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  8088                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  8089                                                           else:
  8090                                                               # Set interest equal to the previous day's interest
  8091                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  8092                                                                   f_i - 1, interest_account_name]
  8093                                           
  8094                                                           # Calculate interest accrued on this day
  8095                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8096                                                           interest_accrued = pbal_balance * (apr / 365.25)
  8097                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  8098                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  8099                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  8100                                           
  8101                                                       # Clean and update memo directives
  8102                                                       md_to_keep = [md for md in md_to_keep if md]
  8103                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8104                                           
  8105                                                   self.log_stack_depth -= 1
  8106                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  8107                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_curr at line 8109

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8109                                               @profile
  8110                                               def _propagate_credit_payment_prev_curr(self, relevant_account_info_df,
  8111                                                                                       account_deltas_list,
  8112                                                                                       future_rows_only_df,
  8113                                                                                       forecast_df,
  8114                                                                                       account_set_before_p2_plus_txn,
  8115                                                                                       billing_dates_dict,
  8116                                                                                       date_string_YYYYMMDD,
  8117                                                                                       post_txn_row_df):
  8118                                                   """
  8119                                                   Propagates credit card payments into the future forecast when both previous and current statement balances are involved.
  8120                                           
  8121                                                   Parameters:
  8122                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  8123                                                   - account_deltas_list: List of account balance changes (deltas).
  8124                                                   - future_rows_only_df: DataFrame with future forecast rows.
  8125                                                   - forecast_df: The original forecast DataFrame.
  8126                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  8127                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  8128                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  8129                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  8130                                           
  8131                                                   Returns:
  8132                                                   - Updated future_rows_only_df DataFrame.
  8133                                                   """
  8134                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8135                                                   self.log_stack_depth += 1
  8136                                           
  8137                                                   # Extract relevant account names
  8138                                                   checking_account_name = relevant_account_info_df[
  8139                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  8140                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  8141                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  8142                                                   prev_stmt_bal_account_name = relevant_account_info_df[
  8143                                                       relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  8144                                           
  8145                                                   # Get billing dates and next billing date
  8146                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  8147                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  8148                                                   if future_billing_dates:
  8149                                                       next_billing_date = str(min(future_billing_dates))
  8150                                                   else:
  8151                                                       next_billing_date = None
  8152                                           
  8153                                                   # Get account indices in forecast_df
  8154                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  8155                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  8156                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  8157                                           
  8158                                                   # Get account deltas
  8159                                                   previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  8160                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  8161                                                   checking_delta = previous_stmt_delta + curr_stmt_delta
  8162                                           
  8163                                                   # Initialize previous previous statement balance (used in future billing dates)
  8164                                                   previous_prev_stmt_bal = 0
  8165                                           
  8166                                                   # Iterate over future forecast rows
  8167                                                   for f_i, f_row in future_rows_only_df.iterrows():
  8168                                                       date_iat = f_row['Date']
  8169                                           
  8170                                                       md_to_keep = []
  8171                                           
  8172                                                       if date_iat == next_billing_date:
  8173                                                           # Handle next billing date
  8174                                           
  8175                                                           # Initialize memo variables
  8176                                                           og_prev_memo = ''
  8177                                                           og_curr_memo = ''
  8178                                                           og_check_memo = ''
  8179                                                           og_interest_memo = ''
  8180                                                           og_prev_amount = 0.0
  8181                                                           og_curr_amount = 0.0
  8182                                                           og_check_amount = 0.0
  8183                                                           og_interest_amount = 0.0
  8184                                           
  8185                                                           # Parse memo directives
  8186                                                           for md in f_row['Memo Directives'].split(';'):
  8187                                                               md = md.strip()
  8188                                                               if not md:
  8189                                                                   continue
  8190                                           
  8191                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8192                                                                   og_prev_memo = md
  8193                                                                   og_prev_amount = self._parse_memo_amount(md)
  8194                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8195                                                                   og_curr_memo = md
  8196                                                                   og_curr_amount = self._parse_memo_amount(md)
  8197                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8198                                                                   og_check_memo = md
  8199                                                                   og_check_amount = self._parse_memo_amount(md)
  8200                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8201                                                                   og_interest_memo = md
  8202                                                                   og_interest_amount = self._parse_memo_amount(md)
  8203                                                               else:
  8204                                                                   md_to_keep.append(md)
  8205                                           
  8206                                                           # Get advance payment amount
  8207                                                           advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  8208                                                               prev_stmt_bal_account_name,
  8209                                                               account_set_before_p2_plus_txn,
  8210                                                               forecast_df,
  8211                                                               date_iat
  8212                                                           )
  8213                                           
  8214                                                           min_payment_amount = og_check_amount
  8215                                           
  8216                                                           # Adjust deltas
  8217                                                           curr_stmt_delta += og_curr_amount
  8218                                                           previous_stmt_delta += og_prev_amount
  8219                                                           checking_delta += og_prev_amount + og_curr_amount
  8220                                           
  8221                                                           # Apply advance payments
  8222                                                           if advance_payment_amount >= min_payment_amount:
  8223                                                               # All payments already made
  8224                                                               new_check_memo = f'CC MIN PAYMENT ALREADY MADE ({checking_account_name} -$0.00)'
  8225                                                               new_prev_memo = (f'CC MIN PAYMENT ALREADY MADE ({prev_stmt_bal_account_name} -$0.00)'
  8226                                                                                if og_prev_amount > 0 else '')
  8227                                                               new_curr_memo = (f'CC MIN PAYMENT ALREADY MADE ({curr_stmt_bal_account_name} -$0.00)'
  8228                                                                                if og_curr_amount > 0 else '')
  8229                                                           else:
  8230                                                               remaining_payment = min_payment_amount - advance_payment_amount
  8231                                                               if advance_payment_amount >= og_prev_amount:
  8232                                                                   # Advance payments cover previous statement balance
  8233                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  8234                                                                   curr_amount_remaining = og_curr_amount - (advance_payment_amount - og_prev_amount)
  8235                                                                   new_curr_memo = self._update_memo_amount(og_curr_memo, curr_amount_remaining)
  8236                                                               else:
  8237                                                                   # Advance payments partially cover previous statement balance
  8238                                                                   prev_amount_remaining = og_prev_amount - advance_payment_amount
  8239                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, prev_amount_remaining)
  8240                                                                   new_curr_memo = og_curr_memo
  8241                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - advance_payment_amount)
  8242                                           
  8243                                                           # Move current statement delta to previous
  8244                                                           previous_stmt_delta += curr_stmt_delta
  8245                                                           curr_stmt_delta = 0
  8246                                           
  8247                                                           # Update memo directives
  8248                                                           md_to_keep.extend(filter(None, [new_check_memo, new_curr_memo, new_prev_memo, og_interest_memo]))
  8249                                           
  8250                                                           # Compute previous previous statement balance
  8251                                                           previous_prev_stmt_bal = round(
  8252                                                               future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta, 2
  8253                                                           )
  8254                                           
  8255                                                       elif date_iat in cc_billing_dates:
  8256                                                           # Handle other billing dates
  8257                                           
  8258                                                           # Ensure we have a valid previous_prev_stmt_bal
  8259                                                           if previous_prev_stmt_bal == 0:
  8260                                                               continue  # Skip if we don't have previous balance
  8261                                           
  8262                                                           # Initialize memo variables
  8263                                                           og_prev_memo = ''
  8264                                                           og_curr_memo = ''
  8265                                                           og_check_memo = ''
  8266                                                           og_interest_memo = ''
  8267                                                           og_prev_amount = 0.0
  8268                                                           og_curr_amount = 0.0
  8269                                                           og_check_amount = 0.0
  8270                                                           og_interest_amount = 0.0
  8271                                                           og_min_payment_amount = 0.0
  8272                                           
  8273                                                           # Parse memo directives
  8274                                                           for md in f_row['Memo Directives'].split(';'):
  8275                                                               md = md.strip()
  8276                                                               if not md:
  8277                                                                   continue
  8278                                           
  8279                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8280                                                                   og_prev_memo = md
  8281                                                                   og_prev_amount = self._parse_memo_amount(md)
  8282                                                                   og_min_payment_amount += og_prev_amount
  8283                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8284                                                                   og_curr_memo = md
  8285                                                                   og_curr_amount = self._parse_memo_amount(md)
  8286                                                                   og_min_payment_amount += og_curr_amount
  8287                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8288                                                                   og_check_memo = md
  8289                                                                   og_check_amount = self._parse_memo_amount(md)
  8290                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8291                                                                   og_interest_memo = md
  8292                                                                   og_interest_amount = self._parse_memo_amount(md)
  8293                                                               else:
  8294                                                                   md_to_keep.append(md)
  8295                                           
  8296                                                           # Get account row for APR
  8297                                                           account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  8298                                                               account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  8299                                                               ]
  8300                                           
  8301                                                           # Compute interest and current due
  8302                                                           apr = account_row.APR.iat[0]
  8303                                                           interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  8304                                                           principal_due = previous_prev_stmt_bal * 0.01
  8305                                                           current_due = principal_due + interest_to_be_charged
  8306                                           
  8307                                                           # Adjusted payment amounts
  8308                                                           curr_prev_stmt_bal = f_row[prev_stmt_bal_account_name]  # Should we adjust for interest?
  8309                                           
  8310                                                           new_min_payment_amount = max(min(40, current_due), curr_prev_stmt_bal)
  8311                                           
  8312                                                           adjusted_payment_amount = round(og_min_payment_amount - new_min_payment_amount, 2)
  8313                                           
  8314                                                           previous_stmt_delta += adjusted_payment_amount
  8315                                                           checking_delta += adjusted_payment_amount
  8316                                                           interest_delta = interest_to_be_charged - og_interest_amount
  8317                                                           previous_stmt_delta += round(interest_delta, 2)
  8318                                           
  8319                                                           # Adjust memos
  8320                                                           new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - adjusted_payment_amount)
  8321                                                           if adjusted_payment_amount >= curr_prev_stmt_bal:
  8322                                                               # Adjust curr and prev memos
  8323                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, adjusted_payment_amount - curr_prev_stmt_bal)
  8324                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, curr_prev_stmt_bal)
  8325                                                           else:
  8326                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  8327                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, adjusted_payment_amount)
  8328                                                           new_interest_memo = self._update_memo_amount(og_interest_memo, interest_to_be_charged)
  8329                                           
  8330                                                           # Update memo directives
  8331                                                           md_to_keep.extend([new_check_memo, new_curr_memo, new_prev_memo, new_interest_memo])
  8332                                           
  8333                                                           # Update previous_prev_stmt_bal
  8334                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  8335                                           
  8336                                                       else:
  8337                                                           # No adjustments needed
  8338                                                           pass
  8339                                           
  8340                                                       # Update balances
  8341                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8342                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  8343                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  8344                                           
  8345                                                       # Clean and update memo directives
  8346                                                       md_to_keep = [md for md in md_to_keep if md]
  8347                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8348                                           
  8349                                                   self.log_stack_depth -= 1
  8350                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8351                                                   return future_rows_only_df

Total time: 0.016677 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _parse_memo_amount at line 8353

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8353                                               @profile
  8354                                               def _parse_memo_amount(self, memo_line):
  8355                                                   """
  8356                                                   Parses a memo line and extracts the amount.
  8357                                                   Returns the amount as a float.
  8358                                                   """
  8359      1804      11771.0      6.5     70.6          match = re.search(r'\((.*?)-\$(.*?)\)', memo_line)
  8360      1804        830.0      0.5      5.0          if match:
  8361      1233       1405.0      1.1      8.4              amount_str = match.group(2).strip()
  8362      1233        364.0      0.3      2.2              try:
  8363      1233       1646.0      1.3      9.9                  amount = float(amount_str)
  8364      1233        426.0      0.3      2.6                  return amount
  8365                                                       except ValueError:
  8366                                                           return 0.0
  8367                                                   else:
  8368       571        235.0      0.4      1.4              return 0.0

Total time: 0.046658 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _update_memo_amount at line 8370

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8370                                               @profile
  8371                                               def _update_memo_amount(self, memo_line, new_amount):
  8372                                                   """
  8373                                                   Updates the amount in a memo line with a new amount.
  8374                                                   Returns the updated memo line.
  8375                                                   """
  8376      1895      46658.0     24.6    100.0          return re.sub(r'\((.*?)-\$(.*?)\)', r'(\1-$' + f'{new_amount:.2f}' + ')', memo_line)

Total time: 617.625 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: propagateOptimizationTransactionsIntoTheFuture at line 8378

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8378                                               @profile
  8379                                               def propagateOptimizationTransactionsIntoTheFuture(self, account_set_before_p2_plus_txn, forecast_df, date_string_YYYYMMDD):
  8380                                                   """
  8381                                                   Propagates optimization transactions into the future forecast.
  8382                                           
  8383                                                   Parameters:
  8384                                                   - account_set_before_p2_plus_txn: Account set before processing transactions.
  8385                                                   - forecast_df: DataFrame containing the financial forecast.
  8386                                                   - date_string_YYYYMMDD: The current date in 'YYYYMMDD' format.
  8387                                           
  8388                                                   Returns:
  8389                                                   - Updated forecast_df with propagated transactions.
  8390                                                   """
  8391      4511      97422.0     21.6      0.0          log_in_color(logger, 'cyan', 'debug', 'ENTER propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8392      4511       4031.0      0.9      0.0          self.log_stack_depth += 1
  8393      4511      36340.0      8.1      0.0          log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8394      4511  139949095.0  31024.0     22.7          log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8395                                           
  8396      9022  132777626.0  14717.1     21.5          account_set_after_p2_plus_txn = self.sync_account_set_w_forecast_day(
  8397      4511    2121098.0    470.2      0.3              copy.deepcopy(account_set_before_p2_plus_txn), forecast_df, date_string_YYYYMMDD
  8398                                                   )
  8399                                           
  8400      4511  117272916.0  25997.1     19.0          A_df = account_set_after_p2_plus_txn.getAccounts()
  8401      4511  117189932.0  25978.7     19.0          B_df = account_set_before_p2_plus_txn.getAccounts()
  8402                                           
  8403                                                   # Compute account deltas
  8404      4511    1664005.0    368.9      0.3          account_deltas = A_df['Balance'] - B_df['Balance']
  8405                                           
  8406                                                   # Sanity check: For certain account types, deltas should be <= 0
  8407      4511       4526.0      1.0      0.0          account_types_to_check = ['checking', 'principal balance', 'interest']
  8408      4511    1260837.0    279.5      0.2          is_account_type = A_df['Account_Type'].isin(account_types_to_check)
  8409      4511    1410359.0    312.6      0.2          violations = account_deltas[is_account_type] > 0
  8410                                           
  8411      4511     399939.0     88.7      0.1          if violations.any():
  8412                                                       log_in_color(logger, 'red', 'error', str(account_deltas[violations]), self.log_stack_depth)
  8413                                                       raise AssertionError('Account delta positive for checking, principal balance, or interest accounts.')
  8414                                           
  8415      4511      19824.0      4.4      0.0          account_deltas_list = account_deltas.tolist()
  8416                                           
  8417      4511     611520.0    135.6      0.1          if account_deltas.sum() == 0:
  8418      4420       2056.0      0.5      0.0              return forecast_df
  8419                                           
  8420                                                   # log_in_color(
  8421                                                   #     logger,
  8422                                                   #     'magenta',
  8423                                                   #     'debug',
  8424                                                   #     f'ENTER propagateOptimizationTransactionsIntoTheFuture({date_string_YYYYMMDD})',
  8425                                                   #     self.log_stack_depth
  8426                                                   # )
  8427                                           
  8428        91    1746273.0  19189.8      0.3          future_rows_only_row_sel_vec = [ datetime.datetime.strptime(d, '%Y%m%d') > datetime.datetime.strptime(date_string_YYYYMMDD, '%Y%m%d') for d in forecast_df.Date]  # not sure if still need this
  8429                                           
  8430        91      43887.0    482.3      0.0          post_txn_row_df = forecast_df[forecast_df['Date'] == date_string_YYYYMMDD]
  8431                                           
  8432        91      46574.0    511.8      0.0          future_rows_only_df = forecast_df[forecast_df['Date'] > date_string_YYYYMMDD].reset_index(drop=True)
  8433                                           
  8434                                                   # Generate interest accrual dates
  8435        91         54.0      0.6      0.0          interest_accrual_dates__list_of_lists = []
  8436       728      84496.0    116.1      0.0          for _, a_row in A_df.iterrows():
  8437       637      10270.0     16.1      0.0              interest_cadence = a_row['Interest_Cadence']
  8438       637       1605.0      2.5      0.0              if pd.isnull(interest_cadence) or interest_cadence == 'None':
  8439       364        262.0      0.7      0.0                  interest_accrual_dates__list_of_lists.append([])
  8440       364        162.0      0.4      0.0                  continue
  8441                                           
  8442       273      79020.0    289.5      0.0              start_date = pd.to_datetime(a_row['Billing_Start_Date'], format='%Y%m%d')
  8443       273      65477.0    239.8      0.0              end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8444       273       5330.0     19.5      0.0              num_days = (end_date - start_date).days
  8445       273     475034.0   1740.1      0.1              account_specific_iad = generate_date_sequence(a_row['Billing_Start_Date'], num_days, interest_cadence)
  8446       273        293.0      1.1      0.0              interest_accrual_dates__list_of_lists.append(account_specific_iad)
  8447                                           
  8448                                                   # Generate billing dates
  8449        91         37.0      0.4      0.0          billing_dates__list_of_lists = []
  8450        91         35.0      0.4      0.0          billing_dates__dict = {}
  8451       728      59673.0     82.0      0.0          for _, a_row in A_df.iterrows():
  8452       637       9115.0     14.3      0.0              billing_start_date = a_row['Billing_Start_Date']
  8453       637       1491.0      2.3      0.0              if pd.isnull(billing_start_date) or billing_start_date == 'None':
  8454       364        267.0      0.7      0.0                  billing_dates__list_of_lists.append([])
  8455       364        118.0      0.3      0.0                  continue
  8456                                           
  8457       273      70914.0    259.8      0.0              start_date = pd.to_datetime(billing_start_date, format='%Y%m%d')
  8458       273      64985.0    238.0      0.0              end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8459       273       4297.0     15.7      0.0              num_days = (end_date - start_date).days
  8460       273     194253.0    711.5      0.0              account_specific_bd = generate_date_sequence(billing_start_date, num_days, 'monthly')
  8461       273        273.0      1.0      0.0              billing_dates__list_of_lists.append(account_specific_bd)
  8462       273       4693.0     17.2      0.0              billing_dates__dict[a_row['Name']] = account_specific_bd
  8463                                           
  8464                                                   # Mapping of account type combinations to processing functions
  8465        91        111.0      1.2      0.0          account_type_combinations = {
  8466       182        167.0      0.9      0.0              frozenset(
  8467       182        146.0      0.8      0.0                  ['checking', 'credit prev stmt bal', 'credit curr stmt bal']): self._propagate_credit_payment_prev_curr,
  8468        91        194.0      2.1      0.0              frozenset(['checking', 'principal balance', 'interest']): self._propagate_loan_payment_pbal_interest,
  8469        91        112.0      1.2      0.0              frozenset(['checking', 'principal balance']): self._propagate_loan_payment_pbal_only,
  8470        91        107.0      1.2      0.0              frozenset(['checking', 'interest']): self._propagate_loan_payment_interest_only,
  8471        91         96.0      1.1      0.0              frozenset(['checking', 'credit prev stmt bal']): self._propagate_credit_payment_prev_only,
  8472        91         88.0      1.0      0.0              frozenset(['checking', 'credit curr stmt bal']): self._propagate_credit_curr_only,
  8473        91         95.0      1.0      0.0              frozenset(['credit curr stmt bal']): self._propagate_credit_curr_stmt_balance,
  8474                                                   }
  8475                                           
  8476                                                   # Assume accounts_df is a DataFrame containing account information
  8477        91    2411157.0  26496.2      0.4          accounts_df = account_set_before_p2_plus_txn.getAccounts().copy()
  8478                                           
  8479                                                   # Create a Series for account deltas with the same index as accounts_df
  8480        91      34402.0    378.0      0.0          accounts_df['Delta'] = account_deltas_list
  8481                                           
  8482                                                   # Extract base names (before ':') of account names
  8483        91      80490.0    884.5      0.0          accounts_df['Base_Name'] = accounts_df['Name'].str.split(':').str[0]
  8484                                           
  8485                                                   # Select accounts with non-zero deltas
  8486        91      67694.0    743.9      0.0          accounts_with_deltas = accounts_df[accounts_df['Delta'] != 0]
  8487                                           
  8488                                                   # Check if 'checking' account type is involved in the transaction
  8489        91      13265.0    145.8      0.0          checking_in_txn = 'checking' in accounts_with_deltas['Account_Type'].unique()
  8490                                           
  8491                                                   # Get base names of accounts involved in the transaction
  8492        91       5458.0     60.0      0.0          affected_account_base_names = set(accounts_with_deltas['Base_Name'])
  8493                                           
  8494                                                   # Get base names of checking accounts
  8495        91      46074.0    506.3      0.0          checking_base_names = set(accounts_df[accounts_df['Account_Type'] == 'checking']['Base_Name'])
  8496                                           
  8497                                                   # Base names of affected accounts excluding checking accounts
  8498        91        106.0      1.2      0.0          affected_account_base_names_sans_checking = affected_account_base_names - checking_base_names
  8499                                           
  8500        91        101.0      1.1      0.0          if checking_in_txn and len(affected_account_base_names_sans_checking) == 0:
  8501                                                       # Only checking accounts are involved in the transaction
  8502                                                       # Update future balances for the checking accounts
  8503                                                       for idx, row in accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking'].iterrows():
  8504                                                           min_balance = row['Min_Balance']
  8505                                                           max_balance = row['Max_Balance']
  8506                                                           relevant_checking_account_name = row['Name']
  8507                                                           checking_delta = row['Delta']
  8508                                                           future_rows_only_df[relevant_checking_account_name] += checking_delta
  8509                                           
  8510                                                       if not future_rows_only_df.empty:
  8511                                                           min_future_acct_bal = min(future_rows_only_df[relevant_checking_account_name])
  8512                                                           max_future_acct_bal = max(future_rows_only_df[relevant_checking_account_name])
  8513                                           
  8514                                                           try:
  8515                                                               assert min_balance <= min_future_acct_bal
  8516                                                           except AssertionError:
  8517                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8518                                                               error_msg += "Account boundaries were violated\n"
  8519                                                               error_msg += "min_balance <= min_future_acct_bal was not True\n"
  8520                                                               error_msg += str(min_balance) + " <= " + str(min_future_acct_bal) + '\n'
  8521                                                               error_msg += future_rows_only_df.to_string()
  8522                                                               self.log_stack_depth -= 1
  8523                                                               raise ValueError(error_msg)
  8524                                           
  8525                                                           try:
  8526                                                               assert max_balance >= max_future_acct_bal
  8527                                                           except AssertionError:
  8528                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8529                                                               error_msg += "Account boundaries were violated\n"
  8530                                                               error_msg += "max_balance >= max_future_acct_bal was not True\n"
  8531                                                               error_msg += str(max_balance) + " <= " + str(max_future_acct_bal) + '\n'
  8532                                                               error_msg += future_rows_only_df.to_string()
  8533                                                               self.log_stack_depth -= 1
  8534                                                               raise ValueError(error_msg)
  8535                                                   else:
  8536                                                       # Process each affected base account name excluding checking accounts
  8537       182        167.0      0.9      0.0              for account_base_name in affected_account_base_names_sans_checking:
  8538                                                           # Select accounts with the current base name
  8539        91      40032.0    439.9      0.0                  accounts_with_base_name = accounts_df[accounts_df['Base_Name'] == account_base_name]
  8540                                           
  8541                                                           # Select accounts with non-zero deltas and the current base name
  8542        91      44258.0    486.4      0.0                  accounts_with_base_name_and_delta = accounts_with_base_name[accounts_with_base_name['Delta'] != 0]
  8543                                           
  8544        91        842.0      9.3      0.0                  if accounts_with_base_name_and_delta.empty:
  8545                                                               continue
  8546                                           
  8547                                                           # Get the list of account types involved for this base name
  8548        91      10318.0    113.4      0.0                  relevant_account_type_list = accounts_with_base_name_and_delta['Account_Type'].unique().tolist()
  8549                                           
  8550                                                           # If checking accounts are involved, include them
  8551        91         54.0      0.6      0.0                  if checking_in_txn:
  8552        91      39858.0    438.0      0.0                      checking_accounts_in_txn = accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking']
  8553       182      57961.0    318.5      0.0                      accounts_with_base_name_and_delta = pd.concat(
  8554        91         54.0      0.6      0.0                          [accounts_with_base_name_and_delta, checking_accounts_in_txn])
  8555        91         81.0      0.9      0.0                      if 'checking' not in relevant_account_type_list:
  8556        91         74.0      0.8      0.0                          relevant_account_type_list.append('checking')
  8557                                           
  8558                                                           # Prepare the DataFrame with relevant account information
  8559        91         46.0      0.5      0.0                  relevant_account_info_df = accounts_with_base_name_and_delta
  8560                                           
  8561                                                           # Proceed to handle the transaction based on relevant_account_type_list
  8562                                                           # (Implementation depends on specific business logic)
  8563                                           
  8564                                                           # Identify the appropriate processing function
  8565        91        110.0      1.2      0.0                  account_types_set = frozenset(relevant_account_type_list)
  8566        91        146.0      1.6      0.0                  processing_function = account_type_combinations.get(account_types_set)
  8567                                           
  8568        91         49.0      0.5      0.0                  if processing_function:
  8569                                                               # Call the processing function
  8570       182   96625264.0 530908.0     15.6                      future_rows_only_df = processing_function(
  8571        91         54.0      0.6      0.0                          relevant_account_info_df,
  8572        91         46.0      0.5      0.0                          account_deltas_list,
  8573        91         52.0      0.6      0.0                          future_rows_only_df,
  8574        91         46.0      0.5      0.0                          forecast_df,
  8575        91         48.0      0.5      0.0                          account_set_before_p2_plus_txn,
  8576        91         39.0      0.4      0.0                          billing_dates__dict,
  8577        91         57.0      0.6      0.0                          date_string_YYYYMMDD,
  8578        91         53.0      0.6      0.0                          post_txn_row_df
  8579                                                               )
  8580                                                           else:
  8581                                                               # print('relevant_account_type_list:', relevant_account_type_list)
  8582                                                               # print('affected_account_base_names:', relevant_account_info_df['Name'].unique())
  8583                                                               self.log_stack_depth -= 1
  8584                                                               raise ValueError("Undefined case in process_transactions")
  8585                                           
  8586        91        935.0     10.3      0.0          if not future_rows_only_df.empty:
  8587                                                       # if not boundary violation
  8588                                                       #todo very slow to do this
  8589        91      18417.0    202.4      0.0              index_of_first_future_day = list(forecast_df.Date).index(future_rows_only_df.head(1).Date.iat[0])
  8590        91       9933.0    109.2      0.0              future_rows_only_df.index = future_rows_only_df.index + index_of_first_future_day
  8591        91     323097.0   3550.5      0.1              forecast_df.update(future_rows_only_df)
  8592                                           
  8593                                           
  8594                                                       # log_in_color(logger, 'cyan', 'debug', 'future_rows_only_df', self.log_stack_depth)
  8595                                                       # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  8596                                                       # log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8597                                                       # log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8598                                           
  8599        91        232.0      2.5      0.0          self.log_stack_depth -= 1
  8600        91       1862.0     20.5      0.0          log_in_color(logger, 'cyan', 'debug', 'EXIT propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8601        91         42.0      0.5      0.0          return forecast_df

Total time: 38.91 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: updateProposedTransactionsBasedOnOtherSets at line 9083

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9083                                               @profile
  9084                                               def updateProposedTransactionsBasedOnOtherSets(self, confirmed_df, proposed_df, deferred_df, skipped_df):
  9085                                           
  9086      4843       7877.0      1.6      0.0          self.log_stack_depth += 1
  9087                                           
  9088                                           
  9089      4843   12934483.0   2670.8     33.2          p_LJ_c = pd.merge(proposed_df, confirmed_df, on=['Date', 'Memo', 'Priority'])
  9090      4843   11688386.0   2413.5     30.0          p_LJ_d = pd.merge(proposed_df, deferred_df, on=['Date', 'Memo', 'Priority'])
  9091      4843   11623992.0   2400.2     29.9          p_LJ_s = pd.merge(proposed_df, skipped_df, on=['Date', 'Memo', 'Priority'])
  9092                                           
  9093      4843     632637.0    130.6      1.6          not_confirmed_sel_vec = (~proposed_df.index.isin(p_LJ_c))
  9094      4843     504273.0    104.1      1.3          not_deferred_sel_vec = (~proposed_df.index.isin(p_LJ_d))
  9095      4843     476909.0     98.5      1.2          not_skipped_sel_vec = (~proposed_df.index.isin(p_LJ_s))
  9096      4843      13018.0      2.7      0.0          remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9097      4843    1019851.0    210.6      2.6          remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9098                                           
  9099                                                   ### this code is equivalent. todo Which is more performant?
  9100                                                   # not_confirmed_sel_vec = (~proposed_df.index.isin(confirmed_df.index))
  9101                                                   # not_deferred_sel_vec = (~proposed_df.index.isin(deferred_df.index))
  9102                                                   # not_skipped_sel_vec = (~proposed_df.index.isin(skipped_df.index))
  9103                                                   # remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9104                                                   # remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9105                                           
  9106      4843       6929.0      1.4      0.0          self.log_stack_depth -= 1
  9107                                                   # log_in_color(logger, 'cyan', 'debug', 'EXIT updateProposedTransactionsBasedOnOtherSets',self.log_stack_depth)
  9108      4843       1663.0      0.3      0.0          return remaining_unproposed_transactions_df

Total time: 4222.22 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: assessPotentialOptimizations at line 9251

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9251                                               @profile
  9252                                               def assessPotentialOptimizations(self, forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df, raise_satisfice_failed_exception, progress_bar=None):
  9253        20         22.0      1.1      0.0          self.log_stack_depth += 1
  9254        20        403.0     20.1      0.0          all_days = forecast_df.Date
  9255                                           
  9256                                                   # Schema is: Date, Priority, Amount, Memo, Deferrable, Partial_Payment_Allowed
  9257        20       8543.0    427.1      0.0          full_budget_schedule_df = pd.concat([confirmed_df, proposed_df, deferred_df, skipped_df])
  9258        20        515.0     25.8      0.0          full_budget_schedule_df.reset_index(drop=True, inplace=True)
  9259                                           
  9260        20       3039.0    151.9      0.0          unique_priority_indices = full_budget_schedule_df.Priority.unique()
  9261        20         66.0      3.3      0.0          unique_priority_indices.sort()
  9262                                           
  9263                                           
  9264        20          4.0      0.2      0.0          last_iteration_ts = None #this is here to remove a warning
  9265                                           
  9266        20         10.0      0.5      0.0          if not raise_satisfice_failed_exception:
  9267         1         15.0     15.0      0.0              log_in_color(logger, 'white', 'info','Beginning Optimization.')
  9268         1          7.0      7.0      0.0              last_iteration_ts = datetime.datetime.now()
  9269                                           
  9270                                                   # print('Beginning unique_priority_indices:'+str(unique_priority_indices))
  9271        50         57.0      1.1      0.0          for priority_index in unique_priority_indices:
  9272        40         17.0      0.4      0.0              if priority_index == 1:
  9273        20          7.0      0.3      0.0                  continue #because this was handled by satisfice
  9274                                           
  9275      4873       8269.0      1.7      0.0              for date_string_YYYYMMDD in all_days:
  9276      4863     727968.0    149.7      0.0                  if date_string_YYYYMMDD == forecast_df.head(1).Date.iat[0]:
  9277                                                           #if date_string_YYYYMMDD == self.start_date_YYYYMMDD:
  9278        20          8.0      0.4      0.0                      continue  # first day is considered final
  9279                                           
  9280                                           
  9281      4843       2730.0      0.6      0.0                  if not raise_satisfice_failed_exception:
  9282       322        150.0      0.5      0.0                      if progress_bar is not None:
  9283       322        831.0      2.6      0.0                          progress_bar.update(1)
  9284       322        557.0      1.7      0.0                          progress_bar.refresh()
  9285                                           
  9286       322       3024.0      9.4      0.0                      iteration_time_elapsed = datetime.datetime.now() - last_iteration_ts
  9287       322        437.0      1.4      0.0                      last_iteration_ts = datetime.datetime.now()
  9288       322      25390.0     78.9      0.0                      log_string = str(priority_index) + ' ' + datetime.datetime.strptime(date_string_YYYYMMDD,'%Y%m%d').strftime('%Y-%m-%d')
  9289       322        968.0      3.0      0.0                      log_string += '     ' + str(iteration_time_elapsed)
  9290                                                               # log_in_color(logger, 'white', 'debug', log_string )
  9291                                           
  9292                                                           # log_in_color(logger, 'magenta', 'info', 'p' + str(priority_index) + ' ' + str(date_string_YYYYMMDD),self.log_stack_depth)
  9293                                           
  9294      4843   39087729.0   8071.0      0.9                  remaining_unproposed_transactions_df = self.updateProposedTransactionsBasedOnOtherSets(confirmed_df, proposed_df, deferred_df, skipped_df)
  9295                                           
  9296                                                           #todo idk if this is necessary
  9297      4843  141598649.0  29237.8      3.4                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9298                                           
  9299                                                           #todo maybe this could be moved down? not sure
  9300      4843    2256793.0    466.0      0.1                  account_set_before_p2_plus_txn = copy.deepcopy(account_set)
  9301                                           
  9302                                                           #todo not sure if this is necessary
  9303      4843  141242394.0  29164.2      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9304                                           
  9305                                           
  9306                                           
  9307      9686 3138556356.0 324030.2     74.3                  forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(account_set=account_set,
  9308      4843       1812.0      0.4      0.0                                                                                                      forecast_df=forecast_df,
  9309      4843       2022.0      0.4      0.0                                                                                                      date_YYYYMMDD=date_string_YYYYMMDD,
  9310      4843       2314.0      0.5      0.0                                                                                                      memo_set=memo_rule_set,
  9311      4843       2111.0      0.4      0.0                                                                                                      confirmed_df=confirmed_df,
  9312      4843       1673.0      0.3      0.0                                                                                                      proposed_df=remaining_unproposed_transactions_df,
  9313      4843       1914.0      0.4      0.0                                                                                                      deferred_df=deferred_df,
  9314      4843       1983.0      0.4      0.0                                                                                                      skipped_df=skipped_df,
  9315      4843       1523.0      0.3      0.0                                                                                                      priority_level=priority_index)
  9316                                           
  9317                                                           # log_in_color(logger, 'green', 'info', 'forecast_df after eTFD ('+str(date_string_YYYYMMDD)+'):', self.log_stack_depth)
  9318                                                           # log_in_color(logger, 'green', 'info', forecast_df.to_string(), self.log_stack_depth)
  9319                                           
  9320                                                           # print('assess optimizations case 3 sync')
  9321      4833  140808185.0  29134.7      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9322                                           
  9323                                                           # this is necessary to make balance deltas propagate only once
  9324                                                           # print('raise_satisfice_failed_exception:'+str(raise_satisfice_failed_exception))
  9325      4833       2301.0      0.5      0.0                  if raise_satisfice_failed_exception:
  9326                                           
  9327                                                               #regarding why the input params are what they are here:
  9328                                                               # since the budget schedule does not have Account_From and Account_To, we infer which accounts were
  9329                                                               # affected by comparing the before and after, hence this method accepts the prior and current state
  9330                                                               # to modify forecast_df
  9331                                                               # Furthermore, additional loan payments affect the allocation of future minimum loan payments
  9332                                                               # so p1 minimumpayments, which aren't even BudgetItems as of 12/31/23.... must be edited
  9333                                                               # it kind of makes more sense to refactor and have credit card minimum payments and loan minimum
  9334                                                               # # payments as budget items....
  9335                                                               #
  9336                                                               # Doing that though creates a coupling between the AccountSet and BudgetSet classes that I don't like...
  9337                                                               # I only recently got the full detail of what happens into the Memo field, but I think that that is the answer
  9338                                                               # There will be information encoded in the Memo column that will not appear anywhere else
  9339                                                               #
  9340                                                               # print('about to propagateOptimizationTransactionsIntoTheFuture')
  9341                                                               # print('BEFORE')
  9342                                                               # print(forecast_df.to_string())
  9343      4511  617870058.0 136969.6     14.6                      forecast_df = self.propagateOptimizationTransactionsIntoTheFuture(account_set_before_p2_plus_txn,forecast_df, date_string_YYYYMMDD)
  9344                                           
  9345                                                               # print('AFTER')
  9346                                                               # print(forecast_df.to_string())
  9347                                           
  9348                                           
  9349        10         22.0      2.2      0.0          self.log_stack_depth -= 1
  9350        10        316.0     31.6      0.0          log_in_color(logger, 'magenta', 'debug', 'EXIT assessPotentialOptimizations() C:'+str(confirmed_df.shape[0])+' D:'+str(deferred_df.shape[0])+' S:'+str(skipped_df.shape[0]),self.log_stack_depth)
  9351        10          4.0      0.4      0.0          return forecast_df, skipped_df, confirmed_df, deferred_df

Total time: 5970.87 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: satisfice at line 9374

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9374                                               @profile
  9375                                               def satisfice(self, list_of_date_strings, confirmed_df, account_set, memo_rule_set, forecast_df,
  9376                                                             raise_satisfice_failed_exception, progress_bar=None):
  9377        20         34.0      1.7      0.0          self.log_stack_depth += 1
  9378        20          5.0      0.2      0.0          all_days = list_of_date_strings  # Rename for clarity
  9379                                           
  9380      6460       4786.0      0.7      0.0          for date_str in all_days:
  9381      6440       3469.0      0.5      0.0              if progress_bar:
  9382       322        713.0      2.2      0.0                  progress_bar.update(1)
  9383       322        637.0      2.0      0.0                  progress_bar.refresh()
  9384                                           
  9385                                                       # Skip the first day, considered as final
  9386      6440      10220.0      1.6      0.0              if date_str == self.start_date_YYYYMMDD:
  9387                                                           continue
  9388                                           
  9389      6440       2159.0      0.3      0.0              try:
  9390                                                           # Log transaction details if exception handling is not strict
  9391      6440       2389.0      0.4      0.0                  if not raise_satisfice_failed_exception:
  9392       322      31127.0     96.7      0.0                      log_string = f"1 {datetime.datetime.strptime(date_str, '%Y%m%d').strftime('%Y-%m-%d')}"
  9393                                           
  9394                                                           # Execute transactions for the day, priority 1 (non-negotiable)
  9395     12880 2489723082.0 193301.5     41.7                  forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(
  9396      6440       1974.0      0.3      0.0                      account_set=account_set,
  9397      6440       1873.0      0.3      0.0                      forecast_df=forecast_df,
  9398      6440       1875.0      0.3      0.0                      date_YYYYMMDD=date_str,
  9399      6440       2627.0      0.4      0.0                      memo_set=memo_rule_set,
  9400      6440       2453.0      0.4      0.0                      confirmed_df=confirmed_df,
  9401      6440     409622.0     63.6      0.0                      proposed_df=confirmed_df.head(0),  # No proposed transactions in satisfice
  9402      6440     256849.0     39.9      0.0                      deferred_df=confirmed_df.head(0),  # No deferred transactions in satisfice
  9403      6440     229275.0     35.6      0.0                      skipped_df=confirmed_df.head(0),  # No skipped transactions in satisfice
  9404      6440       2925.0      0.5      0.0                      priority_level=1
  9405                                                           )
  9406                                           
  9407                                                           # Sync account set after transactions
  9408      6440  194263268.0  30165.1      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9409                                           
  9410                                                           # Calculate loan interest accruals for the day
  9411     12880  595568551.0  46239.8     10.0                  forecast_df.loc[forecast_df.Date == date_str] = self.calculateLoanInterestAccrualsForDay(account_set,
  9412     12880    1359771.0    105.6      0.0                                                                                                           forecast_df[
  9413      6440    1136523.0    176.5      0.0                                                                                                               forecast_df.Date == date_str])
  9414                                           
  9415                                                           # print('POST interest caculation')
  9416                                                           # print(forecast_df.to_string())
  9417                                           
  9418                                                           # Sync again after interest accruals
  9419      6440  193835045.0  30098.6      3.2                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9420                                           
  9421                                                           # Execute minimum loan payments
  9422     12880 1672896400.0 129883.3     28.0                  forecast_df.loc[forecast_df.Date == date_str] = self.executeLoanMinimumPayments(account_set,
  9423     12880    1363539.0    105.9      0.0                                                                                                  forecast_df[
  9424      6440    1148029.0    178.3      0.0                                                                                                      forecast_df.Date == date_str])
  9425                                           
  9426                                                           # Sync after loan payments
  9427      6440  194142621.0  30146.4      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9428                                           
  9429                                                           # Execute credit card minimum payments
  9430     12880  427530396.0  33193.4      7.2                  forecast_df.loc[forecast_df.Date == date_str] = self.executeCreditCardMinimumPayments(forecast_df,
  9431      6440       2262.0      0.4      0.0                                                                                                        account_set,
  9432     12880    1373645.0    106.6      0.0                                                                                                        forecast_df[
  9433      6440    1143754.0    177.6      0.0                                                                                                            forecast_df.Date == date_str])
  9434                                           
  9435                                                           # Final sync for the day
  9436      6440  194420431.0  30189.5      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9437                                           
  9438                                                       except ValueError as e:
  9439                                                           error_message = str(e.args)
  9440                                                           # Handle specific account boundary violations
  9441                                                           if re.search('.*Account boundaries were violated.*',
  9442                                                                        error_message) and not raise_satisfice_failed_exception:
  9443                                                               self.end_date = datetime.datetime.strptime(date_str, '%Y%m%d') - datetime.timedelta(days=1)
  9444                                           
  9445                                                               log_in_color(logger, 'cyan', 'error', 'Account Boundaries were violated', self.log_stack_depth)
  9446                                                               log_in_color(logger, 'cyan', 'error', error_message, self.log_stack_depth)
  9447                                                               log_in_color(logger, 'cyan', 'error', 'State at failure:', self.log_stack_depth)
  9448                                                               log_in_color(logger, 'cyan', 'error', forecast_df.to_string(), self.log_stack_depth)
  9449                                           
  9450                                                               self.log_stack_depth -= 1
  9451                                                               return forecast_df
  9452                                                           else:
  9453                                                               raise e
  9454                                           
  9455        20         34.0      1.7      0.0          self.log_stack_depth -= 1
  9456        20         10.0      0.5      0.0          return forecast_df  # satisfice_success = True

Total time: 7208.92 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: computeOptimalForecast at line 9458

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9458                                               @profile
  9459                                               def computeOptimalForecast(self, start_date_YYYYMMDD, end_date_YYYYMMDD, confirmed_df, proposed_df, deferred_df,
  9460                                                                          skipped_df, account_set, memo_rule_set, raise_satisfice_failed_exception=True,
  9461                                                                          progress_bar=None):
  9462        20         34.0      1.7      0.0          self.log_stack_depth += 1
  9463                                           
  9464                                                   # Reset index for all input DataFrames to ensure clean processing
  9465       100         39.0      0.4      0.0          for df in [confirmed_df, proposed_df, deferred_df, skipped_df]:
  9466        80       1910.0     23.9      0.0              df.reset_index(drop=True, inplace=True)
  9467                                           
  9468                                                   # Generate the list of days for the forecast, excluding the first day
  9469        40       5927.0    148.2      0.0          all_days = pd.date_range(
  9470        20       1686.0     84.3      0.0              datetime.datetime.strptime(start_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(days=1),
  9471        20        757.0     37.9      0.0              datetime.datetime.strptime(end_date_YYYYMMDD, '%Y%m%d')
  9472                                                   )
  9473        20      30145.0   1507.2      0.0          all_days = [d.strftime('%Y%m%d') for d in all_days]
  9474                                           
  9475                                                   # Initialize the forecast DataFrame with the first day's account balances
  9476        20     732383.0  36619.2      0.0          forecast_df = self.getInitialForecastRow(start_date_YYYYMMDD, account_set)
  9477                                           
  9478                                                   # Attempt to satisfice (execute priority 1 transactions for each day)
  9479        40 5971077503.0    1e+08     82.8          satisfice_df = self.satisfice(
  9480        20         12.0      0.6      0.0              all_days, confirmed_df, account_set, memo_rule_set, forecast_df, raise_satisfice_failed_exception,
  9481        20          7.0      0.3      0.0              progress_bar
  9482                                                   )
  9483                                           
  9484                                                   # Check if satisfice succeeded by verifying the last date in the forecast
  9485        20       2480.0    124.0      0.0          satisfice_success = satisfice_df.tail(1)['Date'].iat[0] == end_date_YYYYMMDD
  9486                                           
  9487                                                   # Update forecast DataFrame with the result of satisfice
  9488        20        164.0      8.2      0.0          forecast_df = satisfice_df
  9489                                           
  9490        20          3.0      0.1      0.0          if satisfice_success:
  9491                                                       # Log success message when satisfice completes successfully at the top level
  9492        20          6.0      0.3      0.0              if not raise_satisfice_failed_exception:
  9493         1        100.0    100.0      0.0                  log_in_color(logger, 'white', 'info', 'Satisfice succeeded.')
  9494         1      41488.0  41488.0      0.0                  log_in_color(logger, 'white', 'debug', satisfice_df.to_string())
  9495                                           
  9496                                                       # Assess potential optimizations across all transaction levels
  9497        40 1237027208.0    3e+07     17.2              forecast_df, skipped_df, confirmed_df, deferred_df = self.assessPotentialOptimizations(
  9498        20         11.0      0.6      0.0                  forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df,
  9499        20          6.0      0.3      0.0                  raise_satisfice_failed_exception, progress_bar
  9500                                                       )
  9501                                                   else:
  9502                                                       # Handle satisfice failure: clean up unprocessed transactions
  9503                                                       if not raise_satisfice_failed_exception:
  9504                                                           log_in_color(logger, 'white', 'debug', 'Satisfice failed.')
  9505                                           
  9506                                                       confirmed_df, deferred_df, skipped_df = self.cleanUpAfterFailedSatisfice(
  9507                                                           confirmed_df, proposed_df, deferred_df, skipped_df
  9508                                                       )
  9509                                           
  9510                                                   # Decrement the log stack depth as we exit this method
  9511        10         10.0      1.0      0.0          self.log_stack_depth -= 1
  9512                                           
  9513                                                   # Return the forecast and updated DataFrames
  9514        10          6.0      0.6      0.0          return [forecast_df, skipped_df, confirmed_df, deferred_df]

