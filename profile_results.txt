Timer unit: 1e-06 s

Total time: 428.545 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: runForecast at line 2041

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2041                                               def runForecast(self, log_level='WARNING', play_notification_sound=False):
  2042                                                   #print('Starting Forecast #'+str(self.unique_id))
  2043                                                   self.start_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2044         1         46.0     46.0      0.0  
  2045                                                   if log_level == 'DEBUG':
  2046         1          3.0      3.0      0.0              loglevel = logging.DEBUG
  2047                                                   elif log_level == 'INFO':
  2048         1          1.0      1.0      0.0              loglevel = logging.INFO
  2049                                                   elif log_level == 'WARNING':
  2050         1          1.0      1.0      0.0              loglevel = logging.WARNING
  2051         1          2.0      2.0      0.0          elif log_level == 'ERROR':
  2052                                                       loglevel = logging.ERROR
  2053                                                   elif log_level == 'CRITICAL':
  2054                                                       loglevel = logging.CRITICAL
  2055                                                   else:
  2056                                                       loglevel = logging.WARNING
  2057                                                   logger.setLevel(loglevel)
  2058         1         25.0     25.0      0.0  
  2059                                                   log_in_color(logger, 'white', 'info', 'Starting Forecast '+str(self.unique_id))
  2060         1         49.0     49.0      0.0  
  2061                                                   # this is the place to estimate runtime to appropriately update progress bar
  2062                                                   # It could be for each day each priority, but then priority > 1 would have thr bar stop every time it looks ahead
  2063                                                   # I think the way to do it is have the bar be relative to the worst case
  2064                                                   # deferrable are really fucky. we will assume a deferral cadence of 2 weeks though this can be accounted for
  2065                                                   # if a deferral cadence is implemented #todo
  2066                                                   # I'm not sold that it would be that useful though. A look-ahead on income seems reasonable
  2067                                                   # therefore, each p2+ txn may fail, and each partial_payment may fail twice, and each deferrable may fail n times (where n is accounting for every 2 weeks
  2068                                                   #
  2069                                                   sd = datetime.datetime.strptime(self.start_date_YYYYMMDD, '%Y%m%d')
  2070         1         92.0     92.0      0.0          ed = datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d')
  2071         1         41.0     41.0      0.0          predicted_satisfice_runtime_in_simulated_days = (ed - sd).days
  2072         1          2.0      2.0      0.0          # p2plus_txns_max_runtime_in_simulated_days = 0
  2073                                                   # for index, row in self.initial_proposed_df.iterrows():
  2074                                                   #     num_of_lookahead_days = ( ed - datetime.datetime.strptime(row.date.iat[0],'%Y%m%d') ).days
  2075                                                   #     if row.Deferrable:
  2076                                                   #         max_number_of_retries = math.floor(num_of_lookahead_days / 14)
  2077                                                   #         #each retry would be 2 weeks shorter. I'm thinking of it making a triangle shape
  2078                                                   #         #therefore, we add time * n / 2
  2079                                                   #         p2plus_txns_max_runtime_in_simulated_days += max_number_of_retries * num_of_lookahead_days / 2
  2080                                                   #     elif row.Partial_Payment_Allowed:
  2081                                                   #         p2plus_txns_max_runtime_in_simulated_days += 2 * num_of_lookahead_days
  2082                                                   #     else:
  2083                                                   #         p2plus_txns_max_runtime_in_simulated_days += num_of_lookahead_days
  2084                                                   # total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + p2plus_txns_max_runtime_in_simulated_days
  2085                                                   #
  2086                                                   # On second thought, I would rather deal wit ha stilted progress bar than figuring out how to track progress in recursion
  2087                                                   no_of_p2plus_priority_levels = len(set(self.initial_proposed_df.Priority))
  2088         1        142.0    142.0      0.0          total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + predicted_satisfice_runtime_in_simulated_days * no_of_p2plus_priority_levels
  2089         1          1.0      1.0      0.0          progress_bar = tqdm.tqdm(range(total_predicted_max_runtime_in_simulated_days),total=total_predicted_max_runtime_in_simulated_days, desc=self.unique_id, disable=True) #disabled tqdm
  2090         1      20116.0  20116.0      0.0  
  2091                                                   forecast_df, skipped_df, confirmed_df, deferred_df = self.computeOptimalForecast(
  2092         2  428138029.0    2e+08     99.9              start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2093         1         15.0     15.0      0.0              end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2094         1          1.0      1.0      0.0              confirmed_df=pd.DataFrame(self.initial_confirmed_df, copy=True),
  2095         1       1802.0   1802.0      0.0              proposed_df=pd.DataFrame(self.initial_proposed_df, copy=True),
  2096         1         93.0     93.0      0.0              deferred_df=pd.DataFrame(self.initial_deferred_df, copy=True),
  2097         1         64.0     64.0      0.0              skipped_df=pd.DataFrame(self.initial_skipped_df, copy=True),
  2098         1         58.0     58.0      0.0              account_set=copy.deepcopy(self.initial_account_set),
  2099         1       1039.0   1039.0      0.0              memo_rule_set=copy.deepcopy(self.initial_memo_rule_set),
  2100         1       1068.0   1068.0      0.0              raise_satisfice_failed_exception=False,progress_bar=progress_bar)
  2101         1          1.0      1.0      0.0  
  2102                                                   self.forecast_df = forecast_df
  2103         1          1.0      1.0      0.0          self.skipped_df = skipped_df
  2104         1          0.0      0.0      0.0          self.confirmed_df = confirmed_df
  2105         1          0.0      0.0      0.0          self.deferred_df = deferred_df
  2106         1          1.0      1.0      0.0  
  2107                                                   self.end_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2108         1         24.0     24.0      0.0          self.appendSummaryLines()
  2109         1     368186.0 368186.0      0.1          self.evaluateMilestones()
  2110         1         13.0     13.0      0.0  
  2111                                                   log_in_color(logger, 'white', 'info','Finished Forecast '+str(self.unique_id))
  2112         1         20.0     20.0      0.0          log_in_color(logger, 'white', 'info', self.forecast_df.to_string())
  2113         1      14492.0  14492.0      0.0          # if play_notification_sound:
  2114                                                   #     notification_sounds.play_notification_sound()
  2115                                           
  2116                                                   #self.forecast_df.to_csv('./out//Forecast_' + self.unique_id + '.csv') #this is only the forecast not the whole ExpenseForecast object
  2117                                                   #self.writeToJSONFile() #this is the whole ExpenseForecast object #todo this should accept a path parameter

Total time: 277.562 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: attemptTransaction at line 2413

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2413                                               def attemptTransaction(self, forecast_df, account_set, memo_set, confirmed_df, proposed_row_df):
  2414                                                   """
  2415                                                   Attempts to execute a proposed transaction and returns the hypothetical future state of the forecast
  2416                                                   if the transaction is permitted.
  2417                                           
  2418                                                   Parameters:
  2419                                                   - forecast_df: DataFrame containing the current forecast.
  2420                                                   - account_set: AccountSet object representing the current state of accounts.
  2421                                                   - memo_set: MemoSet object containing memo rules.
  2422                                                   - confirmed_df: DataFrame of confirmed transactions.
  2423                                                   - proposed_row: Series representing the proposed transaction.
  2424                                           
  2425                                                   Returns:
  2426                                                   - hypothetical_future_forecast: DataFrame representing the updated forecast if the transaction is permitted.
  2427                                           
  2428                                                   Raises:
  2429                                                   - ValueError: If an exception occurs that is not due to account boundary violations.
  2430                                                   """
  2431                                                   self.log_stack_depth += 1
  2432         2          4.0      2.0      0.0  
  2433                                                   try:
  2434         2          1.0      0.5      0.0              # Prepare the proposed transaction DataFrame
  2435                                                       single_proposed_transaction_df = proposed_row_df.to_frame().T.copy()
  2436         2       1031.0    515.5      0.0  
  2437                                                       # Combine the confirmed transactions with the proposed transaction
  2438                                                       updated_confirmed_df = pd.concat([confirmed_df, single_proposed_transaction_df], ignore_index=True)
  2439         2        582.0    291.0      0.0  
  2440                                                       # Create an empty DataFrame for proposed, deferred, and skipped transactions
  2441                                                       empty_df = pd.DataFrame(
  2442         4       3240.0    810.0      0.0                  columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  2443         2          5.0      2.5      0.0  
  2444                                                       # Determine the transaction date and previous date
  2445                                                       txn_date = proposed_row_df['Date']
  2446         2         34.0     17.0      0.0              txn_datetime = pd.to_datetime(txn_date, format='%Y%m%d')
  2447         2        602.0    301.0      0.0  
  2448                                                       # Find the previous date for synchronization
  2449                                                       previous_date = self.start_date_YYYYMMDD  # Optimization removed due to credit card prepayment considerations
  2450         2          2.0      1.0      0.0  
  2451                                                       # Synchronize the account set with the forecast on the previous date
  2452                                                       synced_account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, previous_date)
  2453         2     598788.0 299394.0      0.2  
  2454                                                       # Compute the hypothetical future forecast starting from the previous date
  2455                                                       hypothetical_future_forecast = self.computeOptimalForecast(
  2456         5  276956334.0    6e+07     99.8                  start_date_YYYYMMDD=previous_date,
  2457         2          1.0      0.5      0.0                  end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2458         2          1.0      0.5      0.0                  confirmed_df=updated_confirmed_df,
  2459         2          1.0      0.5      0.0                  proposed_df=empty_df,
  2460         2          1.0      0.5      0.0                  deferred_df=empty_df,
  2461         2          1.0      0.5      0.0                  skipped_df=empty_df,
  2462         2          0.0      0.0      0.0                  account_set=synced_account_set,
  2463         2          1.0      0.5      0.0                  memo_rule_set=memo_set
  2464         2          1.0      0.5      0.0              )[0]
  2465         1          0.0      0.0      0.0  
  2466                                                       # Exclude the first row since it's considered final and not part of the new forecast
  2467                                                       hypothetical_future_forecast = hypothetical_future_forecast.iloc[1:].copy()
  2468         1        218.0    218.0      0.0  
  2469                                                       # Extract past forecast rows before the transaction date
  2470                                                       past_forecast = forecast_df[forecast_df['Date'] < txn_date].copy()
  2471         1        672.0    672.0      0.0  
  2472                                                       # Combine past forecast with the hypothetical future forecast
  2473                                                       updated_forecast = pd.concat([past_forecast, hypothetical_future_forecast], ignore_index=True)
  2474         1        358.0    358.0      0.0  
  2475                                                       self.log_stack_depth -= 1
  2476         1          1.0      1.0      0.0  
  2477                                                       return updated_forecast  # Transaction is permitted
  2478         1          0.0      0.0      0.0  
  2479                                                   except ValueError as e:
  2480         1          1.0      1.0      0.0              # Log the exception
  2481                                                       log_in_color(logger, 'red', 'debug', str(e), self.log_stack_depth)
  2482         1         25.0     25.0      0.0  
  2483                                                       # Reraise the exception if it's not due to account boundary violations
  2484                                                       if 'Account boundaries were violated' not in str(e):
  2485         1          1.0      1.0      0.0                  raise e
  2486                                           
  2487                                                       self.log_stack_depth -= 1
  2488         1          0.0      0.0      0.0  
  2489                                                       # Return None to indicate that the transaction is not permitted
  2490                                                       return None
  2491         1         83.0     83.0      0.0  
  2492                                           
  2493                                                   # #print('ENTER attemptTransaction '+proposed_row_df.Memo.iat[0])
  2494                                                   # # log_in_color(logger,'green','info','ENTER attemptTransaction( C:'+str(confirmed_df.shape[0])+' P:'+str(proposed_row_df.Memo)+')',self.log_stack_depth)
  2495                                                   # # log_in_color(logger, 'magenta', 'debug', 'forecast_df BEFORE:')
  2496                                                   # # log_in_color(logger, 'magenta', 'debug', forecast_df.to_string() )
  2497                                                   # self.log_stack_depth += 1
  2498                                                   # try:
  2499                                                   #     single_proposed_transaction_df = pd.DataFrame(copy.deepcopy(proposed_row_df)).T
  2500                                                   #     # print('single_proposed_transaction_df:')
  2501                                                   #     # print(single_proposed_transaction_df.to_string())
  2502                                                   #     not_yet_validated_confirmed_df = copy.deepcopy(pd.concat([confirmed_df, single_proposed_transaction_df]))
  2503                                                   #     empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  2504                                                   #
  2505                                                   #     # hypothetical_future_state_of_forecast = \
  2506                                                   #     #     self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2507                                                   #     #                                 end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2508                                                   #     #                                 confirmed_df=not_yet_validated_confirmed_df,
  2509                                                   #     #                                 proposed_df=empty_df,
  2510                                                   #     #                                 deferred_df=empty_df,
  2511                                                   #     #                                 skipped_df=empty_df,
  2512                                                   #     #                                 account_set=copy.deepcopy(
  2513                                                   #     #                                     self.sync_account_set_w_forecast_day(account_set, forecast_df,
  2514                                                   #     #                                                                          self.start_date_YYYYMMDD)),
  2515                                                   #     #                                 memo_rule_set=memo_set)[0]
  2516                                                   #
  2517                                                   #     txn_date = proposed_row_df.Date
  2518                                                   #     d_sel_vec = ( datetime.datetime.strptime(d,'%Y%m%d') <= datetime.datetime.strptime(txn_date,'%Y%m%d') for d in forecast_df.Date )
  2519                                                   #     previous_row_df = forecast_df.loc[ d_sel_vec, : ].tail(2).head(1)
  2520                                                   #
  2521                                                   #     # log_in_color(logger, 'white', 'debug', 'previous_row_df:',self.log_stack_depth)
  2522                                                   #     # log_in_color(logger, 'white', 'debug', previous_row_df.to_string(),self.log_stack_depth)
  2523                                                   #
  2524                                                   #     #previous_date = previous_row_df.Date.iat[0]
  2525                                                   #     previous_date = self.start_date_YYYYMMDD #todo this optimization had to be removed bc of cc prepayment
  2526                                                   #
  2527                                                   #     #note that there may also be confirmed txns on the same day as the proposed txn
  2528                                                   #     # print('attempt transaction case 1 sync')
  2529                                                   #
  2530                                                   #     hypothetical_future_state_of_forecast_future_rows_only = \
  2531                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=previous_date,
  2532                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2533                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  2534                                                   #                                     proposed_df=empty_df,
  2535                                                   #                                     deferred_df=empty_df,
  2536                                                   #                                     skipped_df=empty_df,
  2537                                                   #                                     account_set=copy.deepcopy(
  2538                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,previous_date)),
  2539                                                   #                                     memo_rule_set=memo_set)[0]
  2540                                                   #
  2541                                                   #     #we started the sub-forecast on the previous date, bc that day is considered final
  2542                                                   #     #therefore, we can drop it from the concat bc it is not new
  2543                                                   #     hypothetical_future_state_of_forecast_future_rows_only = hypothetical_future_state_of_forecast_future_rows_only.iloc[1:,:]
  2544                                                   #
  2545                                                   #     # log_in_color(logger,'white','debug','hypothetical_future_state_of_forecast_future_rows_only:',self.log_stack_depth)
  2546                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2547                                                   #
  2548                                                   #     date_array = [ datetime.datetime.strptime(d,'%Y%m%d') for d in forecast_df.Date ]
  2549                                                   #     row_sel_vec = [ d < datetime.datetime.strptime(txn_date,'%Y%m%d') for d in date_array ]
  2550                                                   #
  2551                                                   #     past_confirmed_forecast_rows_df = forecast_df[ row_sel_vec ]
  2552                                                   #
  2553                                                   #     # log_in_color(logger, 'white', 'debug', 'past_confirmed_forecast_rows_df:', self.log_stack_depth)
  2554                                                   #     # log_in_color(logger, 'white', 'debug', past_confirmed_forecast_rows_df.to_string(), self.log_stack_depth)
  2555                                                   #     # log_in_color(logger, 'white', 'debug', 'hypothetical_future_state_of_forecast_future_rows_only:', self.log_stack_depth)
  2556                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2557                                                   #
  2558                                                   #     hypothetical_future_state_of_forecast = pd.concat([past_confirmed_forecast_rows_df,hypothetical_future_state_of_forecast_future_rows_only])
  2559                                                   #     # log_in_color(logger, 'green', 'info', hypothetical_future_state_of_forecast.to_string(), self.log_stack_depth)
  2560                                                   #
  2561                                                   #     self.log_stack_depth -= 1
  2562                                                   #
  2563                                                   #     #log_in_color(logger, 'green', 'debug',hypothetical_future_state_of_forecast.to_string())
  2564                                                   #     # log_in_color(logger, 'magenta', 'debug', 'forecast_df AFTER:')
  2565                                                   #     # log_in_color(logger, 'magenta', 'debug', hypothetical_future_state_of_forecast.to_string())
  2566                                                   #     # log_in_color(logger, 'green', 'info', 'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (SUCCESS)', self.log_stack_depth)
  2567                                                   #     #print('EXIT attemptTransaction')
  2568                                                   #     return hypothetical_future_state_of_forecast #transaction is permitted
  2569                                                   # except ValueError as e:
  2570                                                   #     self.log_stack_depth -= 5  # several decrements were skipped over by the exception
  2571                                                   #     # log_in_color(logger, 'white', 'debug', 'forecast_df AFTER:')
  2572                                                   #     # log_in_color(logger, 'white', 'debug', forecast_df.to_string())
  2573                                                   #     log_in_color(logger, 'red', 'debug',str(e), self.log_stack_depth)
  2574                                                   #     # log_in_color(logger, 'red', 'debug', account_set.getAccounts().to_string(), self.log_stack_depth)
  2575                                                   #     # log_in_color(logger, 'red', 'info',
  2576                                                   #     #              'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (FAIL)', self.log_stack_depth)
  2577                                                   #     # print(e.args)
  2578                                                   #     #print('EXIT attemptTransaction')
  2579                                                   #     if re.search('.*Account boundaries were violated.*',str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  2580                                                   #         raise e

Total time: 47.9338 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processConfirmedTransactions at line 2583

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2583                                               def processConfirmedTransactions(self, forecast_df, relevant_confirmed_df, memo_set, account_set, date_YYYYMMDD):
  2584                                                   # log_in_color(logger, 'green', 'debug', 'ENTER processConfirmedTransactions( C:'+str(relevant_confirmed_df.shape[0])+' ) '+str(date_YYYYMMDD), self.log_stack_depth)
  2585                                                   self.log_stack_depth += 1
  2586       213        353.0      1.7      0.0          # print('BEGIN processConfirmedTransactions('+date_YYYYMMDD+')')
  2587                                           
  2588                                                   for confirmed_index, confirmed_row in relevant_confirmed_df.iterrows():
  2589       370      21377.0     57.8      0.0              # print('    '+str(confirmed_row.Memo)+' '+str(confirmed_row.Amount))
  2590                                                       relevant_memo_rule_set = memo_set.findMatchingMemoRule(confirmed_row.Memo, confirmed_row.Priority)
  2591       158    3236505.0  20484.2      6.8              memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  2592       158     287082.0   1817.0      0.6  
  2593                                                       income_flag = self.checkIfTxnIsIncome(confirmed_row)
  2594       158       6728.0     42.6      0.0  
  2595                                                       account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  2596       316    4901482.0  15511.0     10.2                                             Account_To=memo_rule_row.Account_To,
  2597       158       3307.0     20.9      0.0                                             Amount=confirmed_row.Amount,
  2598       158       2734.0     17.3      0.0                                             income_flag=income_flag)
  2599       158         60.0      0.4      0.0  
  2600                                                       forecast_df = self.updateBalancesAndMemo(forecast_df, account_set, confirmed_row, memo_rule_row,
  2601       314   39473778.0 125712.7     82.4                                                       date_YYYYMMDD)
  2602       157         60.0      0.4      0.0  
  2603                                                   self.log_stack_depth -= 1
  2604       212        314.0      1.5      0.0          # log_in_color(logger, 'green', 'debug', 'EXIT processConfirmedTransactions()', self.log_stack_depth)
  2605                                                   # print('EXIT processConfirmedTransactions(' + date_YYYYMMDD + ')')
  2606                                                   return forecast_df

Total time: 0.134577 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getTotalPrepaidInCreditCardBillingCycle at line 2964

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2964                                               def getTotalPrepaidInCreditCardBillingCycle(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  2965                                                   """
  2966                                                   Calculates the total prepaid amount made towards a credit card in the billing cycle up to the given date.
  2967                                           
  2968                                                   Parameters:
  2969                                                   - account_name (str): The name of the credit card account.
  2970                                                   - account_set (AccountSet): The account set containing account information.
  2971                                                   - forecast_df (pd.DataFrame): The forecast DataFrame with financial data.
  2972                                                   - date_YYYYMMDD (str): The current date in 'YYYYMMDD' format.
  2973                                           
  2974                                                   Returns:
  2975                                                   - float: The total prepaid amount in the current billing cycle.
  2976                                                   """
  2977                                                   # Extract the base account name (without sub-accounts)
  2978                                                   base_account_name = account_name.split(':')[0]
  2979         4          6.0      1.5      0.0  
  2980                                                   # Filter the account row for the given account name and type
  2981                                                   accounts_df = account_set.getAccounts()
  2982         4     117229.0  29307.2     87.1          account_row = accounts_df[
  2983         8       2396.0    299.5      1.8              (accounts_df['Name'].str.startswith(base_account_name)) &
  2984         8       2393.0    299.1      1.8              (accounts_df['Account_Type'] == 'credit prev stmt bal')
  2985         4       1015.0    253.8      0.8              ]
  2986                                           
  2987                                                   if account_row.empty:
  2988         4         49.0     12.2      0.0              raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  2989                                           
  2990                                                   # Get the billing start date
  2991                                                   billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  2992         4        346.0     86.5      0.3          billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  2993         4       1416.0    354.0      1.1  
  2994                                                   # Convert the current date to datetime
  2995                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  2996         4       1310.0    327.5      1.0  
  2997                                                   # Generate billing dates up to the current date
  2998                                                   num_months = (current_date.year - billing_start_date.year) * 12 + (
  2999         8         10.0      1.2      0.0                      current_date.month - billing_start_date.month)
  3000         4          0.0      0.0      0.0          billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 1, freq='MS').strftime('%Y%m%d')
  3001         4       2431.0    607.8      1.8  
  3002                                                   # Determine the start and end of the billing cycle
  3003                                                   if billing_dates.empty:
  3004         4         18.0      4.5      0.0              billing_cycle_start_date = billing_start_date_str
  3005                                                   else:
  3006                                                       billing_cycle_start_date = billing_dates[-1]
  3007         4         19.0      4.8      0.0  
  3008                                                   # Define the time window to search for payments
  3009                                                   lookback_period_start = (current_date - pd.Timedelta(days=35)).strftime('%Y%m%d')
  3010         4        244.0     61.0      0.2          lookback_period_end = date_YYYYMMDD
  3011         4          3.0      0.8      0.0  
  3012                                                   # Filter forecast_df for the relevant date range
  3013                                                   date_filtered_df = forecast_df[
  3014         8       1003.0    125.4      0.7              (forecast_df['Date'] > billing_cycle_start_date) &
  3015         8       1550.0    193.8      1.2              (forecast_df['Date'] <= lookback_period_end)
  3016         4        816.0    204.0      0.6              ]
  3017                                           
  3018                                                   # Check for additional credit card payments in the memo directives
  3019                                                   def extract_payment_amount(memo):
  3020         4         10.0      2.5      0.0              matches = re.findall(r'ADDTL CC PAYMENT \((.*?)\$\s*([0-9]*\.[0-9]{1,2})\)', memo)
  3021                                                       total = 0.0
  3022                                                       for acc_name, amount_str in matches:
  3023                                                           acc_name = acc_name.replace('-', '').strip()
  3024                                                           if acc_name == account_row['Name'].iloc[0].replace('-', '').strip():
  3025                                                               try:
  3026                                                                   amount = float(amount_str)
  3027                                                                   total += amount
  3028                                                               except ValueError:
  3029                                                                   continue
  3030                                                       return total
  3031                                           
  3032                                                   # Calculate the total prepaid amount
  3033                                                   total_prepaid_amount = date_filtered_df['Memo Directives'].apply(extract_payment_amount).sum()
  3034         4       2310.0    577.5      1.7  
  3035                                                   return total_prepaid_amount

Total time: 0.033172 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getFutureMinPaymentAmount at line 3119

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3119                                               def getFutureMinPaymentAmount(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  3120                                                   """
  3121                                                   Calculates the future minimum payment amount for a given credit card account starting from a specific date.
  3122                                           
  3123                                                   Parameters:
  3124                                                   - account_name (str): The name of the credit card account.
  3125                                                   - account_set (AccountSet): The account set containing account information.
  3126                                                   - forecast_df (pd.DataFrame): The forecast DataFrame containing financial data.
  3127                                                   - date_YYYYMMDD (str): The date from which to start the calculation, in 'YYYYMMDD' format.
  3128                                           
  3129                                                   Returns:
  3130                                                   - float: The minimum payment amount due in the future, or 0.0 if no payment is due.
  3131                                                   """
  3132                                                   import pandas as pd
  3133         1          2.0      2.0      0.0  
  3134                                                   # Extract the base account name (before any colons)
  3135                                                   base_account_name = account_name.split(':')[0]
  3136         1          1.0      1.0      0.0  
  3137                                                   # Get the account row for the specified account name and account type 'credit prev stmt bal'
  3138                                                   accounts_df = account_set.getAccounts()
  3139         1      29552.0  29552.0     89.1          account_row = accounts_df[
  3140         2        651.0    325.5      2.0              (accounts_df['Name'].str.startswith(base_account_name)) &
  3141         2        744.0    372.0      2.2              (accounts_df['Account_Type'] == 'credit prev stmt bal')
  3142         1        255.0    255.0      0.8              ]
  3143                                           
  3144                                                   if account_row.empty:
  3145         1          9.0      9.0      0.0              raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  3146                                           
  3147                                                   # Get the forecast row for the specified date
  3148                                                   current_forecast_row_df = forecast_df[forecast_df['Date'] == date_YYYYMMDD]
  3149         1        389.0    389.0      1.2  
  3150                                                   if current_forecast_row_df.empty:
  3151         1          7.0      7.0      0.0              raise ValueError(f"Date '{date_YYYYMMDD}' not found in forecast DataFrame.")
  3152                                           
  3153                                                   # Check if there is a minimum payment on the current date
  3154                                                   memo_directives = current_forecast_row_df['Memo Directives'].iat[0]
  3155         1         65.0     65.0      0.2          min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3156         1         26.0     26.0      0.1  
  3157                                                   if min_payment_amount > 0:
  3158         1          1.0      1.0      0.0              return min_payment_amount
  3159                                           
  3160                                                   # If no minimum payment on the current date, find the next billing date
  3161                                           
  3162                                                   # Convert dates to datetime objects
  3163                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3164         1        343.0    343.0      1.0          billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  3165         1         83.0     83.0      0.3          billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  3166         1        254.0    254.0      0.8  
  3167                                                   # Generate billing dates starting from the billing start date
  3168                                                   if current_date < billing_start_date:
  3169         1          1.0      1.0      0.0              next_billing_date = billing_start_date
  3170                                                   else:
  3171                                                       # Calculate the number of months between the billing start date and current date
  3172                                                       num_months = (current_date.year - billing_start_date.year) * 12 + (
  3173         2          3.0      1.5      0.0                          current_date.month - billing_start_date.month)
  3174         1          1.0      1.0      0.0              billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 2, freq='MS')
  3175         1        265.0    265.0      0.8  
  3176                                                       # Find the next billing date after the current date
  3177                                                       future_billing_dates = billing_dates[billing_dates > current_date]
  3178         1        185.0    185.0      0.6              if not future_billing_dates.empty:
  3179         1          4.0      4.0      0.0                  next_billing_date = future_billing_dates.min()
  3180         1         70.0     70.0      0.2              else:
  3181                                                           # If no future billing dates are found, set next billing date to billing start date
  3182                                                           next_billing_date = billing_start_date
  3183                                           
  3184                                                   # Check if next billing date is beyond the forecast end date
  3185                                                   forecast_end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3186         1        260.0    260.0      0.8          if next_billing_date > forecast_end_date:
  3187         1          1.0      1.0      0.0              return 0.0
  3188         1          0.0      0.0      0.0  
  3189                                                   # Get the forecast row for the next billing date
  3190                                                   next_billing_date_str = next_billing_date.strftime('%Y%m%d')
  3191                                                   next_forecast_row_df = forecast_df[forecast_df['Date'] == next_billing_date_str]
  3192                                           
  3193                                                   if next_forecast_row_df.empty:
  3194                                                       return 0.0
  3195                                           
  3196                                                   # Extract minimum payment amount from the memo directives on the next billing date
  3197                                                   memo_directives = next_forecast_row_df['Memo Directives'].iat[0]
  3198                                                   min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3199                                           
  3200                                                   return min_payment_amount

Total time: 6e-06 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _extract_min_payment_amount at line 3203

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3203                                               def _extract_min_payment_amount(self, memo_directives, base_account_name):
  3204                                                   """
  3205                                                   Helper function to extract the minimum payment amount from memo directives.
  3206                                           
  3207                                                   Parameters:
  3208                                                   - memo_directives (str): The memo directives string.
  3209                                                   - base_account_name (str): The base account name.
  3210                                           
  3211                                                   Returns:
  3212                                                   - float: The total minimum payment amount found in the memo directives.
  3213                                                   """
  3214                                                   import re
  3215         1          3.0      3.0     50.0  
  3216                                                   min_payment_amount = 0.0
  3217         1          1.0      1.0     16.7          memo_items = memo_directives.split(';')
  3218         1          1.0      1.0     16.7          for memo in memo_items:
  3219         2          0.0      0.0      0.0              memo = memo.strip()
  3220         1          1.0      1.0     16.7              if not memo:
  3221         1          0.0      0.0      0.0                  continue
  3222         1          0.0      0.0      0.0              # Check for minimum payment directives for both previous and current statement balances
  3223                                                       if (f'CC MIN PAYMENT ({base_account_name}: Prev Stmt Bal' in memo or
  3224                                                               f'CC MIN PAYMENT ({base_account_name}: Curr Stmt Bal' in memo):
  3225                                                           match = re.search(r'\(.*-\$(\d+(\.\d{1,2})?)\)', memo)
  3226                                                           if match:
  3227                                                               amount = float(match.group(1))
  3228                                                               min_payment_amount += amount
  3229                                                   return min_payment_amount

Total time: 177.103 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processProposedTransactions at line 3537

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3537                                               def processProposedTransactions(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df,
  3538                                                                                 relevant_proposed_df, priority_level):
  3539                                                   """
  3540                                                   Processes proposed transactions by attempting to execute them, handling partial payments, deferrals,
  3541                                                   and updating the forecast accordingly.
  3542                                           
  3543                                                   Parameters:
  3544                                                   - account_set: AccountSet object representing the current state of accounts.
  3545                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3546                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3547                                                   - memo_set: MemoSet object containing memo rules.
  3548                                                   - confirmed_df: DataFrame of confirmed transactions.
  3549                                                   - relevant_proposed_df: DataFrame of proposed transactions for the current date.
  3550                                                   - priority_level: Integer representing the priority level.
  3551                                           
  3552                                                   Returns:
  3553                                                   - forecast_df: Updated forecast DataFrame.
  3554                                                   - new_confirmed_df: DataFrame of newly confirmed transactions.
  3555                                                   - new_deferred_df: DataFrame of newly deferred transactions.
  3556                                                   - new_skipped_df: DataFrame of newly skipped transactions.
  3557                                                   """
  3558                                                   # Increment the log stack depth
  3559                                                   self.log_stack_depth += 1
  3560        98         82.0      0.8      0.0  
  3561                                                   # Initialize DataFrames to hold new deferred, skipped, and confirmed transactions
  3562                                                   new_deferred_df = relevant_proposed_df.iloc[0:0].copy()  # Empty DataFrame with the same schema
  3563        98      12862.0    131.2      0.0          new_skipped_df = relevant_proposed_df.iloc[0:0].copy()
  3564        98       8833.0     90.1      0.0          new_confirmed_df = relevant_proposed_df.iloc[0:0].copy()
  3565        98       8478.0     86.5      0.0  
  3566                                                   # If there are no proposed transactions, return early
  3567                                                   if relevant_proposed_df.empty:
  3568        98        813.0      8.3      0.0              self.log_stack_depth -= 1
  3569        97        136.0      1.4      0.0              return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df
  3570        97         58.0      0.6      0.0  
  3571                                                   # Iterate over each proposed transaction
  3572                                                   for proposed_index, proposed_row in relevant_proposed_df.iterrows():
  3573         2        100.0     50.0      0.0              # Find the matching memo rule for the proposed transaction
  3574                                                       memo_rule_set = memo_set.findMatchingMemoRule(proposed_row['Memo'], proposed_row['Priority'])
  3575         1      15345.0  15345.0      0.0              memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  3576         1       1473.0   1473.0      0.0  
  3577                                                       # Attempt to execute the transaction
  3578                                                       result = self.attemptTransaction(
  3579         2   88304891.0    4e+07     49.9                  forecast_df=forecast_df,
  3580         1          0.0      0.0      0.0                  account_set=copy.deepcopy(account_set),
  3581         1        501.0    501.0      0.0                  memo_set=memo_set,
  3582         1          0.0      0.0      0.0                  confirmed_df=confirmed_df,
  3583         1          0.0      0.0      0.0                  proposed_row_df=proposed_row
  3584         1          0.0      0.0      0.0              )
  3585                                           
  3586                                           
  3587                                                       # Check if the transaction is permitted (returns a DataFrame if successful)
  3588                                                       transaction_permitted = isinstance(result, pd.DataFrame)
  3589         1          2.0      2.0      0.0  
  3590                                                       if transaction_permitted:
  3591         1          0.0      0.0      0.0                  # Transaction is permitted; update the hypothetical future forecast and account set
  3592                                                           hypothetical_forecast = result
  3593                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3594                                                       else:
  3595                                                           hypothetical_forecast = None
  3596         1          1.0      1.0      0.0  
  3597                                                       # Handle partial payments if transaction is not permitted and partial payments are allowed
  3598                                                       if not transaction_permitted and proposed_row['Partial_Payment_Allowed']:
  3599         1         25.0     25.0      0.0                  # Get the minimum future available balances
  3600                                                           min_future_balances = self.getMinimumFutureAvailableBalances(account_set, forecast_df, date_YYYYMMDD)
  3601         1      32012.0  32012.0      0.0                  max_available_funds = min_future_balances.get(memo_rule_row['Account_From'], 0.0)
  3602         1         44.0     44.0      0.0  
  3603                                                           # Determine the maximum amount that can be transferred to the destination account
  3604                                                           reduced_amount = self.calculate_reduced_amount(
  3605         2      92794.0  46397.0      0.1                      account_set=account_set,
  3606         1          0.0      0.0      0.0                      memo_rule_row=memo_rule_row,
  3607         1          0.0      0.0      0.0                      max_available_funds=max_available_funds,
  3608         1          0.0      0.0      0.0                      forecast_df=forecast_df,
  3609         1          1.0      1.0      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3610         1          0.0      0.0      0.0                  )
  3611                                           
  3612                                                           # Attempt the transaction with the reduced amount if it's greater than zero
  3613                                                           if reduced_amount > 0:
  3614         1          1.0      1.0      0.0                      proposed_row['Amount'] = reduced_amount
  3615         1         43.0     43.0      0.0  
  3616                                                               result = self.attemptTransaction(
  3617         2   87927925.0    4e+07     49.6                          forecast_df=forecast_df,
  3618         1          1.0      1.0      0.0                          account_set=copy.deepcopy(account_set),
  3619         1        513.0    513.0      0.0                          memo_set=memo_set,
  3620         1          0.0      0.0      0.0                          confirmed_df=confirmed_df,
  3621         1          0.0      0.0      0.0                          proposed_row_df=proposed_row
  3622         1          0.0      0.0      0.0                      )
  3623                                           
  3624                                                               transaction_permitted = isinstance(result, pd.DataFrame)
  3625         1          2.0      2.0      0.0  
  3626                                                               if transaction_permitted:
  3627         1          1.0      1.0      0.0                          hypothetical_forecast = result
  3628         1          0.0      0.0      0.0                          account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3629         1     286342.0 286342.0      0.2                      else:
  3630                                                                   hypothetical_forecast = None
  3631                                           
  3632                                                       # Handle deferrable transactions if not permitted
  3633                                                       if not transaction_permitted and proposed_row['Deferrable']:
  3634         1          1.0      1.0      0.0                  # Find the next income date
  3635                                                           next_income_date = self.find_next_income_date(forecast_df, date_YYYYMMDD)
  3636                                           
  3637                                                           # Update the date of the proposed transaction to the next income date
  3638                                                           proposed_row['Date'] = next_income_date
  3639                                           
  3640                                                           # Add the transaction to the deferred DataFrame
  3641                                                           new_deferred_df = pd.concat([new_deferred_df, proposed_row.to_frame().T], ignore_index=True)
  3642                                           
  3643                                                       elif not transaction_permitted and not proposed_row['Deferrable']:
  3644         1          0.0      0.0      0.0                  # Add the transaction to the skipped DataFrame
  3645                                                           new_skipped_df = pd.concat([new_skipped_df, proposed_row.to_frame().T], ignore_index=True)
  3646                                           
  3647                                                       elif transaction_permitted:
  3648         1          0.0      0.0      0.0                  # Transaction is permitted; execute it and update the forecast and account set
  3649                                                           if priority_level > 1:
  3650         1          1.0      1.0      0.0                      account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3651         1     288280.0 288280.0      0.2  
  3652                                                           account_set.executeTransaction(
  3653         2      84583.0  42291.5      0.0                      Account_From=memo_rule_row['Account_From'],
  3654         1         12.0     12.0      0.0                      Account_To=memo_rule_row['Account_To'],
  3655         1          8.0      8.0      0.0                      Amount=proposed_row['Amount'],
  3656         1         10.0     10.0      0.0                      income_flag=False
  3657         1          1.0      1.0      0.0                  )
  3658                                           
  3659                                                           # Add the transaction to the confirmed DataFrame
  3660                                                           new_confirmed_df = pd.concat([new_confirmed_df, proposed_row.to_frame().T], ignore_index=True)
  3661         1        718.0    718.0      0.0  
  3662                                                           # Update the forecast DataFrame with the hypothetical future forecast
  3663                                                           forecast_df = self.update_forecast_with_hypothetical(
  3664         2       2583.0   1291.5      0.0                      forecast_df=forecast_df,
  3665         1          0.0      0.0      0.0                      hypothetical_forecast=hypothetical_forecast,
  3666         1          0.0      0.0      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3667         1          0.0      0.0      0.0                  )
  3668                                           
  3669                                                           # Update the account balances in the forecast DataFrame for the current date
  3670                                                           self.update_forecast_balances(
  3671         2      33637.0  16818.5      0.0                      forecast_df=forecast_df,
  3672         1          0.0      0.0      0.0                      account_set=account_set,
  3673         1          0.0      0.0      0.0                      date_YYYYMMDD=date_YYYYMMDD
  3674         1          0.0      0.0      0.0                  )
  3675                                                       else:
  3676                                                           # This case should not occur; raise an error
  3677                                                           raise ValueError(
  3678                                                               "Unexpected case in process_proposed_transactions:\n"
  3679                                                               f"transaction_permitted: {transaction_permitted}\n"
  3680                                                               f"Deferrable: {proposed_row['Deferrable']}\n"
  3681                                                               f"Partial_Payment_Allowed: {proposed_row['Partial_Payment_Allowed']}\n"
  3682                                                           )
  3683                                           
  3684                                                   # Decrement the log stack depth
  3685                                                   self.log_stack_depth -= 1
  3686         1          2.0      2.0      0.0  
  3687                                                   return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df

Total time: 0.092741 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculate_reduced_amount at line 3690

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3690                                               def calculate_reduced_amount(self, account_set, memo_rule_row, max_available_funds, forecast_df, date_YYYYMMDD):
  3691                                                   """
  3692                                                   Calculates the maximum amount that can be transferred based on available funds and account types.
  3693                                           
  3694                                                   Parameters:
  3695                                                   - account_set: AccountSet object representing the current state of accounts.
  3696                                                   - memo_rule_row: Series representing the memo rule for the transaction.
  3697                                                   - max_available_funds: Float representing the maximum available funds from the source account.
  3698                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3699                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3700                                           
  3701                                                   Returns:
  3702                                                   - reduced_amount: Float representing the reduced transaction amount.
  3703                                                   """
  3704                                                   # Get the account types for the destination account
  3705                                                   account_base_names = account_set.getAccounts()['Name'].apply(lambda x: x.split(':')[0])
  3706         1      30164.0  30164.0     32.5          destination_accounts = account_set.getAccounts()[account_base_names == memo_rule_row['Account_To']]
  3707         1      28972.0  28972.0     31.2          account_types = destination_accounts['Account_Type'].tolist()
  3708         1         82.0     82.0      0.1  
  3709                                                   # Determine the account type
  3710                                                   if 'credit curr stmt bal' in account_types and 'credit prev stmt bal' in account_types:
  3711         1          1.0      1.0      0.0              account_type = 'credit'
  3712         1          1.0      1.0      0.0          elif 'principal balance' in account_types and 'interest' in account_types:
  3713                                                       account_type = 'loan'
  3714                                                   elif len(account_types) == 1 and account_types[0] == 'checking':
  3715                                                       account_type = 'checking'
  3716                                                   else:
  3717                                                       account_type = 'none'
  3718                                           
  3719                                                   # Calculate the maximum amount that can be transferred to the destination account
  3720                                                   if account_type == 'credit':
  3721         1          1.0      1.0      0.0              total_balance = destination_accounts['Balance'].sum()
  3722         1        236.0    236.0      0.3              future_min_payment = self.getFutureMinPaymentAmount(
  3723         2      33242.0  16621.0     35.8                  account_name=memo_rule_row['Account_To'],
  3724         1         39.0     39.0      0.0                  account_set=account_set,
  3725         1          0.0      0.0      0.0                  forecast_df=forecast_df,
  3726         1          0.0      0.0      0.0                  date_YYYYMMDD=date_YYYYMMDD
  3727         1          1.0      1.0      0.0              )
  3728                                                       reduced_amount = min(max_available_funds, total_balance)
  3729         1          2.0      2.0      0.0          elif account_type in ['checking', 'loan']:
  3730                                                       total_balance = destination_accounts['Balance'].sum()
  3731                                                       reduced_amount = min(max_available_funds, total_balance)
  3732                                                   elif account_type == 'none':
  3733                                                       reduced_amount = max_available_funds
  3734                                                   else:
  3735                                                       raise ValueError('Invalid account type in calculate_reduced_amount')
  3736                                           
  3737                                                   return reduced_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: find_next_income_date at line 3740

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3740                                               def find_next_income_date(self, forecast_df, date_YYYYMMDD):
  3741                                                   """
  3742                                                   Finds the next income date after the given date.
  3743                                           
  3744                                                   Parameters:
  3745                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3746                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3747                                           
  3748                                                   Returns:
  3749                                                   - next_income_date: String representing the next income date in 'YYYYMMDD' format.
  3750                                                   """
  3751                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3752                                           
  3753                                                   # Filter future dates
  3754                                                   future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  3755                                           
  3756                                                   # Filter rows where the memo indicates income
  3757                                                   income_rows = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  3758                                           
  3759                                                   if not income_rows.empty:
  3760                                                       next_income_date = income_rows['Date'].iloc[0]
  3761                                                   else:
  3762                                                       # If no future income dates, set to one day after the forecast end date
  3763                                                       end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3764                                                       next_income_date = (end_date + pd.Timedelta(days=1)).strftime('%Y%m%d')
  3765                                           
  3766                                                   return next_income_date

Total time: 0.00256 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_with_hypothetical at line 3769

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3769                                               def update_forecast_with_hypothetical(self, forecast_df, hypothetical_forecast, date_YYYYMMDD):
  3770                                                   """
  3771                                                   Updates the forecast DataFrame with the hypothetical future forecast starting from the given date.
  3772                                           
  3773                                                   Parameters:
  3774                                                   - forecast_df: DataFrame containing the current forecast data.
  3775                                                   - hypothetical_forecast: DataFrame containing the hypothetical future forecast.
  3776                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3777                                           
  3778                                                   Returns:
  3779                                                   - Updated forecast_df.
  3780                                                   """
  3781                                                   # Split the forecast into past and future
  3782                                                   past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  3783         1        432.0    432.0     16.9          future_forecast = hypothetical_forecast[hypothetical_forecast['Date'] >= date_YYYYMMDD]
  3784         1        442.0    442.0     17.3  
  3785                                                   # Concatenate the past and updated future forecasts
  3786                                                   updated_forecast = pd.concat([past_forecast, future_forecast], ignore_index=True)
  3787         1        274.0    274.0     10.7  
  3788                                                   # Ensure no duplicate dates
  3789                                                   updated_forecast = updated_forecast.drop_duplicates(subset=['Date'])
  3790         1       1412.0   1412.0     55.2  
  3791                                                   return updated_forecast

Total time: 0.033586 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_balances at line 3794

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3794                                               def update_forecast_balances(self, forecast_df, account_set, date_YYYYMMDD):
  3795                                                   """
  3796                                                   Updates the account balances in the forecast DataFrame for the current date based on the account set.
  3797                                           
  3798                                                   Parameters:
  3799                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3800                                                   - account_set: AccountSet object representing the current state of accounts.
  3801                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3802                                                   """
  3803                                                   # Update each account balance in the forecast
  3804                                                   for index, account_row in account_set.getAccounts().iterrows():
  3805         8      30315.0   3789.4     90.3              account_name = account_row['Name']
  3806         7        141.0     20.1      0.4              balance = account_row['Balance']
  3807         7         67.0      9.6      0.2  
  3808                                                       if account_name in forecast_df.columns:
  3809         7         18.0      2.6      0.1                  forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = balance

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processDeferredTransactions at line 4108

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4108                                               def processDeferredTransactions(self,account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df, priority_level, confirmed_df):
  4109                                                   """
  4110                                                       Processes deferred transactions by attempting to execute them, updating the forecast,
  4111                                                       and handling further deferrals if necessary.
  4112                                           
  4113                                                       Parameters:
  4114                                                       - account_set: AccountSet object representing the current state of accounts.
  4115                                                       - forecast_df: DataFrame containing the forecasted financial data.
  4116                                                       - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  4117                                                       - memo_set: MemoSet object containing memo rules.
  4118                                                       - relevant_deferred_df: DataFrame of deferred transactions relevant to the current date.
  4119                                                       - priority_level: Integer representing the priority level.
  4120                                                       - confirmed_df: DataFrame of confirmed transactions.
  4121                                           
  4122                                                       Returns:
  4123                                                       - forecast_df: Updated forecast DataFrame.
  4124                                                       - new_confirmed_df: DataFrame of newly confirmed transactions.
  4125                                                       - new_deferred_df: DataFrame of transactions that remain deferred.
  4126                                                       """
  4127                                                   # Increment log stack depth for logging purposes
  4128                                                   self.log_stack_depth += 1
  4129                                           
  4130                                                   # Initialize DataFrames for new confirmed and deferred transactions, preserving the schema
  4131                                                   new_confirmed_df = confirmed_df.iloc[0:0].copy()
  4132                                                   new_deferred_df = relevant_deferred_df.iloc[0:0].copy()
  4133                                           
  4134                                                   # Return early if there are no deferred transactions to process
  4135                                                   if relevant_deferred_df.empty:
  4136                                                       self.log_stack_depth -= 1
  4137                                                       return forecast_df, new_confirmed_df, new_deferred_df
  4138                                           
  4139                                                   # Iterate over each deferred transaction
  4140                                                   for deferred_index, deferred_row in relevant_deferred_df.iterrows():
  4141                                                       # Skip if the deferred date is beyond the forecast end date
  4142                                                       deferred_date = deferred_row['Date']
  4143                                                       if datetime.datetime.strptime(deferred_date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD,
  4144                                                                                                                                           '%Y%m%d'):
  4145                                                           continue
  4146                                           
  4147                                                       # Find the matching memo rule for the deferred transaction
  4148                                                       memo_rule_set = memo_set.findMatchingMemoRule(deferred_row['Memo'], deferred_row['Priority'])
  4149                                                       memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  4150                                           
  4151                                                       # Initialize an empty forecast DataFrame for the hypothetical future state
  4152                                                       hypothetical_future_forecast = forecast_df.iloc[0:0].copy()
  4153                                           
  4154                                                       try:
  4155                                                           # Combine the confirmed transactions with the deferred transaction
  4156                                                           updated_confirmed_df = pd.concat([confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4157                                           
  4158                                                           # Create empty DataFrames for proposed, deferred, and skipped transactions
  4159                                                           empty_df = pd.DataFrame(
  4160                                                               columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  4161                                           
  4162                                                           # Compute the optimal forecast including the deferred transaction
  4163                                                           hypothetical_future_forecast = self.computeOptimalForecast(
  4164                                                               start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4165                                                               end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4166                                                               confirmed_df=updated_confirmed_df,
  4167                                                               proposed_df=empty_df,
  4168                                                               deferred_df=empty_df,
  4169                                                               skipped_df=empty_df,
  4170                                                               account_set=copy.deepcopy(
  4171                                                                   self.sync_account_set_w_forecast_day(account_set, forecast_df, self.start_date_YYYYMMDD)
  4172                                                               ),
  4173                                                               memo_rule_set=memo_set
  4174                                                           )[0]
  4175                                           
  4176                                                           transaction_permitted = True
  4177                                                       except ValueError as e:
  4178                                                           # Check if the exception is due to account boundary violations
  4179                                                           if 'Account boundaries were violated' not in str(e):
  4180                                                               # Reraise the exception if it's not expected
  4181                                                               raise e
  4182                                                           transaction_permitted = False
  4183                                           
  4184                                                       if not transaction_permitted and deferred_row['Deferrable']:
  4185                                                           # Look ahead for the next income date
  4186                                                           future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  4187                                                           income_dates = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  4188                                                           if not income_dates.empty:
  4189                                                               next_income_date = income_dates['Date'].iloc[0]
  4190                                                           else:
  4191                                                               # If no future income date, set to one day after forecast end date
  4192                                                               next_income_date = (
  4193                                                                           datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(
  4194                                                                       days=1)).strftime('%Y%m%d')
  4195                                           
  4196                                                           # Update the deferred transaction's date
  4197                                                           deferred_row['Date'] = next_income_date
  4198                                           
  4199                                                           # Add the deferred transaction to the new deferred DataFrame
  4200                                                           new_deferred_df = pd.concat([new_deferred_df, deferred_row.to_frame().T], ignore_index=True)
  4201                                                       elif transaction_permitted:
  4202                                                           # If priority level is greater than 1, sync the account set with the forecast
  4203                                                           if priority_level > 1:
  4204                                                               account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4205                                           
  4206                                                           # Execute the transaction
  4207                                                           account_set.executeTransaction(
  4208                                                               Account_From=memo_rule_row['Account_From'],
  4209                                                               Account_To=memo_rule_row['Account_To'],
  4210                                                               Amount=deferred_row['Amount'],
  4211                                                               income_flag=False
  4212                                                           )
  4213                                           
  4214                                                           # Add the transaction to the new confirmed DataFrame
  4215                                                           new_confirmed_df = pd.concat([new_confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4216                                           
  4217                                                           # Remove the transaction from relevant deferred transactions
  4218                                                           relevant_deferred_df = relevant_deferred_df.drop(deferred_index)
  4219                                           
  4220                                                           # Update the forecast DataFrame with the hypothetical future forecast
  4221                                                           past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  4222                                                           future_forecast = hypothetical_future_forecast[hypothetical_future_forecast['Date'] >= date_YYYYMMDD]
  4223                                                           forecast_df = pd.concat([past_forecast, future_forecast], ignore_index=True)
  4224                                                           forecast_df.drop_duplicates(subset=['Date'], inplace=True)
  4225                                                           forecast_df.reset_index(drop=True, inplace=True)
  4226                                           
  4227                                                           # Update the account balances in the forecast DataFrame for the current date
  4228                                                           for account_row in account_set.getAccounts().itertuples():
  4229                                                               account_name = account_row.Name
  4230                                                               account_balance = account_row.Balance
  4231                                                               if account_name in forecast_df.columns:
  4232                                                                   forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = account_balance
  4233                                                       else:
  4234                                                           # This case should not occur; raise an error
  4235                                                           raise ValueError(f"""This is an edge case that should not be possible
  4236                                                                   transaction_permitted...............: {transaction_permitted}
  4237                                                                   deferred_row.Deferrable.............: {deferred_row['Deferrable']}
  4238                                                                   deferred_row.Partial_Payment_Allowed: {deferred_row['Partial_Payment_Allowed']}
  4239                                                                   """)
  4240                                           
  4241                                                   # Decrement log stack depth
  4242                                                   self.log_stack_depth -= 1
  4243                                           
  4244                                                   # Return the updated forecast and DataFrames
  4245                                                   return forecast_df, new_confirmed_df, new_deferred_df
  4246                                           
  4247                                                   # # log_in_color(logger, 'green', 'debug','ENTER processDeferredTransactions( D:'+str(relevant_deferred_df.shape[0])+' )', self.log_stack_depth)
  4248                                                   # self.log_stack_depth += 1
  4249                                                   #
  4250                                                   # #new_confirmed_df = pd.DataFrame(
  4251                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4252                                                   # #new_deferred_df = pd.DataFrame(
  4253                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4254                                                   # new_confirmed_df = confirmed_df.head(0) #to preserve schema
  4255                                                   # new_deferred_df = relevant_deferred_df.head(0)  # to preserve schema. same as above line btw
  4256                                                   #
  4257                                                   # if relevant_deferred_df.shape[0] == 0:
  4258                                                   #
  4259                                                   #     self.log_stack_depth -= 1
  4260                                                   #     # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4261                                                   #     return forecast_df, new_confirmed_df, new_deferred_df
  4262                                                   #
  4263                                                   # for deferred_item_index, deferred_row_df in relevant_deferred_df.iterrows():
  4264                                                   #     if datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d'):
  4265                                                   #         continue
  4266                                                   #
  4267                                                   #     relevant_memo_rule_set = memo_set.findMatchingMemoRule(deferred_row_df.Memo, deferred_row_df.Priority)
  4268                                                   #     memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  4269                                                   #
  4270                                                   #     hypothetical_future_state_of_forecast = copy.deepcopy(forecast_df.head(0))
  4271                                                   #
  4272                                                   #     try:
  4273                                                   #
  4274                                                   #         not_yet_validated_confirmed_df = pd.concat([confirmed_df, pd.DataFrame(deferred_row_df).T])
  4275                                                   #         #not_yet_validated_confirmed_df = confirmed_df.append(deferred_row_df)
  4276                                                   #
  4277                                                   #         empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  4278                                                   #
  4279                                                   #         # print('process deferred case 1 sync')
  4280                                                   #         hypothetical_future_state_of_forecast = \
  4281                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4282                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4283                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  4284                                                   #                                     proposed_df=empty_df,
  4285                                                   #                                     deferred_df=empty_df,
  4286                                                   #                                     skipped_df=empty_df,
  4287                                                   #                                     account_set=copy.deepcopy(
  4288                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,
  4289                                                   #                                                                              self.start_date_YYYYMMDD)),
  4290                                                   #                                     memo_rule_set=memo_set)[0]
  4291                                                   #
  4292                                                   #         transaction_is_permitted = True
  4293                                                   #     except ValueError as e:
  4294                                                   #         # log_in_color(logger, 'red', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4295                                                   #         if re.search('.*Account boundaries were violated.*',
  4296                                                   #                      str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  4297                                                   #             raise e
  4298                                                   #
  4299                                                   #         transaction_is_permitted = False
  4300                                                   #
  4301                                                   #     if not transaction_is_permitted and deferred_row_df.Deferrable:
  4302                                                   #
  4303                                                   #         # deferred_row_df.Date = (datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') + datetime.timedelta(
  4304                                                   #         #     days=1)).strftime('%Y%m%d')
  4305                                                   #
  4306                                                   #         #look ahead for next income date
  4307                                                   #         future_date_sel_vec = ( d > datetime.datetime.strptime(date_YYYYMMDD,'%Y%m%d') for d in forecast_df.Date )
  4308                                                   #         income_date_sel_vec = ( 'income' in m for m in forecast_df.Memo )
  4309                                                   #         next_income_date = forecast_df[ future_date_sel_vec & income_date_sel_vec ].head(1)['Date']
  4310                                                   #
  4311                                                   #         deferred_row_df.Date = next_income_date
  4312                                                   #         # print('new deferred row')
  4313                                                   #         # print(deferred_row_df.to_string())
  4314                                                   #
  4315                                                   #         #todo what is no future income date
  4316                                                   #
  4317                                                   #         new_deferred_df = pd.concat([new_deferred_df,pd.DataFrame(deferred_row_df).T])
  4318                                                   #
  4319                                                   #     elif transaction_is_permitted:
  4320                                                   #
  4321                                                   #         if priority_level > 1:
  4322                                                   #             # print('process deferred sync case 2')
  4323                                                   #             account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4324                                                   #
  4325                                                   #         account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  4326                                                   #                                        Account_To=memo_rule_row.Account_To, Amount=deferred_row_df.Amount,
  4327                                                   #                                        income_flag=False)
  4328                                                   #
  4329                                                   #
  4330                                                   #         new_confirmed_df = pd.concat([new_confirmed_df, pd.DataFrame(deferred_row_df).T])
  4331                                                   #
  4332                                                   #         remaining_unproposed_deferred_transactions_df = relevant_deferred_df[
  4333                                                   #             ~relevant_deferred_df.index.isin(deferred_row_df.index)]
  4334                                                   #         relevant_deferred_df = remaining_unproposed_deferred_transactions_df
  4335                                                   #
  4336                                                   #         # forecast_df, skipped_df, confirmed_df, deferred_df
  4337                                                   #         forecast_with_accurately_updated_future_rows = hypothetical_future_state_of_forecast
  4338                                                   #
  4339                                                   #         row_sel_vec = [
  4340                                                   #             datetime.datetime.strptime(d, '%Y%m%d') < datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4341                                                   #             in forecast_df.Date]
  4342                                                   #         forecast_rows_to_keep_df = forecast_df.loc[row_sel_vec, :]
  4343                                                   #
  4344                                                   #         row_sel_vec = [
  4345                                                   #             datetime.datetime.strptime(d, '%Y%m%d') >= datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4346                                                   #             in forecast_with_accurately_updated_future_rows.Date]
  4347                                                   #         new_forecast_rows_df = forecast_with_accurately_updated_future_rows.loc[row_sel_vec, :]
  4348                                                   #
  4349                                                   #         forecast_df = pd.concat([forecast_rows_to_keep_df, new_forecast_rows_df])
  4350                                                   #         assert forecast_df.shape[0] == forecast_df.drop_duplicates().shape[0]
  4351                                                   #         forecast_df.reset_index(drop=True, inplace=True)
  4352                                                   #
  4353                                                   #         for account_index, account_row in account_set.getAccounts().iterrows():
  4354                                                   #             if (account_index + 1) == account_set.getAccounts().shape[1]:
  4355                                                   #                 break
  4356                                                   #             relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  4357                                                   #
  4358                                                   #             row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  4359                                                   #             col_sel_vec = (forecast_df.columns == account_row.Name)
  4360                                                   #             forecast_df.iloc[row_sel_vec, col_sel_vec] = relevant_balance
  4361                                                   #     else:
  4362                                                   #         raise ValueError("""This is an edge case that should not be possible
  4363                                                   #                 transaction_is_permitted...............:""" + str(transaction_is_permitted) + """
  4364                                                   #                 budget_item_row.Deferrable.............:""" + str(deferred_row_df.Deferrable) + """
  4365                                                   #                 budget_item_row.Partial_Payment_Allowed:""" + str(deferred_row_df.Partial_Payment_Allowed) + """
  4366                                                   #                 """)
  4367                                                   #
  4368                                                   # self.log_stack_depth -= 1
  4369                                                   # # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4370                                                   # return forecast_df, new_confirmed_df, new_deferred_df

Total time: 86.7658 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeTransactionsForDay at line 4513

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4513                                               def executeTransactionsForDay(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, proposed_df,
  4514                                                                             deferred_df, skipped_df, priority_level):
  4515                                                   isP1 = (priority_level == 1)
  4516       213        184.0      0.9      0.0  
  4517                                                   # Filter transactions relevant to the current day and priority level
  4518                                                   relevant_proposed_df = proposed_df[
  4519       426      70212.0    164.8      0.1              (proposed_df.Priority == priority_level) & (proposed_df.Date == date_YYYYMMDD)]
  4520       213     142702.0    670.0      0.2          relevant_confirmed_df = confirmed_df[
  4521       426      52851.0    124.1      0.1              (confirmed_df.Priority == priority_level) & (confirmed_df.Date == date_YYYYMMDD)]
  4522       213     123428.0    579.5      0.1          relevant_deferred_df = deferred_df[
  4523       426      59796.0    140.4      0.1              (deferred_df.Priority <= priority_level) & (deferred_df.Date == date_YYYYMMDD)]
  4524       213     131043.0    615.2      0.2  
  4525                                                   self.log_stack_depth += 1
  4526       213        411.0      1.9      0.0  
  4527                                                   # Ensure no proposed transactions exist for priority 1
  4528                                                   if isP1:
  4529       213         80.0      0.4      0.0              assert relevant_proposed_df.empty
  4530       114       1052.0      9.2      0.0  
  4531                                                   # Check if there are pending confirmed transactions
  4532                                                   thereArePendingConfirmedTransactions = not relevant_confirmed_df.empty
  4533       213       1700.0      8.0      0.0  
  4534                                                   # Check if the current day exists in the forecast and if it's within the forecast range
  4535                                                   date_sel_vec = forecast_df['Date'] == date_YYYYMMDD
  4536       213      48091.0    225.8      0.1          noMatchingDayInForecast = forecast_df.loc[date_sel_vec].empty
  4537       213      49969.0    234.6      0.1          notPastEndOfForecast = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') <= datetime.datetime.strptime(
  4538       426      24254.0     56.9      0.0              self.end_date_YYYYMMDD, '%Y%m%d')
  4539       213        405.0      1.9      0.0  
  4540                                                   # Add a new day to the forecast if required
  4541                                                   if isP1 and noMatchingDayInForecast and notPastEndOfForecast:
  4542       213        122.0      0.6      0.0              forecast_df = self.addANewDayToTheForecast(forecast_df, date_YYYYMMDD)
  4543       114     176995.0   1552.6      0.2  
  4544                                                   # Sort transactions to prioritize income first
  4545                                                   if isP1 and thereArePendingConfirmedTransactions:
  4546       213        131.0      0.6      0.0              relevant_confirmed_df = self.sortTxnsToPutIncomeFirst(relevant_confirmed_df)
  4547       114     168198.0   1475.4      0.2  
  4548                                                   # Sync account set with the forecast for non-priority 1 transactions
  4549                                                   if priority_level > 1:
  4550       213        131.0      0.6      0.0              account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4551        99   30408361.0 307155.2     35.0  
  4552                                                   # Process confirmed transactions
  4553                                                   forecast_df = self.processConfirmedTransactions(forecast_df, relevant_confirmed_df, memo_set, account_set,
  4554       426   47940731.0 112536.9     55.3                                                          date_YYYYMMDD)
  4555       213         81.0      0.4      0.0  
  4556                                                   # Process proposed transactions for priority levels greater than 1
  4557                                                   if priority_level > 1:
  4558       212        168.0      0.8      0.0              forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df = self.processProposedTransactions(
  4559       196     395072.0   2015.7      0.5                  account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, relevant_proposed_df, priority_level
  4560        98         64.0      0.7      0.0              )
  4561                                           
  4562                                                       # Update confirmed, deferred, and skipped DataFrames
  4563                                                       confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4564        98      51672.0    527.3      0.1              deferred_df = pd.concat([deferred_df, new_deferred_df]).reset_index(drop=True)
  4565        98      47463.0    484.3      0.1              skipped_df = pd.concat([skipped_df, new_skipped_df]).reset_index(drop=True)
  4566        98      47419.0    483.9      0.1  
  4567                                                       # Process deferred transactions if any exist
  4568                                                       if not deferred_df.empty:
  4569        98        711.0      7.3      0.0                  relevant_deferred_before_processing = relevant_deferred_df.copy()  # Keep original for comparison
  4570                                           
  4571                                                           forecast_df, new_confirmed_df, new_deferred_df = self.processDeferredTransactions(
  4572                                                               account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df.copy(), priority_level,
  4573                                                               confirmed_df
  4574                                                           )
  4575                                           
  4576                                                           # Update confirmed DataFrame with newly confirmed transactions
  4577                                                           confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4578                                           
  4579                                                           # Adjust deferred DataFrame by removing processed transactions and adding new deferred ones
  4580                                                           not_relevant_deferred_df = deferred_df[
  4581                                                               (deferred_df.Priority > priority_level) | (deferred_df.Date != date_YYYYMMDD)]
  4582                                                           deferred_df = pd.concat([not_relevant_deferred_df, new_deferred_df]).reset_index(drop=True)
  4583                                           
  4584                                                   # Final row counts for logging
  4585                                                   C1, D1, S1 = confirmed_df.shape[0], deferred_df.shape[0], skipped_df.shape[0]
  4586       212       1722.0      8.1      0.0          T1 = C1 + D1 + S1
  4587       212        194.0      0.9      0.0          row_count_string = f' C1: {C1}  D1: {D1}  S1: {S1}  T1: {T1}'
  4588       212        546.0      2.6      0.0  
  4589                                                   # Log account balances
  4590                                                   bal_string = ' '.join([f'${account_row.Balance}' for _, account_row in account_set.getAccounts().iterrows()])
  4591       212    6819146.0  32165.8      7.9  
  4592                                                   self.log_stack_depth -= 1
  4593       212        521.0      2.5      0.0  
  4594                                                   return [forecast_df, confirmed_df, deferred_df, skipped_df]

Total time: 12.005 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculateLoanInterestAccrualsForDay at line 5487

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5487                                               def calculateLoanInterestAccrualsForDay(self, account_set, current_forecast_row_df):
  5488                                                   """
  5489                                                   Calculates and applies interest accruals for loans on the current day.
  5490                                           
  5491                                                   Parameters:
  5492                                                   - account_set: AccountSet object containing account information.
  5493                                                   - current_forecast_row_df: DataFrame containing the forecast row for the current date.
  5494                                           
  5495                                                   Returns:
  5496                                                   - Updated current_forecast_row_df with applied interest accruals.
  5497                                                   """
  5498                                                   # Increment log stack depth for logging purposes
  5499                                                   self.log_stack_depth += 1
  5500       114        194.0      1.7      0.0  
  5501                                                   # print('PRE INTEREST ACCRUAL FORECAST ROW')
  5502                                                   # print(current_forecast_row_df.to_string())
  5503                                           
  5504                                                   # Extract the current date
  5505                                                   current_date = current_forecast_row_df['Date'].iat[0]
  5506       114       8250.0     72.4      0.1  
  5507                                                   # Iterate over each account to calculate interest accruals
  5508                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  5509       912    3689940.0   4046.0     30.7              # Skip accounts that are not interest-bearing or are previous statement balances
  5510                                                       if account_row['Account_Type'] == 'credit prev stmt bal':
  5511       798      24022.0     30.1      0.2                  continue
  5512       114         40.0      0.4      0.0  
  5513                                                       # Get the interest cadence and type
  5514                                                       if account_row.get('Interest_Cadence', '') is not None:
  5515       684       8391.0     12.3      0.1                  interest_cadence = account_row.get('Interest_Cadence', '').lower()
  5516       228       2670.0     11.7      0.0              else:
  5517                                                           continue
  5518                                           
  5519                                                       if account_row.get('Interest_Type', '') is not None:
  5520       228       2414.0     10.6      0.0                  interest_type = account_row.get('Interest_Type', '').lower()
  5521       228       2333.0     10.2      0.0              else:
  5522                                                           continue
  5523                                           
  5524                                                       # # Skip if interest cadence or type is not defined
  5525                                                       # if not interest_cadence or interest_cadence == 'none' or not interest_type:
  5526                                                       #     continue
  5527                                           
  5528                                                       # Calculate the number of days since the billing start date
  5529                                                       billing_start_date = account_row['Billing_Start_Date']
  5530       228       4096.0     18.0      0.0              num_days = (pd.to_datetime(current_date, format='%Y%m%d') - pd.to_datetime(billing_start_date,
  5531       456     162857.0    357.1      1.4                                                                                         format='%Y%m%d')).days
  5532       228        128.0      0.6      0.0  
  5533                                                       # Skip if current date is before billing start date
  5534                                                       if num_days < 0:
  5535       228        164.0      0.7      0.0                  continue
  5536                                           
  5537                                                       # Generate date sequence based on billing start date and interest cadence
  5538                                                       # Assume generate_date_sequence is a function that returns a set of dates
  5539                                                       dseq = generate_date_sequence(start_date_YYYYMMDD=billing_start_date, num_days=num_days,
  5540       456     268443.0    588.7      2.2                                            cadence=interest_cadence)
  5541       228         91.0      0.4      0.0  
  5542                                                       # Include billing start date if current date matches
  5543                                                       if current_date == billing_start_date:
  5544       228        193.0      0.8      0.0                  dseq.append(current_date)
  5545                                           
  5546                                                       # Check if current date is in the interest accrual dates
  5547                                                       if current_date in dseq:
  5548       228       1032.0      4.5      0.0                  apr = account_row['APR']
  5549       228       5910.0     25.9      0.0                  balance = account_row['Balance']
  5550       228       2637.0     11.6      0.0  
  5551                                                           # Calculate interest based on type and cadence
  5552                                                           if interest_type == 'compound':
  5553       228        154.0      0.7      0.0                      if interest_cadence == 'monthly':
  5554                                                                   # Compound interest, monthly accrual
  5555                                                                   interest_accrued = balance * (apr / 12)
  5556                                                                   # Update account balance
  5557                                                                   account_set.accounts[account_index].balance += interest_accrued
  5558                                           
  5559                                                                   # # Move current statement balance to previous statement balance for credit accounts
  5560                                                                   # if account_row['Account_Type'] == 'credit curr stmt bal':
  5561                                                                   #     prev_account_index = account_index - 1
  5562                                                                   #     prev_stmt_balance = account_set.accounts[prev_account_index].balance
  5563                                                                   #     account_set.accounts[account_index].balance += prev_stmt_balance
  5564                                                                   #     account_set.accounts[prev_account_index].balance = 0
  5565                                                               else:
  5566                                                                   # Other compound interest cadences not implemented
  5567                                                                   raise NotImplementedError(
  5568                                                                       f"Compound interest with '{interest_cadence}' cadence is not implemented.")
  5569                                                           elif interest_type == 'simple':
  5570       228        184.0      0.8      0.0                      if interest_cadence == 'daily':
  5571       228        112.0      0.5      0.0                          # Simple interest, daily accrual
  5572                                                                   interest_accrued = balance * (apr / 365.25)
  5573       228        250.0      1.1      0.0  
  5574                                                                   # print('current_date, Name, interest '+str(current_date)+' '+str(account_row.Name)+' '+str(round(interest_accrued,2)))
  5575                                           
  5576                                                                   # Update interest account balance (assuming it's the next account)
  5577                                                                   interest_account_index = account_index + 1
  5578       228        157.0      0.7      0.0                          if interest_account_index < len(account_set.accounts):
  5579       228        417.0      1.8      0.0                              account_set.accounts[interest_account_index].balance += interest_accrued
  5580       228        447.0      2.0      0.0                              # Round small balances to zero
  5581                                                                       if abs(account_set.accounts[interest_account_index].balance) < 0.01:
  5582       228        335.0      1.5      0.0                                  account_set.accounts[interest_account_index].balance = 0.0
  5583       114        137.0      1.2      0.0                      else:
  5584                                                                   # Other simple interest cadences not implemented
  5585                                                                   raise NotImplementedError(
  5586                                                                       f"Simple interest with '{interest_cadence}' cadence is not implemented.")
  5587                                                           else:
  5588                                                               raise ValueError(f"Unknown interest type '{interest_type}' for account '{account_row['Name']}'.")
  5589                                           
  5590                                                       # print('PRE-UPDATE ACCRUAL FORECAST ROW')
  5591                                                       # print(current_forecast_row_df.to_string())
  5592                                           
  5593                                                       # Update the current forecast row with the updated account balances
  5594                                                       for idx, acc_row in account_set.getAccounts().iterrows():
  5595      1824    7369353.0   4040.2     61.4                  account_name = acc_row['Name']
  5596      1596      37160.0     23.3      0.3                  balance = acc_row['Balance']
  5597      1596      17237.0     10.8      0.1                  if account_name in current_forecast_row_df.columns:
  5598      1596       4572.0      2.9      0.0                      current_forecast_row_df.iloc[0,current_forecast_row_df.columns == account_name] = round(balance,2)
  5599      1596     390367.0    244.6      3.3                      #current_forecast_row_df.at[0, account_name] = balance
  5600                                           
  5601                                                       # print('POST-UPDATE ACCRUAL FORECAST ROW')
  5602                                                       # print(current_forecast_row_df.to_string())
  5603                                           
  5604                                                   # Decrement log stack depth
  5605                                                   self.log_stack_depth -= 1
  5606       114        238.0      2.1      0.0  
  5607                                                   # print('POST INTEREST ACCRUAL FORECAST ROW')
  5608                                                   # print(current_forecast_row_df.to_string())
  5609                                           
  5610                                                   # Return the updated forecast row DataFrame
  5611                                                   return current_forecast_row_df

Total time: 15.4804 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeCreditCardMinimumPayments at line 5767

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5767                                               def executeCreditCardMinimumPayments(self, forecast_df, account_set, current_forecast_row_df):
  5768                                                   """
  5769                                                   Executes minimum payments for credit card accounts.
  5770                                           
  5771                                                   Parameters:
  5772                                                   - forecast_df: DataFrame containing forecasted financial data.
  5773                                                   - account_set: The current set of accounts.
  5774                                                   - current_forecast_row_df: The forecast row for the current date.
  5775                                           
  5776                                                   Returns:
  5777                                                   - Updated current_forecast_row_df after executing credit card minimum payments.
  5778                                                   """
  5779                                                   #log_in_color(logger, 'cyan', 'debug', 'ENTER executeMinimumPayments() ', self.log_stack_depth)
  5780                                                   self.log_stack_depth += 1
  5781       114        229.0      2.0      0.0          primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5782       114    7172018.0  62912.4     46.3  
  5783                                                   # Loop through accounts to process credit card minimum payments
  5784                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  5785       912    3619146.0   3968.4     23.4              if account_row.Account_Type != 'credit prev stmt bal':
  5786       798      25861.0     32.4      0.2                  continue
  5787       684        243.0      0.4      0.0  
  5788                                                       # Skip accounts without a billing start date
  5789                                                       billing_start_date = account_row.Billing_Start_Date
  5790       114       2113.0     18.5      0.0              if pd.isnull(billing_start_date) or billing_start_date == 'None':
  5791       114        643.0      5.6      0.0                  continue
  5792                                           
  5793                                                       current_date_str = current_forecast_row_df.Date.iloc[0]
  5794       114      11456.0    100.5      0.1              current_date = datetime.datetime.strptime(current_date_str, '%Y%m%d')
  5795       114       8547.0     75.0      0.1  
  5796                                                       billing_start_datetime = datetime.datetime.strptime(billing_start_date, '%Y%m%d')
  5797       114       4593.0     40.3      0.0              num_days = (current_date - billing_start_datetime).days
  5798       114        244.0      2.1      0.0  
  5799                                                       # Generate billing days
  5800                                                       if num_days >= 0:
  5801       114         57.0      0.5      0.0                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5802       114     101291.0    888.5      0.7              else:
  5803                                                           billing_days = set()
  5804                                           
  5805                                                       if current_date_str == billing_start_date:
  5806       114         93.0      0.8      0.0                  billing_days.add(current_date_str)
  5807                                           
  5808                                                       if current_date_str not in billing_days:
  5809       114         67.0      0.6      0.0                  continue
  5810       111         34.0      0.3      0.0  
  5811                                                       # Calculate advance payments made during the billing cycle
  5812                                                       advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  5813         6     103694.0  17282.3      0.7                  account_row.Name, account_set, forecast_df, current_date_str
  5814         3         87.0     29.0      0.0              )
  5815                                           
  5816                                                       # Determine the earliest billing date within the forecast range
  5817                                                       first_day_of_forecast_str = forecast_df.Date.iloc[0]
  5818         3        176.0     58.7      0.0              first_day_of_forecast = datetime.datetime.strptime(first_day_of_forecast_str, '%Y%m%d')
  5819         3        223.0     74.3      0.0  
  5820                                                       relevant_billing_days = [
  5821         6       1084.0    180.7      0.0                  d for d in billing_days
  5822         3          1.0      0.3      0.0                  if datetime.datetime.strptime(d, '%Y%m%d') > first_day_of_forecast
  5823                                                       ]
  5824                                           
  5825                                                       if not relevant_billing_days:
  5826         3          2.0      0.7      0.0                  continue
  5827                                           
  5828                                                       earliest_billing_date_within_forecast_range = min(relevant_billing_days)
  5829         3          6.0      2.0      0.0              if current_date_str == earliest_billing_date_within_forecast_range:
  5830         3          2.0      0.7      0.0                  # First billing date in forecast range
  5831                                                           current_prev_stmt_balance = forecast_df.iloc[0][account_row.Name]
  5832         3        535.0    178.3      0.0                  prev_prev_stmt_balance = current_prev_stmt_balance
  5833         3          1.0      0.3      0.0                  current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5834         3      95130.0  31710.0      0.6              else:
  5835                                                           # Get previous billing cycle data
  5836                                                           left_check_bound = current_date - datetime.timedelta(days=35)
  5837                                                           forecast_dates = forecast_df['Date'].apply(lambda d: datetime.datetime.strptime(d, '%Y%m%d'))
  5838                                                           check_region = forecast_df[
  5839                                                               (forecast_dates > left_check_bound) & (forecast_dates <= current_date)
  5840                                                               ]
  5841                                           
  5842                                                           previous_min_payment_dates = check_region['Memo Directives'].str.contains('CC MIN PAYMENT')
  5843                                                           if previous_min_payment_dates.any():
  5844                                                               prev_prev_stmt_balance = check_region.loc[previous_min_payment_dates, account_row.Name].iat[0]
  5845                                                           else:
  5846                                                               prev_prev_stmt_balance = 0
  5847                                           
  5848                                                           current_prev_stmt_balance = account_row.Balance
  5849                                                           current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5850                                           
  5851                                                       # Calculate interest and principal to be charged
  5852                                                       interest_rate_monthly = account_row.APR / 12
  5853         3        100.0     33.3      0.0              interest_charged = round(prev_prev_stmt_balance * interest_rate_monthly, 2)
  5854         3         88.0     29.3      0.0              principal_charged = prev_prev_stmt_balance * 0.01
  5855         3          3.0      1.0      0.0              current_due = principal_charged + interest_charged
  5856         3          2.0      0.7      0.0  
  5857                                           
  5858                                                       # blindly copied from gpt
  5859                                                       min_payment = (
  5860         3          1.0      0.3      0.0                  current_due if current_due > 0 and current_due > account_row.Minimum_Payment else
  5861         3         75.0     25.0      0.0                  (
  5862                                                               account_row.Minimum_Payment if (current_prev_stmt_balance + current_curr_stmt_balance) > account_row.Minimum_Payment else (current_prev_stmt_balance + current_curr_stmt_balance)) if current_due > 0 else 0
  5863                                                       )
  5864                                           
  5865                                                       total_payment_due = min_payment - advance_payment_amount
  5866         3          3.0      1.0      0.0              if total_payment_due <= 0:
  5867         3          1.0      0.3      0.0                  payment_toward_prev = 0
  5868                                                           payment_toward_curr = 0
  5869                                                       else:
  5870                                                           if current_prev_stmt_balance >= total_payment_due:
  5871         3          1.0      0.3      0.0                      payment_toward_prev = total_payment_due
  5872         3          0.0      0.0      0.0                      payment_toward_curr = 0
  5873         3          0.0      0.0      0.0                  else:
  5874                                                               payment_toward_prev = current_prev_stmt_balance
  5875                                                               payment_toward_curr = total_payment_due - payment_toward_prev
  5876                                           
  5877                                                       # Update account balances and memo directives
  5878                                                       if interest_charged > 0:
  5879         3          2.0      0.7      0.0                  account_set.accounts[account_index].balance += interest_charged
  5880         3          8.0      2.7      0.0                  interest_md_text = f'; CC INTEREST ({account_row.Name} +${interest_charged:.2f}); '
  5881         3         72.0     24.0      0.0                  if interest_md_text not in current_forecast_row_df['Memo Directives'].iat[0]:
  5882         3        207.0     69.0      0.0                      current_forecast_row_df['Memo Directives'] += interest_md_text
  5883         3       1525.0    508.3      0.0  
  5884                                                       total_payment = payment_toward_prev + payment_toward_curr
  5885         3          8.0      2.7      0.0              if total_payment > 0:
  5886         3          3.0      1.0      0.0                  account_set.executeTransaction(
  5887         6     283496.0  47249.3      1.8                      Account_From=primary_checking_account_name,
  5888         3          1.0      0.3      0.0                      Account_To=account_row.Name.split(':')[0],
  5889         3         87.0     29.0      0.0                      Amount=total_payment
  5890         3          2.0      0.7      0.0                  )
  5891                                           
  5892                                                           memo_parts = []
  5893         3          3.0      1.0      0.0                  if payment_toward_prev > 0:
  5894         3          3.0      1.0      0.0                      memo_parts.append(
  5895         6          4.0      0.7      0.0                          f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Prev Stmt Bal -${payment_toward_prev:.2f}); '
  5896         3        121.0     40.3      0.0                      )
  5897                                                           if payment_toward_curr > 0:
  5898         3          2.0      0.7      0.0                      memo_parts.append(
  5899                                                                   f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Curr Stmt Bal -${payment_toward_curr:.2f}); '
  5900                                                               )
  5901                                                           if total_payment > 0:
  5902         3          3.0      1.0      0.0                      memo_parts.append(
  5903         6          5.0      0.8      0.0                          f'CC MIN PAYMENT ({primary_checking_account_name} -${total_payment:.2f}); '
  5904         3          6.0      2.0      0.0                      )
  5905                                                           current_forecast_row_df['Memo Directives'] += ''.join(memo_parts)
  5906         3       1468.0    489.3      0.0              elif 'CC MIN PAYMENT' in current_forecast_row_df['Memo Directives'] or advance_payment_amount > 0:
  5907                                                               current_forecast_row_df['Memo Directives'] += (
  5908                                                                   f'CC MIN PAYMENT ALREADY MADE ({account_row.Name.split(":")[0]}: Prev Stmt Bal -$0.00); '
  5909                                                                   f'CC MIN PAYMENT ALREADY MADE ({primary_checking_account_name} -$0.00); '
  5910                                                               )
  5911                                                       #else:  there was no min payment, and one is not necessary now
  5912                                           
  5913                                                       # Clean up memo directives
  5914                                                       memo_directives = [
  5915         6         19.0      3.2      0.0                  md.strip() for md in current_forecast_row_df['Memo Directives'].iat[0].split(';') if md.strip()
  5916         3        240.0     80.0      0.0              ]
  5917                                                       current_forecast_row_df['Memo Directives'] = '; '.join(memo_directives)
  5918         3        344.0    114.7      0.0  
  5919                                                   # Update balances in current forecast row
  5920                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  5921       912    3634928.0   3985.7     23.5              current_balance = account_row['Balance']
  5922       798      17873.0     22.4      0.1              account_name = account_row['Name']
  5923       798       8705.0     10.9      0.1              current_forecast_row_df[account_name] = current_balance
  5924       798     164771.0    206.5      1.1  
  5925                                                       # Move current statement balance to previous if it's a billing day
  5926                                                       if account_row.Account_Type == 'credit prev stmt bal':
  5927       798      21787.0     27.3      0.1                  billing_start_date = account_row.Billing_Start_Date
  5928       114       2201.0     19.3      0.0                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5929       114     105131.0    922.2      0.7                  if current_date_str in billing_days:
  5930       114        138.0      1.2      0.0                      curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5931         3      88357.0  29452.3      0.6                      account_set.accounts[account_index].balance += curr_stmt_balance
  5932         3          9.0      3.0      0.0                      account_set.accounts[account_index - 1].balance = 0
  5933         3          4.0      1.3      0.0                      current_forecast_row_df[account_row.Name] = account_set.accounts[account_index].balance
  5934         3        410.0    136.7      0.0                      current_forecast_row_df[account_set.accounts[account_index - 1].name] = 0
  5935         3        278.0     92.7      0.0  
  5936                                                   self.log_stack_depth -= 1
  5937       114        284.0      2.5      0.0          return current_forecast_row_df

Total time: 48.9338 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeLoanMinimumPayments at line 5940

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5940                                               def executeLoanMinimumPayments(self, account_set, current_forecast_row_df):
  5941                                           
  5942                                                   bal_string = ''
  5943       114        120.0      1.1      0.0          for account_index2, account_row2 in account_set.getAccounts().iterrows():
  5944       912    3623231.0   3972.8      7.4              bal_string += '$' + str(account_row2.Balance) + ' '
  5945       798      28194.0     35.3      0.1  
  5946                                                   primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5947       114    7504093.0  65825.4     15.3  
  5948                                                   #logger.debug('self.log_stack_depth += 1')
  5949                                                   #log_in_color(logger,'cyan', 'debug', 'ENTER executeMinimumPayments() ' + bal_string, self.log_stack_depth)
  5950                                                   self.log_stack_depth += 1
  5951       114        296.0      2.6      0.0  
  5952                                                   # the branch logic here assumes the sort order of accounts in account list
  5953                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  5954       912    3709028.0   4066.9      7.6  
  5955                                                       if account_row.Account_Type == 'prev smt bal':
  5956       798      24325.0     30.5      0.0                  continue
  5957                                           
  5958                                                       #not sure why both of these checks are necessary
  5959                                                       if account_row.Billing_Start_Date == 'None':
  5960       798      15043.0     18.9      0.0                  continue
  5961                                           
  5962                                                       if pd.isnull(account_row.Billing_Start_Date):
  5963       798      15601.0     19.6      0.0                  continue
  5964       456        220.0      0.5      0.0  
  5965                                                       # print(BEGIN_GREEN + row.to_string() + RESET_COLOR)
  5966                                                       # print('current_forecast_row_df.Date - row.Billing_Start_Date:')
  5967                                                       # print('current_forecast_row_df.Date:')
  5968                                                       # print(current_forecast_row_df.Date)
  5969                                                       # print('row.Billing_Start_Date:')
  5970                                                       # print(row.Billing_Start_Date)
  5971                                           
  5972                                                       num_days = (datetime.datetime.strptime(current_forecast_row_df.Date.iloc[0],'%Y%m%d') - datetime.datetime.strptime(account_row.Billing_Start_Date,'%Y%m%d')).days
  5973       342      61912.0    181.0      0.1              #billing_days = set(generate_date_sequence(account_row.Billing_Start_Date.strftime('%Y%m%d'), num_days, account_row.Interest_Cadence))
  5974                                                       billing_days = set(generate_date_sequence(account_row.Billing_Start_Date, num_days, 'monthly'))
  5975       342     259628.0    759.1      0.5  
  5976                                                       # if the input date matches the start date, add it to the set (bc range where start = end == null set)
  5977                                                       if current_forecast_row_df.Date.iloc[0] == account_row.Billing_Start_Date:
  5978       342      25469.0     74.5      0.1                  billing_days = set(current_forecast_row_df.Date).union(billing_days)
  5979                                           
  5980                                                       if current_forecast_row_df.Date.iloc[0] in billing_days:
  5981       342      12271.0     35.9      0.0                  # log_in_color(logger,'green', 'debug', 'Processing minimum payments', self.log_stack_depth)
  5982                                                           # log_in_color(logger,'green', 'debug', 'account_row:', self.log_stack_depth)
  5983                                                           # log_in_color(logger,'green', 'debug', account_row.to_string(), self.log_stack_depth)
  5984                                           
  5985                                                           # print(row)
  5986                                                           # if account_row.Account_Type == 'credit prev stmt bal':  # cc min payment
  5987                                                           #
  5988                                                           #     log_in_color(logger, 'cyan', 'debug', 'executeMinimumPayments() ' + bal_string, self.log_stack_depth)
  5989                                                           #
  5990                                                           #     #minimum_payment_amount = max(40, account_row.Balance * 0.033) #this is an estimate
  5991                                                           #     minimum_payment_amount = max(40, account_row.Balance * account_row.APR/12)
  5992                                                           #     #todo it turns out that the way this really works is that Chase uses 1% PLUS the interest accrued to be charged immediately, not added to the principal
  5993                                                           #     #very much not how I designed this but not earth-shatteringly different
  5994                                                           #
  5995                                                           #
  5996                                                           #     payment_toward_prev = round(min(minimum_payment_amount, account_row.Balance),2)
  5997                                                           #     payment_toward_curr = round(min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev),2)
  5998                                                           #
  5999                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  6000                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  6001                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  6002                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  6003                                                           #
  6004                                                           #         if payment_toward_prev > 0:
  6005                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Prev Stmt Bal -$'+str(payment_toward_prev) + '); '
  6006                                                           #         if payment_toward_curr > 0:
  6007                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Curr Stmt Bal -$' + str(payment_toward_curr) + '); '
  6008                                                           #         #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' cc min payment ($' + str(minimum_payment_amount) + ') ; '
  6009                                                           #
  6010                                                           # el
  6011                                                           if account_row.Account_Type == 'principal balance':  # loan min payment
  6012         9        171.0     19.0      0.0  
  6013                                                               minimum_payment_amount = account_set.getAccounts().loc[account_index, :].Minimum_Payment
  6014         6     180148.0  30024.7      0.4  
  6015                                                               #todo I notice that this depends on the order of accounts
  6016                                                               #if an accountset was created by manually adding sub accounts, and this is done in the wrong order
  6017                                                               #there will be unexpected behavior BECAUSE OF this part of the code
  6018                                           
  6019                                                               #new
  6020                                                               current_pbal_balance = account_row.Balance
  6021         6        137.0     22.8      0.0                      current_interest_balance = account_set.getAccounts().loc[account_index + 1, :].Balance
  6022         6     176328.0  29388.0      0.4                      current_debt_balance = current_pbal_balance + current_interest_balance
  6023         6          8.0      1.3      0.0  
  6024                                                               # payment_toward_interest = round(min(minimum_payment_amount, current_interest_balance),2)
  6025                                                               # payment_toward_principal = round(min(current_pbal_balance, minimum_payment_amount - payment_toward_interest),2)
  6026                                           
  6027                                                               payment_toward_interest = min(minimum_payment_amount, current_interest_balance)
  6028         6         15.0      2.5      0.0                      payment_toward_principal = min(current_pbal_balance, minimum_payment_amount - payment_toward_interest)
  6029         6          7.0      1.2      0.0  
  6030                                                               #old
  6031                                                               #current_debt_balance = account_set.getBalances()[account_row.Name.split(':')[0]]
  6032                                           
  6033                                           
  6034                                                               loan_payment_amount = min(current_debt_balance,minimum_payment_amount)
  6035         6          3.0      0.5      0.0  
  6036                                                               if loan_payment_amount > 0:
  6037         6          6.0      1.0      0.0                          account_set.executeTransaction(Account_From=primary_checking_account_name, Account_To=account_row.Name.split(':')[0],
  6038        12     514671.0  42889.2      1.1                                                         # Note that the execute transaction method will split the amount paid between the 2 accounts
  6039                                                                                                  Amount=loan_payment_amount)
  6040         6          3.0      0.5      0.0  
  6041                                                                   if payment_toward_interest > 0:
  6042         6         17.0      2.8      0.0                              #current_forecast_row_df.Memo += ' loan min payment (' + account_row.Name.split(':')[0] + ': Interest -$' + str(round(payment_toward_interest,2)) + '); ' #
  6043                                                                       current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Interest -$' + str(f'{payment_toward_interest:.2f}') + '); '
  6044         3       1513.0    504.3      0.0  
  6045                                                                   if payment_toward_principal > 0:
  6046         6          6.0      1.0      0.0                              #current_forecast_row_df.Memo += ' loan min payment ('+account_row.Name.split(':')[0] +': Principal Balance -$' + str(round(payment_toward_principal,2)) + '); '
  6047                                                                       current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Principal Balance -$' + str(f'{payment_toward_principal:.2f}') + '); '
  6048         6       2699.0    449.8      0.0  
  6049                                                                   #add checking note
  6050                                                                   if ( payment_toward_interest + payment_toward_principal ) > 0 :
  6051         6         14.0      2.3      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT ('+primary_checking_account_name+' -$' + str(f'{( payment_toward_interest + payment_toward_principal ):.2f}') + '); '
  6052         6       1875.0    312.5      0.0  
  6053                                                                   #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' loan min payment ($' + str(minimum_payment_amount) + '); '
  6054                                           
  6055                                           
  6056                                                           # if account_row.Account_Type == 'credit prev stmt bal' or account_row.Account_Type == 'interest':
  6057                                                           #
  6058                                                           #     payment_toward_prev = min(minimum_payment_amount, account_row.Balance)
  6059                                                           #     payment_toward_curr = min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev)
  6060                                                           #     surplus_payment = minimum_payment_amount - (payment_toward_prev + payment_toward_curr)
  6061                                                           #
  6062                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  6063                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  6064                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  6065                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  6066                                           
  6067                                                   # print('current_forecast_row_df pre-update')
  6068                                                   # print(current_forecast_row_df.to_string())
  6069                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  6070       912    3888902.0   4264.1      7.9              relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  6071       798   24935259.0  31247.2     51.0              col_sel_vec = (current_forecast_row_df.columns == account_row.Name)
  6072       798     104869.0    131.4      0.2              #print('Setting '+account_row.Name+' to '+str(relevant_balance))
  6073                                                       current_forecast_row_df.iloc[0, col_sel_vec] = round(relevant_balance,2)
  6074       798     192163.0    240.8      0.4  
  6075                                                   # print('current_forecast_row_df post-update')
  6076                                                   # print(current_forecast_row_df.to_string())
  6077                                           
  6078                                                   bal_string = ''
  6079       114         81.0      0.7      0.0          for account_index2, account_row2 in account_set.getAccounts().iterrows():
  6080       912    3629581.0   3979.8      7.4              bal_string += '$' + str(account_row2.Balance) + ' '
  6081       798      25578.0     32.1      0.1  
  6082                                                   # log_in_color(logger,'green', 'debug', 'return this row:', self.log_stack_depth)
  6083                                                   # log_in_color(logger,'green', 'debug', current_forecast_row_df.to_string(), self.log_stack_depth)
  6084                                                   self.log_stack_depth -= 1
  6085       114        229.0      2.0      0.0          #log_in_color(logger,'cyan', 'debug', 'EXIT  executeMinimumPayments() ' + bal_string, self.log_stack_depth)
  6086                                                   #logger.debug('self.log_stack_depth -= 1')
  6087                                           
  6088                                                   return current_forecast_row_df

Total time: 0.03194 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getMinimumFutureAvailableBalances at line 6091

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6091                                               def getMinimumFutureAvailableBalances(self, account_set, forecast_df, date_YYYYMMDD):
  6092                                                   """
  6093                                                   Calculates the minimum future available balances for each account starting from the specified date.
  6094                                           
  6095                                                   Parameters:
  6096                                                   - account_set: AccountSet object containing account information.
  6097                                                   - forecast_df: DataFrame containing the forecasted financial data.
  6098                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  6099                                           
  6100                                                   Returns:
  6101                                                   - future_available_balances: Dictionary mapping account names to their minimum future available balances.
  6102                                                   """
  6103                                                   import datetime
  6104         1          2.0      2.0      0.0          import pandas as pd
  6105         1          0.0      0.0      0.0  
  6106                                                   # Increment log stack depth (if used for logging)
  6107                                                   self.log_stack_depth += 1
  6108         1          1.0      1.0      0.0  
  6109                                                   # Convert date string to datetime object for comparison
  6110                                                   current_date = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d')
  6111         1         64.0     64.0      0.2  
  6112                                                   # Ensure 'Date' column is in datetime format
  6113                                                   #forecast_df['Date_dt'] = pd.to_datetime(forecast_df['Date'], format='%Y%m%d')
  6114                                           
  6115                                                   # Filter forecast_df for current and future dates
  6116                                                   current_and_future_forecast_df = forecast_df[ [ datetime.datetime.strptime(d,'%Y%m%d') >= current_date for d in forecast_df['Date'] ] ]
  6117         1       1604.0   1604.0      5.0  
  6118                                                   # Get the account information
  6119                                                   accounts_df = account_set.getAccounts()
  6120         1      28749.0  28749.0     90.0          future_available_balances = {}
  6121         1          0.0      0.0      0.0  
  6122                                                   for account_index, account_row in accounts_df.iterrows():
  6123         8       1019.0    127.4      3.2              full_account_name = account_row['Name']
  6124         7        147.0     21.0      0.5              account_name = full_account_name.split(':')[0]
  6125         7          9.0      1.3      0.0              account_type = account_row['Account_Type'].lower()
  6126         7         72.0     10.3      0.2  
  6127                                                       # Check if account exists in forecast_df columns
  6128                                                       if account_name not in forecast_df.columns:
  6129         7         17.0      2.4      0.1                  continue
  6130         6          2.0      0.3      0.0  
  6131                                                       if account_type == 'checking':
  6132         1          0.0      0.0      0.0                  # Calculate minimum future balance minus minimum required balance
  6133                                                           min_future_balance = current_and_future_forecast_df[account_name].min()
  6134         1        236.0    236.0      0.7                  min_available_balance = min_future_balance - account_row['Min_Balance']
  6135         1         15.0     15.0      0.0                  future_available_balances[account_name] = min_available_balance
  6136         1          1.0      1.0      0.0  
  6137                                                       elif account_type == 'credit prev stmt bal':
  6138                                                           # Get indices for previous and current statement balance accounts
  6139                                                           prev_index = account_index
  6140                                                           curr_index = account_index - 1
  6141                                           
  6142                                                           # Ensure the current index is valid
  6143                                                           if curr_index < 0:
  6144                                                               continue
  6145                                           
  6146                                                           prev_stmt_account_name = accounts_df.iloc[prev_index]['Name']
  6147                                                           curr_stmt_account_name = accounts_df.iloc[curr_index]['Name']
  6148                                           
  6149                                                           # Check if both accounts exist in forecast_df columns
  6150                                                           if prev_stmt_account_name not in forecast_df.columns or curr_stmt_account_name not in forecast_df.columns:
  6151                                                               continue
  6152                                           
  6153                                                           # Sum the balances of previous and current statement balances
  6154                                                           total_credit_balance = current_and_future_forecast_df[prev_stmt_account_name] + \
  6155                                                                                  current_and_future_forecast_df[curr_stmt_account_name]
  6156                                           
  6157                                                           # Calculate the minimum total credit balance
  6158                                                           min_total_credit_balance = total_credit_balance.min()
  6159                                           
  6160                                                           # Calculate available credit
  6161                                                           max_balance = account_row['Max_Balance']
  6162                                                           min_available_credit = max_balance - min_total_credit_balance - account_row['Min_Balance']
  6163                                                           future_available_balances[account_name] = min_available_credit
  6164                                           
  6165                                                   # Decrement log stack depth
  6166                                                   self.log_stack_depth -= 1
  6167         1          2.0      2.0      0.0  
  6168                                                   return future_available_balances

Total time: 286.733 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: sync_account_set_w_forecast_day at line 6171

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6171                                               def sync_account_set_w_forecast_day(self, account_set, forecast_df, date_YYYYMMDD):
  6172                                                   # print('ENTER sync_account_set_w_forecast_day('+str(date_YYYYMMDD)+')')
  6173                                                   # print(forecast_df.to_string())
  6174                                                   # print('Pre-Sync account balances:')
  6175                                                   # print(account_set.getAccounts().to_string())
  6176                                                   bal_string = ' '
  6177       915        716.0      0.8      0.0          for index, row in account_set.getAccounts().iterrows():
  6178      7320   29298691.0   4002.6     10.2              bal_string += '$'+str(f'{row.Balance:.2f}') + ' '
  6179      6405     211464.0     33.0      0.1          #log_in_color(logger,'cyan','debug','ENTER sync_account_set_w_forecast_day(date_YYYYMMDD='+str(date_YYYYMMDD)+')'+bal_string,self.log_stack_depth)
  6180                                                   # log_in_color(logger,'green','debug','Initial account_set:',self.log_stack_depth)
  6181                                                   # log_in_color(logger,'green', 'debug', account_set.getAccounts().to_string(), self.log_stack_depth)
  6182                                           
  6183                                                   relevant_forecast_day = forecast_df[forecast_df.Date == date_YYYYMMDD]
  6184       915     481994.0    526.8      0.2  
  6185                                                   # log_in_color(logger,'green', 'debug', 'relevant forecast row:', self.log_stack_depth)
  6186                                                   # log_in_color(logger,'green', 'debug', relevant_forecast_day.to_string(), self.log_stack_depth)
  6187                                           
  6188                                                   for account_index, account_row in account_set.getAccounts().iterrows():
  6189      7320   29106753.0   3976.3     10.2              if (account_index + 1) == account_set.getAccounts().shape[1]:
  6190      6405  196576671.0  30691.1     68.6                  break
  6191                                           
  6192                                                       # print('forecast_df.Date:')
  6193                                                       # print(forecast_df.Date)
  6194                                                       # print('d:')
  6195                                                       # print(d)
  6196                                           
  6197                                                       row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  6198      6405    1597438.0    249.4      0.6              # print('row_sel_vec:')
  6199                                                       # print(row_sel_vec)
  6200                                           
  6201                                                       try:
  6202      6405       4217.0      0.7      0.0                  assert sum(row_sel_vec) > 0
  6203      6405      88640.0     13.8      0.0              except Exception as e:
  6204                                                           error_msg = "error in sync_account_set_w_forecast_day\n"
  6205                                                           error_msg += "date_YYYYMMDD: "+date_YYYYMMDD+"\n"
  6206                                                           error_msg += "min date of forecast:"+min(forecast_df.Date)+"\n"
  6207                                                           error_msg += "max date of forecast:"+max(forecast_df.Date)+"\n"
  6208                                                           raise AssertionError(error_msg)
  6209                                           
  6210                                                       relevant_balance = relevant_forecast_day.iat[0, account_index + 1]
  6211      6405     333387.0     52.1      0.1              # log_in_color(logger,'green','debug','CASE 1 Setting '+account_row.Name+' to '+str(relevant_balance),self.log_stack_depth)
  6212                                                       account_set.accounts[account_index].balance = relevant_balance
  6213      6405      13194.0      2.1      0.0  
  6214                                                   bal_string = ' '
  6215       915        707.0      0.8      0.0          for index, row in account_set.getAccounts().iterrows():
  6216      7320   28800728.0   3934.5     10.0              bal_string += '$' + str(row.Balance) + ' '
  6217      6405     218190.0     34.1      0.1          #log_in_color(logger,'cyan','debug','EXIT sync_account_set_w_forecast_day(date_YYYYMMDD='+str(date_YYYYMMDD)+')'+bal_string,self.log_stack_depth)
  6218                                                   # print('Post-Update account balances:')
  6219                                                   # print(account_set.getAccounts().to_string())
  6220                                                   # print('EXIT sync_account_set_w_forecast_day(' + str(date_YYYYMMDD) + ')')
  6221                                                   return account_set

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_stmt_balance at line 7355

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7355                                               def _propagate_credit_curr_stmt_balance(self, relevant_account_info_df,
  7356                                                                                       account_deltas_list,
  7357                                                                                       future_rows_only_df,
  7358                                                                                       forecast_df):
  7359                                                   """
  7360                                                   Propagates changes to the credit card current statement balance into the future forecast.
  7361                                           
  7362                                                   Parameters:
  7363                                                   - relevant_account_info_df: DataFrame containing account information.
  7364                                                   - account_deltas_list: List of deltas for each account (excluding 'Date' column).
  7365                                                   - future_rows_only_df: DataFrame containing future forecast rows.
  7366                                                   - forecast_df: The original forecast DataFrame.
  7367                                           
  7368                                                   Returns:
  7369                                                   - Updated future_rows_only_df DataFrame.
  7370                                                   """
  7371                                                   # Extract the account name for the current statement balance
  7372                                                   curr_stmt_bal_account_series = relevant_account_info_df[
  7373                                                       relevant_account_info_df['Account_Type'] == 'credit curr stmt bal']['Name']
  7374                                                   if curr_stmt_bal_account_series.empty:
  7375                                                       # Handle the case where the account type is not found
  7376                                                       raise ValueError("Account type 'credit curr stmt bal' not found in relevant_account_info_df")
  7377                                                   curr_stmt_bal_account_name = curr_stmt_bal_account_series.iat[0]
  7378                                           
  7379                                                   # Create a Series mapping account names to deltas
  7380                                                   account_names = forecast_df.columns[1:]  # Exclude 'Date' column
  7381                                                   account_deltas_series = pd.Series(account_deltas_list, index=account_names)
  7382                                           
  7383                                                   # Get the delta for the current statement balance account
  7384                                                   try:
  7385                                                       curr_stmt_delta = account_deltas_series[curr_stmt_bal_account_name]
  7386                                                   except KeyError:
  7387                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in account_deltas_list")
  7388                                           
  7389                                                   # Update the future forecast DataFrame
  7390                                                   if curr_stmt_bal_account_name in future_rows_only_df.columns:
  7391                                                       future_rows_only_df[curr_stmt_bal_account_name] += curr_stmt_delta
  7392                                                   else:
  7393                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in future_rows_only_df columns")
  7394                                           
  7395                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_only at line 7399

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7399                                               def _propagate_credit_curr_only(self, relevant_account_info_df,
  7400                                                                                       account_deltas_list,
  7401                                                                                       future_rows_only_df,
  7402                                                                                       forecast_df,
  7403                                                                                       account_set_before_p2_plus_txn,
  7404                                                                                       billing_dates_dict,
  7405                                                                                       date_string_YYYYMMDD,
  7406                                                                                       post_txn_row_df):
  7407                                                   """
  7408                                                   Propagates credit card payments involving only the current statement balance into the future forecast.
  7409                                           
  7410                                                   Parameters:
  7411                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7412                                                   - account_deltas_list: List of account balance changes (deltas).
  7413                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7414                                                   - forecast_df: The original forecast DataFrame.
  7415                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7416                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7417                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7418                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7419                                           
  7420                                                   Returns:
  7421                                                   - Updated future_rows_only_df DataFrame.
  7422                                                   """
  7423                                           
  7424                                                   # Extract relevant account names
  7425                                                   checking_account_name = relevant_account_info_df[
  7426                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7427                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  7428                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  7429                                                   # Construct the previous statement balance account name
  7430                                                   prev_stmt_bal_account_name = curr_stmt_bal_account_name.replace('Curr Stmt Bal', 'Prev Stmt Bal')
  7431                                           
  7432                                                   # Get billing dates and next billing date
  7433                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7434                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7435                                                   if future_billing_dates:
  7436                                                       next_billing_date = str(min(future_billing_dates))
  7437                                                   else:
  7438                                                       next_billing_date = None
  7439                                           
  7440                                                   # Get account indices in forecast_df
  7441                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7442                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7443                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  7444                                           
  7445                                                   # Get account deltas
  7446                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  7447                                                   checking_delta = curr_stmt_delta
  7448                                                   previous_stmt_delta = 0.0
  7449                                           
  7450                                                   # Iterate over future forecast rows
  7451                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7452                                                       date_iat = f_row['Date']
  7453                                                       md_to_keep = []
  7454                                           
  7455                                                       if date_iat == next_billing_date:
  7456                                                           # At the next billing date, process memo directives
  7457                                           
  7458                                                           # Initialize memo variables
  7459                                                           og_curr_memo = ''
  7460                                                           og_check_memo = ''
  7461                                                           og_curr_amount = 0.0
  7462                                                           og_check_amount = 0.0
  7463                                           
  7464                                                           # Parse memo directives
  7465                                                           for md in f_row['Memo Directives'].split(';'):
  7466                                                               md = md.strip()
  7467                                                               if not md:
  7468                                                                   continue
  7469                                           
  7470                                                               if f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  7471                                                                   og_curr_memo = md
  7472                                                                   og_curr_amount = self._parse_memo_amount(md)
  7473                                                                   curr_stmt_delta += og_curr_amount
  7474                                                                   checking_delta += og_curr_amount
  7475                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7476                                                                   og_check_memo = md
  7477                                                                   og_check_amount = self._parse_memo_amount(md)
  7478                                                               else:
  7479                                                                   md_to_keep.append(md)
  7480                                           
  7481                                                           # Move curr_stmt_delta to previous_stmt_delta as the current balance moves to previous
  7482                                                           previous_stmt_delta += curr_stmt_delta
  7483                                                           curr_stmt_delta = 0.0
  7484                                           
  7485                                                           # Update memo directives
  7486                                                           new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  7487                                                           md_to_keep.append(new_curr_memo)
  7488                                           
  7489                                                           if og_check_memo:
  7490                                                               # Adjust the checking memo amount
  7491                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - og_curr_amount)
  7492                                                               md_to_keep.append(new_check_memo)
  7493                                           
  7494                                                       else:
  7495                                                           # No adjustments needed on other dates
  7496                                                           pass
  7497                                           
  7498                                                       # Update balances
  7499                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7500                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  7501                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7502                                           
  7503                                                       # Clean and update memo directives
  7504                                                       md_to_keep = [md for md in md_to_keep if md]
  7505                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7506                                           
  7507                                                       # Reset deltas for the next iteration
  7508                                                       checking_delta = 0.0
  7509                                                       curr_stmt_delta = 0.0
  7510                                                       previous_stmt_delta = 0.0
  7511                                           
  7512                                                   return future_rows_only_df

Total time: 0.035677 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_only at line 7515

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7515                                               def _propagate_credit_payment_prev_only(self, relevant_account_info_df,
  7516                                                                                       account_deltas_list,
  7517                                                                                       future_rows_only_df,
  7518                                                                                       forecast_df,
  7519                                                                                       account_set_before_p2_plus_txn,
  7520                                                                                       billing_dates_dict,
  7521                                                                                       date_string_YYYYMMDD,
  7522                                                                                       post_txn_row_df):
  7523                                                   """
  7524                                                   Propagates credit card payments involving only the previous statement balance into the future forecast.
  7525                                           
  7526                                                   Parameters:
  7527                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7528                                                   - account_deltas_list: List of account balance changes (deltas).
  7529                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7530                                                   - forecast_df: The original forecast DataFrame.
  7531                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7532                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7533                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7534                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7535                                           
  7536                                                   Returns:
  7537                                                   - Updated future_rows_only_df DataFrame.
  7538                                                   """
  7539                                           
  7540                                                   # Extract relevant account names
  7541                                                   checking_account_name = relevant_account_info_df[
  7542         3        548.0    182.7      1.5              relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7543         2        233.0    116.5      0.7          prev_stmt_bal_account_name = relevant_account_info_df[
  7544         3        318.0    106.0      0.9              relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  7545         2        207.0    103.5      0.6  
  7546                                                   # Get billing dates and next billing date
  7547                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7548         1          0.0      0.0      0.0          future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7549         1         15.0     15.0      0.0          if future_billing_dates:
  7550         1          0.0      0.0      0.0              next_billing_date = str(min(future_billing_dates))
  7551         1          2.0      2.0      0.0          else:
  7552                                                       next_billing_date = None
  7553                                           
  7554                                                   # Get account indices in forecast_df
  7555                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7556         1          6.0      6.0      0.0          prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7557         1          3.0      3.0      0.0  
  7558                                                   # Get account deltas
  7559                                                   previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  7560         1          1.0      1.0      0.0          checking_delta = previous_stmt_delta
  7561         1          0.0      0.0      0.0  
  7562                                                   # Initialize previous previous statement balance
  7563                                                   previous_prev_stmt_bal = 0.0
  7564         1          0.0      0.0      0.0  
  7565                                                   # Iterate over future forecast rows
  7566                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7567        16       1167.0     72.9      3.3              date_iat = f_row['Date']
  7568        15        220.0     14.7      0.6              md_to_keep = []
  7569        15          4.0      0.3      0.0  
  7570                                                       if date_iat == next_billing_date:
  7571        15          8.0      0.5      0.0                  # Handle next billing date (payment due date)
  7572                                           
  7573                                                           # Initialize memo variables
  7574                                                           og_check_memo = ''
  7575         1          0.0      0.0      0.0                  og_prev_memo = ''
  7576         1          1.0      1.0      0.0                  og_min_payment_amount = 0.0
  7577         1          0.0      0.0      0.0  
  7578                                                           # Parse memo directives
  7579                                                           for md in f_row['Memo Directives'].split(';'):
  7580         4         11.0      2.8      0.0                      md = md.strip()
  7581         3          2.0      0.7      0.0                      if not md:
  7582         3          1.0      0.3      0.0                          continue
  7583                                           
  7584                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7585         3          3.0      1.0      0.0                          og_prev_memo = md
  7586         1          1.0      1.0      0.0                      elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7587         2          2.0      1.0      0.0                          og_check_memo = md
  7588         1          1.0      1.0      0.0                      else:
  7589                                                                   md_to_keep.append(md)
  7590         1          1.0      1.0      0.0  
  7591                                                           # Get advance payment amount
  7592                                                           advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  7593         2      31144.0  15572.0     87.3                      prev_stmt_bal_account_name,
  7594         1          0.0      0.0      0.0                      account_set_before_p2_plus_txn,
  7595         1          0.0      0.0      0.0                      forecast_df,
  7596         1          1.0      1.0      0.0                      date_iat
  7597         1          0.0      0.0      0.0                  )
  7598                                           
  7599                                                           # Get minimum payment amount
  7600                                                           og_min_payment_amount = self._parse_memo_amount(og_check_memo)
  7601         1        410.0    410.0      1.1  
  7602                                                           # Adjust deltas
  7603                                                           payment_to_apply = min(og_min_payment_amount, advance_payment_amount)
  7604         1          1.0      1.0      0.0                  previous_stmt_delta += payment_to_apply
  7605         1          0.0      0.0      0.0                  checking_delta += payment_to_apply
  7606         1          0.0      0.0      0.0  
  7607                                                           # Update previous_prev_stmt_bal
  7608                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7609         1         27.0     27.0      0.1  
  7610                                                           # Adjust memo directives
  7611                                                           if advance_payment_amount >= og_min_payment_amount:
  7612         1          1.0      1.0      0.0                      new_check_memo = self._update_memo_amount(og_check_memo, 0.00)
  7613                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  7614                                                           else:
  7615                                                               remaining_payment = og_min_payment_amount - advance_payment_amount
  7616         1          1.0      1.0      0.0                      new_check_memo = self._update_memo_amount(og_check_memo, remaining_payment)
  7617         1        100.0    100.0      0.3                      new_prev_memo = self._update_memo_amount(og_prev_memo, remaining_payment)
  7618         1         18.0     18.0      0.1  
  7619                                                           md_to_keep.extend([new_check_memo, new_prev_memo])
  7620         1          1.0      1.0      0.0  
  7621                                                       elif date_iat in cc_billing_dates and previous_prev_stmt_bal != 0:
  7622        14         11.0      0.8      0.0                  # Handle other billing dates after payment has been made
  7623                                           
  7624                                                           # Initialize memo variables
  7625                                                           og_min_payment_amount = 0.0
  7626                                           
  7627                                                           # Parse memo directives
  7628                                                           for md in f_row['Memo Directives'].split(';'):
  7629                                                               md = md.strip()
  7630                                                               if not md:
  7631                                                                   continue
  7632                                           
  7633                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7634                                                                   og_min_payment_amount = self._parse_memo_amount(md)
  7635                                           
  7636                                                                   # Calculate interest and current due
  7637                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7638                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7639                                                                       ]
  7640                                                                   apr = account_row['APR'].iat[0]
  7641                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7642                                                                   principal_due = previous_prev_stmt_bal * 0.01
  7643                                                                   current_due = principal_due + interest_to_be_charged
  7644                                           
  7645                                                                   new_min_payment_amount = round(current_due, 2)
  7646                                           
  7647                                                                   # Adjust deltas
  7648                                                                   previous_stmt_delta += new_min_payment_amount
  7649                                                                   checking_delta += new_min_payment_amount
  7650                                           
  7651                                                                   # Update memo directive
  7652                                                                   new_md = self._update_memo_amount(md, new_min_payment_amount)
  7653                                                                   md_to_keep.append(new_md)
  7654                                           
  7655                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  7656                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7657                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7658                                                                       ]
  7659                                                                   apr = account_row['APR'].iat[0]
  7660                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7661                                           
  7662                                                                   og_interest_amount = self._parse_memo_amount(md)
  7663                                                                   previous_stmt_delta += interest_to_be_charged
  7664                                           
  7665                                                                   # Update memo directive
  7666                                                                   new_md = self._update_memo_amount(md, interest_to_be_charged)
  7667                                                                   md_to_keep.append(new_md)
  7668                                           
  7669                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7670                                                                   og_check_amount = self._parse_memo_amount(md)
  7671                                           
  7672                                                                   # Calculate interest and current due
  7673                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7674                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7675                                                                       ]
  7676                                                                   apr = account_row['APR'].iat[0]
  7677                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7678                                                                   principal_due = previous_prev_stmt_bal * 0.01
  7679                                                                   current_due = principal_due + interest_to_be_charged
  7680                                           
  7681                                                                   new_min_payment_amount = round(current_due, 2)
  7682                                           
  7683                                                                   # Update memo directive
  7684                                                                   new_md = self._update_memo_amount(md, new_min_payment_amount)
  7685                                                                   md_to_keep.append(new_md)
  7686                                           
  7687                                                               else:
  7688                                                                   md_to_keep.append(md)
  7689                                           
  7690                                                           # Update previous_prev_stmt_bal
  7691                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7692                                           
  7693                                                       else:
  7694                                                           # No adjustments needed
  7695                                                           pass
  7696                                           
  7697                                                       # Update balances
  7698                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7699        15        542.0     36.1      1.5              future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7700        15        390.0     26.0      1.1  
  7701                                                       # Clean and update memo directives
  7702                                                       md_to_keep = [md for md in md_to_keep if md]
  7703        15         17.0      1.1      0.0              future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7704        15        258.0     17.2      0.7  
  7705                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_interest_only at line 7708

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7708                                               def _propagate_loan_payment_interest_only(self, relevant_account_info_df,
  7709                                                                                         account_deltas_list,
  7710                                                                                         future_rows_only_df,
  7711                                                                                         forecast_df,
  7712                                                                                         account_set_before_p2_plus_txn,
  7713                                                                                         billing_dates_dict,
  7714                                                                                         date_string_YYYYMMDD,
  7715                                                                                         post_txn_row_df):
  7716                                                   """
  7717                                                   Propagates loan payments involving only the interest into the future forecast.
  7718                                           
  7719                                                   Parameters:
  7720                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7721                                                   - account_deltas_list: List of account balance changes (deltas).
  7722                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7723                                                   - forecast_df: The original forecast DataFrame.
  7724                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7725                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7726                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7727                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7728                                           
  7729                                                   Returns:
  7730                                                   - Updated future_rows_only_df DataFrame.
  7731                                                   """
  7732                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_interest_only', self.log_stack_depth)
  7733                                                   self.log_stack_depth += 1
  7734                                                   # log_in_color(logger, 'cyan', 'debug', 'BEFORE future_rows_only_df', self.log_stack_depth)
  7735                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7736                                           
  7737                                                   # Extract relevant account names
  7738                                                   checking_account_name = relevant_account_info_df[
  7739                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7740                                                   interest_account_name = relevant_account_info_df[
  7741                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  7742                                                   # Construct the principal balance account name based on the interest account name
  7743                                                   pbal_account_name = interest_account_name.split(':')[0] + ': Principal Balance'
  7744                                           
  7745                                                   # Get the APR for the principal balance account
  7746                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7747                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7748                                                   apr = pbal_row_df['APR'].iat[0]
  7749                                           
  7750                                                   # Get billing dates and next billing date
  7751                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7752                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7753                                                   if future_billing_dates:
  7754                                                       next_billing_date = str(min(future_billing_dates))
  7755                                                   else:
  7756                                                       next_billing_date = None
  7757                                           
  7758                                                   # Get account indices in forecast_df
  7759                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7760                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7761                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7762                                           
  7763                                                   # Get account deltas
  7764                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  7765                                                   checking_delta = interest_delta  # Since only interest is involved
  7766                                           
  7767                                                   # Iterate over future forecast rows
  7768                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7769                                                       date_iat = f_row['Date']
  7770                                                       md_to_keep = []
  7771                                           
  7772                                                       if date_iat == next_billing_date:
  7773                                                           # Handle next billing date (payment due date)
  7774                                           
  7775                                                           # Initialize amounts
  7776                                                           interest_amount = 0.0
  7777                                           
  7778                                                           # Parse memo directives
  7779                                                           for md in f_row['Memo Directives'].split(';'):
  7780                                                               md = md.strip()
  7781                                                               if not md:
  7782                                                                   continue
  7783                                           
  7784                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7785                                                                   interest_amount = self._parse_memo_amount(md)
  7786                                                                   interest_delta += interest_amount
  7787                                                                   checking_delta += interest_amount
  7788                                                               else:
  7789                                                                   md_to_keep.append(md)
  7790                                           
  7791                                                           # Remove the checking memo directive
  7792                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${interest_amount:.2f})'
  7793                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7794                                           
  7795                                                       elif date_iat in loan_billing_dates:
  7796                                                           # Handle other billing dates
  7797                                           
  7798                                                           # Initialize variables
  7799                                                           interest_paid_amount = 0.0
  7800                                                           og_interest_md = ''
  7801                                           
  7802                                                           # Parse memo directives
  7803                                                           for md in f_row['Memo Directives'].split(';'):
  7804                                                               md = md.strip()
  7805                                                               if not md:
  7806                                                                   continue
  7807                                           
  7808                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7809                                                                   interest_paid_amount = self._parse_memo_amount(md)
  7810                                                                   og_interest_md = md
  7811                                                               else:
  7812                                                                   md_to_keep.append(md)
  7813                                           
  7814                                                           # Get interest balance at the time of charge
  7815                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  7816                                           
  7817                                                           # Adjust interest memo
  7818                                                           if interest_balance <= interest_paid_amount:
  7819                                                               new_interest_amount = interest_balance
  7820                                                               og_interest_surplus = interest_paid_amount - interest_balance
  7821                                                               new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  7822                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7823                                                           else:
  7824                                                               new_interest_amount = interest_paid_amount
  7825                                                               og_interest_surplus = 0.0
  7826                                                               new_interest_md = og_interest_md
  7827                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7828                                           
  7829                                                           # Update memo directives
  7830                                                           md_to_keep.extend([new_interest_md, new_checking_interest_md])
  7831                                           
  7832                                                           # Adjust deltas
  7833                                                           checking_delta += og_interest_surplus
  7834                                                           interest_delta += og_interest_surplus
  7835                                           
  7836                                                       else:
  7837                                                           # No adjustments needed for other dates
  7838                                                           pass
  7839                                           
  7840                                                       # Apply daily interest accrual
  7841                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  7842                                                           if f_i == 0:
  7843                                                               # Set interest to the value after the transaction
  7844                                           
  7845                                                               #this is the OG line, but I think this keeps the OG index so this fails
  7846                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  7847                                                               #instead of reindexing (bc expensive) lets try this:
  7848                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  7849                                                           else:
  7850                                                               # Set interest equal to the previous day's interest
  7851                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  7852                                                                   f_i - 1, interest_account_name]
  7853                                           
  7854                                                           # Calculate interest accrued on this day
  7855                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7856                                                           interest_accrued = pbal_balance * (apr / 365.25)
  7857                                           
  7858                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  7859                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  7860                                           
  7861                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  7862                                           
  7863                                                       # Update balances
  7864                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7865                                           
  7866                                                       # Clean and update memo directives
  7867                                                       md_to_keep = [md for md in md_to_keep if md]
  7868                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7869                                           
  7870                                                       log_in_color(logger, 'cyan', 'debug', 'f_i:'+str(f_i), self.log_stack_depth)
  7871                                           
  7872                                                   # log_in_color(logger, 'cyan', 'debug', 'AFTER future_rows_only_df', self.log_stack_depth)
  7873                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7874                                                   self.log_stack_depth -= 1
  7875                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_interest_only', self.log_stack_depth)
  7876                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_only at line 7879

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7879                                               def _propagate_loan_payment_pbal_only(self, relevant_account_info_df,
  7880                                                                                     account_deltas_list,
  7881                                                                                     future_rows_only_df,
  7882                                                                                     forecast_df,
  7883                                                                                     account_set_before_p2_plus_txn,
  7884                                                                                     billing_dates_dict,
  7885                                                                                     date_string_YYYYMMDD,
  7886                                                                                     post_txn_row_df):
  7887                                                   """
  7888                                                   Propagates loan payments involving only the principal balance into the future forecast.
  7889                                           
  7890                                                   Parameters:
  7891                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7892                                                   - account_deltas_list: List of account balance changes (deltas).
  7893                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7894                                                   - forecast_df: The original forecast DataFrame.
  7895                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7896                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7897                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7898                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7899                                           
  7900                                                   Returns:
  7901                                                   - Updated future_rows_only_df DataFrame.
  7902                                                   """
  7903                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_only', self.log_stack_depth)
  7904                                                   self.log_stack_depth += 1
  7905                                           
  7906                                                   # Extract relevant account names
  7907                                                   checking_account_name = relevant_account_info_df[
  7908                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7909                                                   pbal_account_name = relevant_account_info_df[
  7910                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  7911                                                   # Construct the interest account name based on the principal balance account name
  7912                                                   interest_account_name = pbal_account_name.split(':')[0] + ': Interest'
  7913                                           
  7914                                                   # Get the APR for the principal balance account
  7915                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7916                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7917                                                   apr = pbal_row_df['APR'].iat[0]
  7918                                           
  7919                                                   # Get billing dates and next billing date
  7920                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7921                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7922                                                   if future_billing_dates:
  7923                                                       next_billing_date = str(min(future_billing_dates))
  7924                                                   else:
  7925                                                       next_billing_date = None
  7926                                           
  7927                                                   # Get account indices in forecast_df
  7928                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7929                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7930                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7931                                           
  7932                                                   # Get account deltas
  7933                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  7934                                                   checking_delta = pbal_delta  # Since only principal balance is involved
  7935                                           
  7936                                                   # Iterate over future forecast rows
  7937                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7938                                                       date_iat = f_row['Date']
  7939                                                       md_to_keep = []
  7940                                           
  7941                                                       if date_iat == next_billing_date:
  7942                                                           # Handle next billing date (payment due date)
  7943                                           
  7944                                                           # Initialize amounts
  7945                                                           pbal_amount = 0.0
  7946                                           
  7947                                                           # Parse memo directives
  7948                                                           for md in f_row['Memo Directives'].split(';'):
  7949                                                               md = md.strip()
  7950                                                               if not md:
  7951                                                                   continue
  7952                                           
  7953                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7954                                                                   pbal_amount = self._parse_memo_amount(md)
  7955                                                                   pbal_delta += pbal_amount
  7956                                                                   checking_delta += pbal_amount
  7957                                                               else:
  7958                                                                   md_to_keep.append(md)
  7959                                           
  7960                                                           # Remove the checking memo directive
  7961                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${pbal_amount:.2f})'
  7962                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7963                                           
  7964                                                       elif date_iat in loan_billing_dates:
  7965                                                           # Handle other billing dates
  7966                                           
  7967                                                           # Initialize variables
  7968                                                           pbal_paid_amount = 0.0
  7969                                                           og_pbal_md = ''
  7970                                           
  7971                                                           # Parse memo directives
  7972                                                           for md in f_row['Memo Directives'].split(';'):
  7973                                                               md = md.strip()
  7974                                                               if not md:
  7975                                                                   continue
  7976                                           
  7977                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7978                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  7979                                                                   og_pbal_md = md
  7980                                                               else:
  7981                                                                   md_to_keep.append(md)
  7982                                           
  7983                                                           # Get balance at the time of charge
  7984                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7985                                           
  7986                                                           # Adjust principal balance memo
  7987                                                           if pbal_balance <= pbal_paid_amount:
  7988                                                               new_pbal_amount = pbal_balance
  7989                                                               og_pbal_surplus = pbal_paid_amount - pbal_balance
  7990                                                               final_recredit_checking = og_pbal_surplus
  7991                                                               new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  7992                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7993                                                           else:
  7994                                                               new_pbal_amount = pbal_paid_amount
  7995                                                               og_pbal_surplus = 0.0
  7996                                                               final_recredit_checking = 0.0
  7997                                                               new_pbal_md = og_pbal_md
  7998                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7999                                           
  8000                                                           # Update memo directives
  8001                                                           md_to_keep.extend([new_pbal_md, new_checking_pbal_md])
  8002                                           
  8003                                                           # Adjust deltas
  8004                                                           checking_delta += final_recredit_checking
  8005                                                           pbal_delta += og_pbal_surplus
  8006                                           
  8007                                                       else:
  8008                                                           # No adjustments needed for other dates
  8009                                                           pass
  8010                                           
  8011                                                       # Update balances
  8012                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8013                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  8014                                           
  8015                                                       # Apply daily interest accrual
  8016                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  8017                                                           if f_i == 0:
  8018                                                               # Set interest to the value after the transaction
  8019                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  8020                                                           else:
  8021                                                               # Set interest equal to the previous day's interest
  8022                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  8023                                                                   f_i - 1, interest_account_name]
  8024                                           
  8025                                                           # Calculate interest accrued on this day
  8026                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8027                                                           interest_accrued = pbal_balance * (apr / 365.25)
  8028                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  8029                                           
  8030                                                       # Clean and update memo directives
  8031                                                       md_to_keep = [md for md in md_to_keep if md]
  8032                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8033                                           
  8034                                                   self.log_stack_depth -= 1
  8035                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_only', self.log_stack_depth)
  8036                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_interest at line 8039

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8039                                               def _propagate_loan_payment_pbal_interest(self, relevant_account_info_df,
  8040                                                                                         account_deltas_list,
  8041                                                                                         future_rows_only_df,
  8042                                                                                         forecast_df,
  8043                                                                                         account_set_before_p2_plus_txn,
  8044                                                                                         billing_dates_dict,
  8045                                                                                         date_string_YYYYMMDD,
  8046                                                                                         post_txn_row_df):
  8047                                                   """
  8048                                                   Propagates loan payments involving principal balance and interest into the future forecast.
  8049                                           
  8050                                                   Parameters:
  8051                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  8052                                                   - account_deltas_list: List of account balance changes (deltas).
  8053                                                   - future_rows_only_df: DataFrame with future forecast rows.
  8054                                                   - forecast_df: The original forecast DataFrame.
  8055                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  8056                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  8057                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  8058                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  8059                                           
  8060                                                   Returns:
  8061                                                   - Updated future_rows_only_df DataFrame.
  8062                                                   """
  8063                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  8064                                                   self.log_stack_depth += 1
  8065                                           
  8066                                                   # Extract relevant account names
  8067                                                   checking_account_name = relevant_account_info_df[
  8068                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  8069                                                   pbal_account_name = relevant_account_info_df[
  8070                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  8071                                                   interest_account_name = relevant_account_info_df[
  8072                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  8073                                           
  8074                                                   # Get the APR for the principal balance account
  8075                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  8076                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  8077                                                   apr = pbal_row_df['APR'].iat[0]
  8078                                           
  8079                                                   # Get billing dates and next billing date
  8080                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  8081                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  8082                                                   if future_billing_dates:
  8083                                                       next_billing_date = str(min(future_billing_dates))
  8084                                                   else:
  8085                                                       next_billing_date = None
  8086                                           
  8087                                                   # Get account indices in forecast_df
  8088                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  8089                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  8090                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  8091                                           
  8092                                                   # Get account deltas
  8093                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  8094                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  8095                                                   checking_delta = pbal_delta + interest_delta
  8096                                           
  8097                                                   # Iterate over future forecast rows
  8098                                                   for f_i, f_row in future_rows_only_df.iterrows():
  8099                                                       date_iat = f_row['Date']
  8100                                                       md_to_keep = []
  8101                                           
  8102                                                       if date_iat == next_billing_date:
  8103                                                           # Handle next billing date (payment due date)
  8104                                           
  8105                                                           # Initialize amounts
  8106                                                           pbal_amount = 0.0
  8107                                                           interest_amount = 0.0
  8108                                           
  8109                                                           # Parse memo directives
  8110                                                           for md in f_row['Memo Directives'].split(';'):
  8111                                                               md = md.strip()
  8112                                                               if not md:
  8113                                                                   continue
  8114                                           
  8115                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8116                                                                   pbal_amount = self._parse_memo_amount(md)
  8117                                                                   pbal_delta += pbal_amount
  8118                                                                   checking_delta += pbal_amount
  8119                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8120                                                                   interest_amount = self._parse_memo_amount(md)
  8121                                                                   interest_delta += interest_amount
  8122                                                                   checking_delta += interest_amount
  8123                                                               else:
  8124                                                                   md_to_keep.append(md)
  8125                                           
  8126                                                           # Remove the checking memo directive
  8127                                                           total_payment = pbal_amount + interest_amount
  8128                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${total_payment:.2f})'
  8129                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  8130                                           
  8131                                                       elif date_iat in loan_billing_dates:
  8132                                                           # Handle other billing dates (interest accrual)
  8133                                           
  8134                                                           # Initialize variables
  8135                                                           pbal_paid_amount = 0.0
  8136                                                           interest_paid_amount = 0.0
  8137                                                           og_pbal_md = ''
  8138                                                           og_interest_md = ''
  8139                                           
  8140                                                           # Parse memo directives
  8141                                                           for md in f_row['Memo Directives'].split(';'):
  8142                                                               md = md.strip()
  8143                                                               if not md:
  8144                                                                   continue
  8145                                           
  8146                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8147                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  8148                                                                   og_pbal_md = md
  8149                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8150                                                                   interest_paid_amount = self._parse_memo_amount(md)
  8151                                                                   og_interest_md = md
  8152                                                               else:
  8153                                                                   md_to_keep.append(md)
  8154                                           
  8155                                                           # Get balances at the time of charge
  8156                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8157                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  8158                                           
  8159                                                           # Adjust interest memo
  8160                                                           if interest_balance <= interest_paid_amount:
  8161                                                               new_interest_amount = interest_balance
  8162                                                               og_interest_surplus = interest_paid_amount - interest_balance
  8163                                                           else:
  8164                                                               new_interest_amount = interest_paid_amount
  8165                                                               og_interest_surplus = 0.0
  8166                                                           new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  8167                                                           new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  8168                                           
  8169                                                           # Adjust principal balance memo
  8170                                                           total_pbal_payment = pbal_paid_amount + og_interest_surplus
  8171                                                           if pbal_balance <= total_pbal_payment:
  8172                                                               new_pbal_amount = pbal_balance
  8173                                                               og_pbal_surplus = total_pbal_payment - pbal_balance
  8174                                                               final_recredit_checking = og_pbal_surplus
  8175                                                           else:
  8176                                                               new_pbal_amount = total_pbal_payment
  8177                                                               og_pbal_surplus = 0.0
  8178                                                               final_recredit_checking = 0.0
  8179                                                           new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  8180                                                           new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  8181                                           
  8182                                                           # Update memo directives
  8183                                                           md_to_keep.extend([new_interest_md, new_pbal_md, new_checking_pbal_md, new_checking_interest_md])
  8184                                           
  8185                                                           # Adjust deltas
  8186                                                           checking_delta += (og_pbal_surplus + og_interest_surplus)
  8187                                                           pbal_delta += og_pbal_surplus
  8188                                                           interest_delta += og_interest_surplus
  8189                                           
  8190                                                       else:
  8191                                                           # No adjustments needed for other dates
  8192                                                           pass
  8193                                           
  8194                                                       # Update balances
  8195                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8196                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  8197                                           
  8198                                                       # Apply daily interest accrual
  8199                                                       if date_iat >= min(loan_billing_dates):
  8200                                                           if f_i == 0:
  8201                                                               # Set interest to the value after the transaction
  8202                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  8203                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  8204                                                           else:
  8205                                                               # Set interest equal to the previous day's interest
  8206                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  8207                                                                   f_i - 1, interest_account_name]
  8208                                           
  8209                                                           # Calculate interest accrued on this day
  8210                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8211                                                           interest_accrued = pbal_balance * (apr / 365.25)
  8212                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  8213                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  8214                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  8215                                           
  8216                                                       # Clean and update memo directives
  8217                                                       md_to_keep = [md for md in md_to_keep if md]
  8218                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8219                                           
  8220                                                   self.log_stack_depth -= 1
  8221                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  8222                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_curr at line 8225

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8225                                               def _propagate_credit_payment_prev_curr(self, relevant_account_info_df,
  8226                                                                                       account_deltas_list,
  8227                                                                                       future_rows_only_df,
  8228                                                                                       forecast_df,
  8229                                                                                       account_set_before_p2_plus_txn,
  8230                                                                                       billing_dates_dict,
  8231                                                                                       date_string_YYYYMMDD,
  8232                                                                                       post_txn_row_df):
  8233                                                   """
  8234                                                   Propagates credit card payments into the future forecast when both previous and current statement balances are involved.
  8235                                           
  8236                                                   Parameters:
  8237                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  8238                                                   - account_deltas_list: List of account balance changes (deltas).
  8239                                                   - future_rows_only_df: DataFrame with future forecast rows.
  8240                                                   - forecast_df: The original forecast DataFrame.
  8241                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  8242                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  8243                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  8244                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  8245                                           
  8246                                                   Returns:
  8247                                                   - Updated future_rows_only_df DataFrame.
  8248                                                   """
  8249                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8250                                                   self.log_stack_depth += 1
  8251                                           
  8252                                                   # Extract relevant account names
  8253                                                   checking_account_name = relevant_account_info_df[
  8254                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  8255                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  8256                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  8257                                                   prev_stmt_bal_account_name = relevant_account_info_df[
  8258                                                       relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  8259                                           
  8260                                                   # Get billing dates and next billing date
  8261                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  8262                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  8263                                                   if future_billing_dates:
  8264                                                       next_billing_date = str(min(future_billing_dates))
  8265                                                   else:
  8266                                                       next_billing_date = None
  8267                                           
  8268                                                   # Get account indices in forecast_df
  8269                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  8270                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  8271                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  8272                                           
  8273                                                   # Get account deltas
  8274                                                   previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  8275                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  8276                                                   checking_delta = previous_stmt_delta + curr_stmt_delta
  8277                                           
  8278                                                   # Initialize previous previous statement balance (used in future billing dates)
  8279                                                   previous_prev_stmt_bal = 0
  8280                                           
  8281                                                   # Iterate over future forecast rows
  8282                                                   for f_i, f_row in future_rows_only_df.iterrows():
  8283                                                       date_iat = f_row['Date']
  8284                                           
  8285                                                       md_to_keep = []
  8286                                           
  8287                                                       if date_iat == next_billing_date:
  8288                                                           # Handle next billing date
  8289                                           
  8290                                                           # Initialize memo variables
  8291                                                           og_prev_memo = ''
  8292                                                           og_curr_memo = ''
  8293                                                           og_check_memo = ''
  8294                                                           og_interest_memo = ''
  8295                                                           og_prev_amount = 0.0
  8296                                                           og_curr_amount = 0.0
  8297                                                           og_check_amount = 0.0
  8298                                                           og_interest_amount = 0.0
  8299                                           
  8300                                                           # Parse memo directives
  8301                                                           for md in f_row['Memo Directives'].split(';'):
  8302                                                               md = md.strip()
  8303                                                               if not md:
  8304                                                                   continue
  8305                                           
  8306                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8307                                                                   og_prev_memo = md
  8308                                                                   og_prev_amount = self._parse_memo_amount(md)
  8309                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8310                                                                   og_curr_memo = md
  8311                                                                   og_curr_amount = self._parse_memo_amount(md)
  8312                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8313                                                                   og_check_memo = md
  8314                                                                   og_check_amount = self._parse_memo_amount(md)
  8315                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8316                                                                   og_interest_memo = md
  8317                                                                   og_interest_amount = self._parse_memo_amount(md)
  8318                                                               else:
  8319                                                                   md_to_keep.append(md)
  8320                                           
  8321                                                           # Get advance payment amount
  8322                                                           advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  8323                                                               prev_stmt_bal_account_name,
  8324                                                               account_set_before_p2_plus_txn,
  8325                                                               forecast_df,
  8326                                                               date_iat
  8327                                                           )
  8328                                           
  8329                                                           min_payment_amount = og_check_amount
  8330                                           
  8331                                                           # Adjust deltas
  8332                                                           curr_stmt_delta += og_curr_amount
  8333                                                           previous_stmt_delta += og_prev_amount
  8334                                                           checking_delta += og_prev_amount + og_curr_amount
  8335                                           
  8336                                                           # Apply advance payments
  8337                                                           if advance_payment_amount >= min_payment_amount:
  8338                                                               # All payments already made
  8339                                                               new_check_memo = f'CC MIN PAYMENT ALREADY MADE ({checking_account_name} -$0.00)'
  8340                                                               new_prev_memo = (f'CC MIN PAYMENT ALREADY MADE ({prev_stmt_bal_account_name} -$0.00)'
  8341                                                                                if og_prev_amount > 0 else '')
  8342                                                               new_curr_memo = (f'CC MIN PAYMENT ALREADY MADE ({curr_stmt_bal_account_name} -$0.00)'
  8343                                                                                if og_curr_amount > 0 else '')
  8344                                                           else:
  8345                                                               remaining_payment = min_payment_amount - advance_payment_amount
  8346                                                               if advance_payment_amount >= og_prev_amount:
  8347                                                                   # Advance payments cover previous statement balance
  8348                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  8349                                                                   curr_amount_remaining = og_curr_amount - (advance_payment_amount - og_prev_amount)
  8350                                                                   new_curr_memo = self._update_memo_amount(og_curr_memo, curr_amount_remaining)
  8351                                                               else:
  8352                                                                   # Advance payments partially cover previous statement balance
  8353                                                                   prev_amount_remaining = og_prev_amount - advance_payment_amount
  8354                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, prev_amount_remaining)
  8355                                                                   new_curr_memo = og_curr_memo
  8356                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - advance_payment_amount)
  8357                                           
  8358                                                           # Move current statement delta to previous
  8359                                                           previous_stmt_delta += curr_stmt_delta
  8360                                                           curr_stmt_delta = 0
  8361                                           
  8362                                                           # Update memo directives
  8363                                                           md_to_keep.extend(filter(None, [new_check_memo, new_curr_memo, new_prev_memo, og_interest_memo]))
  8364                                           
  8365                                                           # Compute previous previous statement balance
  8366                                                           previous_prev_stmt_bal = round(
  8367                                                               future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta, 2
  8368                                                           )
  8369                                           
  8370                                                       elif date_iat in cc_billing_dates:
  8371                                                           # Handle other billing dates
  8372                                           
  8373                                                           # Ensure we have a valid previous_prev_stmt_bal
  8374                                                           if previous_prev_stmt_bal == 0:
  8375                                                               continue  # Skip if we don't have previous balance
  8376                                           
  8377                                                           # Initialize memo variables
  8378                                                           og_prev_memo = ''
  8379                                                           og_curr_memo = ''
  8380                                                           og_check_memo = ''
  8381                                                           og_interest_memo = ''
  8382                                                           og_prev_amount = 0.0
  8383                                                           og_curr_amount = 0.0
  8384                                                           og_check_amount = 0.0
  8385                                                           og_interest_amount = 0.0
  8386                                                           og_min_payment_amount = 0.0
  8387                                           
  8388                                                           # Parse memo directives
  8389                                                           for md in f_row['Memo Directives'].split(';'):
  8390                                                               md = md.strip()
  8391                                                               if not md:
  8392                                                                   continue
  8393                                           
  8394                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8395                                                                   og_prev_memo = md
  8396                                                                   og_prev_amount = self._parse_memo_amount(md)
  8397                                                                   og_min_payment_amount += og_prev_amount
  8398                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8399                                                                   og_curr_memo = md
  8400                                                                   og_curr_amount = self._parse_memo_amount(md)
  8401                                                                   og_min_payment_amount += og_curr_amount
  8402                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8403                                                                   og_check_memo = md
  8404                                                                   og_check_amount = self._parse_memo_amount(md)
  8405                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8406                                                                   og_interest_memo = md
  8407                                                                   og_interest_amount = self._parse_memo_amount(md)
  8408                                                               else:
  8409                                                                   md_to_keep.append(md)
  8410                                           
  8411                                                           # Get account row for APR
  8412                                                           account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  8413                                                               account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  8414                                                               ]
  8415                                           
  8416                                                           # Compute interest and current due
  8417                                                           apr = account_row.APR.iat[0]
  8418                                                           interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  8419                                                           principal_due = previous_prev_stmt_bal * 0.01
  8420                                                           current_due = principal_due + interest_to_be_charged
  8421                                           
  8422                                                           # Adjusted payment amounts
  8423                                                           curr_prev_stmt_bal = f_row[prev_stmt_bal_account_name]  # Should we adjust for interest?
  8424                                           
  8425                                                           new_min_payment_amount = max(min(40, current_due), curr_prev_stmt_bal)
  8426                                           
  8427                                                           adjusted_payment_amount = round(og_min_payment_amount - new_min_payment_amount, 2)
  8428                                           
  8429                                                           previous_stmt_delta += adjusted_payment_amount
  8430                                                           checking_delta += adjusted_payment_amount
  8431                                                           interest_delta = interest_to_be_charged - og_interest_amount
  8432                                                           previous_stmt_delta += round(interest_delta, 2)
  8433                                           
  8434                                                           # Adjust memos
  8435                                                           new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - adjusted_payment_amount)
  8436                                                           if adjusted_payment_amount >= curr_prev_stmt_bal:
  8437                                                               # Adjust curr and prev memos
  8438                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, adjusted_payment_amount - curr_prev_stmt_bal)
  8439                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, curr_prev_stmt_bal)
  8440                                                           else:
  8441                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  8442                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, adjusted_payment_amount)
  8443                                                           new_interest_memo = self._update_memo_amount(og_interest_memo, interest_to_be_charged)
  8444                                           
  8445                                                           # Update memo directives
  8446                                                           md_to_keep.extend([new_check_memo, new_curr_memo, new_prev_memo, new_interest_memo])
  8447                                           
  8448                                                           # Update previous_prev_stmt_bal
  8449                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  8450                                           
  8451                                                       else:
  8452                                                           # No adjustments needed
  8453                                                           pass
  8454                                           
  8455                                                       # Update balances
  8456                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8457                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  8458                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  8459                                           
  8460                                                       # Clean and update memo directives
  8461                                                       md_to_keep = [md for md in md_to_keep if md]
  8462                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8463                                           
  8464                                                   self.log_stack_depth -= 1
  8465                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8466                                                   return future_rows_only_df

Total time: 0.000397 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _parse_memo_amount at line 8469

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8469                                               def _parse_memo_amount(self, memo_line):
  8470                                                   """
  8471                                                   Parses a memo line and extracts the amount.
  8472                                                   Returns the amount as a float.
  8473                                                   """
  8474                                                   match = re.search(r'\((.*?)-\$(.*?)\)', memo_line)
  8475         1        391.0    391.0     98.5          if match:
  8476         1          0.0      0.0      0.0              amount_str = match.group(2).strip()
  8477         1          2.0      2.0      0.5              try:
  8478         1          1.0      1.0      0.3                  amount = float(amount_str)
  8479         1          2.0      2.0      0.5                  return amount
  8480         1          1.0      1.0      0.3              except ValueError:
  8481                                                           return 0.0
  8482                                                   else:
  8483                                                       return 0.0

Total time: 0.000105 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _update_memo_amount at line 8486

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8486                                               def _update_memo_amount(self, memo_line, new_amount):
  8487                                                   """
  8488                                                   Updates the amount in a memo line with a new amount.
  8489                                                   Returns the updated memo line.
  8490                                                   """
  8491                                                   return re.sub(r'\((.*?)-\$(.*?)\)', r'(\1-$' + f'{new_amount:.2f}' + ')', memo_line)

Total time: 22.4688 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: propagateOptimizationTransactionsIntoTheFuture at line 8494

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8494                                               def propagateOptimizationTransactionsIntoTheFuture(self, account_set_before_p2_plus_txn, forecast_df, date_string_YYYYMMDD):
  8495                                                   """
  8496                                                   Propagates optimization transactions into the future forecast.
  8497                                           
  8498                                                   Parameters:
  8499                                                   - account_set_before_p2_plus_txn: Account set before processing transactions.
  8500                                                   - forecast_df: DataFrame containing the financial forecast.
  8501                                                   - date_string_YYYYMMDD: The current date in 'YYYYMMDD' format.
  8502                                           
  8503                                                   Returns:
  8504                                                   - Updated forecast_df with propagated transactions.
  8505                                                   """
  8506                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8507        60       2292.0     38.2      0.0          self.log_stack_depth += 1
  8508        60        119.0      2.0      0.0          log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8509        60        663.0     11.1      0.0          log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8510        60     539792.0   8996.5      2.4  
  8511                                                   account_set_after_p2_plus_txn = self.sync_account_set_w_forecast_day(
  8512       120   18245354.0 152044.6     81.2              copy.deepcopy(account_set_before_p2_plus_txn), forecast_df, date_string_YYYYMMDD
  8513        60      33749.0    562.5      0.2          )
  8514                                           
  8515                                                   A_df = account_set_after_p2_plus_txn.getAccounts()
  8516        60    1727976.0  28799.6      7.7          B_df = account_set_before_p2_plus_txn.getAccounts()
  8517        60    1741920.0  29032.0      7.8  
  8518                                                   # Compute account deltas
  8519                                                   account_deltas = A_df['Balance'] - B_df['Balance']
  8520        60      24653.0    410.9      0.1  
  8521                                                   # Sanity check: For certain account types, deltas should be <= 0
  8522                                                   account_types_to_check = ['checking', 'principal balance', 'interest']
  8523        60         69.0      1.1      0.0          is_account_type = A_df['Account_Type'].isin(account_types_to_check)
  8524        60      17226.0    287.1      0.1          violations = account_deltas[is_account_type] > 0
  8525        60      19569.0    326.1      0.1  
  8526                                                   if violations.any():
  8527        60       5783.0     96.4      0.0              log_in_color(logger, 'red', 'error', str(account_deltas[violations]), self.log_stack_depth)
  8528                                                       raise AssertionError('Account delta positive for checking, principal balance, or interest accounts.')
  8529                                           
  8530                                                   account_deltas_list = account_deltas.tolist()
  8531        60        308.0      5.1      0.0  
  8532                                                   if account_deltas.sum() == 0:
  8533        60       8725.0    145.4      0.0              return forecast_df
  8534        59         29.0      0.5      0.0  
  8535                                                   # log_in_color(
  8536                                                   #     logger,
  8537                                                   #     'magenta',
  8538                                                   #     'debug',
  8539                                                   #     f'ENTER propagateOptimizationTransactionsIntoTheFuture({date_string_YYYYMMDD})',
  8540                                                   #     self.log_stack_depth
  8541                                                   # )
  8542                                           
  8543                                                   future_rows_only_row_sel_vec = [ datetime.datetime.strptime(d, '%Y%m%d') > datetime.datetime.strptime(date_string_YYYYMMDD, '%Y%m%d') for d in forecast_df.Date]  # not sure if still need this
  8544         1       2552.0   2552.0      0.0  
  8545                                                   post_txn_row_df = forecast_df[forecast_df['Date'] == date_string_YYYYMMDD]
  8546         1        434.0    434.0      0.0  
  8547                                                   future_rows_only_df = forecast_df[forecast_df['Date'] > date_string_YYYYMMDD].reset_index(drop=True)
  8548         1        443.0    443.0      0.0  
  8549                                                   # Generate interest accrual dates
  8550                                                   interest_accrual_dates__list_of_lists = []
  8551         1          0.0      0.0      0.0          for _, a_row in A_df.iterrows():
  8552         8        922.0    115.2      0.0              interest_cadence = a_row['Interest_Cadence']
  8553         7        112.0     16.0      0.0              if pd.isnull(interest_cadence) or interest_cadence == 'None':
  8554         7         16.0      2.3      0.0                  interest_accrual_dates__list_of_lists.append([])
  8555         4          3.0      0.8      0.0                  continue
  8556         4          1.0      0.2      0.0  
  8557                                                       start_date = pd.to_datetime(a_row['Billing_Start_Date'], format='%Y%m%d')
  8558         3        875.0    291.7      0.0              end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8559         3        737.0    245.7      0.0              num_days = (end_date - start_date).days
  8560         3         57.0     19.0      0.0              account_specific_iad = generate_date_sequence(a_row['Billing_Start_Date'], num_days, interest_cadence)
  8561         3       2810.0    936.7      0.0              interest_accrual_dates__list_of_lists.append(account_specific_iad)
  8562         3          3.0      1.0      0.0  
  8563                                                   # Generate billing dates
  8564                                                   billing_dates__list_of_lists = []
  8565         1          0.0      0.0      0.0          billing_dates__dict = {}
  8566         1          0.0      0.0      0.0          for _, a_row in A_df.iterrows():
  8567         8        674.0     84.2      0.0              billing_start_date = a_row['Billing_Start_Date']
  8568         7        105.0     15.0      0.0              if pd.isnull(billing_start_date) or billing_start_date == 'None':
  8569         7         17.0      2.4      0.0                  billing_dates__list_of_lists.append([])
  8570         4          4.0      1.0      0.0                  continue
  8571         4          3.0      0.8      0.0  
  8572                                                       start_date = pd.to_datetime(billing_start_date, format='%Y%m%d')
  8573         3        808.0    269.3      0.0              end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8574         3        809.0    269.7      0.0              num_days = (end_date - start_date).days
  8575         3         50.0     16.7      0.0              account_specific_bd = generate_date_sequence(billing_start_date, num_days, 'monthly')
  8576         3       1871.0    623.7      0.0              billing_dates__list_of_lists.append(account_specific_bd)
  8577         3          3.0      1.0      0.0              billing_dates__dict[a_row['Name']] = account_specific_bd
  8578         3         61.0     20.3      0.0  
  8579                                                   # Mapping of account type combinations to processing functions
  8580                                                   account_type_combinations = {
  8581         1          2.0      2.0      0.0              frozenset(
  8582         2          2.0      1.0      0.0                  ['checking', 'credit prev stmt bal', 'credit curr stmt bal']): self._propagate_credit_payment_prev_curr,
  8583         2          2.0      1.0      0.0              frozenset(['checking', 'principal balance', 'interest']): self._propagate_loan_payment_pbal_interest,
  8584         1          2.0      2.0      0.0              frozenset(['checking', 'principal balance']): self._propagate_loan_payment_pbal_only,
  8585         1          1.0      1.0      0.0              frozenset(['checking', 'interest']): self._propagate_loan_payment_interest_only,
  8586         1          0.0      0.0      0.0              frozenset(['checking', 'credit prev stmt bal']): self._propagate_credit_payment_prev_only,
  8587         1          1.0      1.0      0.0              frozenset(['checking', 'credit curr stmt bal']): self._propagate_credit_curr_only,
  8588         1          1.0      1.0      0.0              frozenset(['credit curr stmt bal']): self._propagate_credit_curr_stmt_balance,
  8589         1          1.0      1.0      0.0          }
  8590                                           
  8591                                                   # Assume accounts_df is a DataFrame containing account information
  8592                                                   accounts_df = account_set_before_p2_plus_txn.getAccounts().copy()
  8593         1      28686.0  28686.0      0.1  
  8594                                                   # Create a Series for account deltas with the same index as accounts_df
  8595                                                   accounts_df['Delta'] = account_deltas_list
  8596         1        431.0    431.0      0.0  
  8597                                                   # Extract base names (before ':') of account names
  8598                                                   accounts_df['Base_Name'] = accounts_df['Name'].str.split(':').str[0]
  8599         1        924.0    924.0      0.0  
  8600                                                   # Select accounts with non-zero deltas
  8601                                                   accounts_with_deltas = accounts_df[accounts_df['Delta'] != 0]
  8602         1        778.0    778.0      0.0  
  8603                                                   # Check if 'checking' account type is involved in the transaction
  8604                                                   checking_in_txn = 'checking' in accounts_with_deltas['Account_Type'].unique()
  8605         1        165.0    165.0      0.0  
  8606                                                   # Get base names of accounts involved in the transaction
  8607                                                   affected_account_base_names = set(accounts_with_deltas['Base_Name'])
  8608         1         61.0     61.0      0.0  
  8609                                                   # Get base names of checking accounts
  8610                                                   checking_base_names = set(accounts_df[accounts_df['Account_Type'] == 'checking']['Base_Name'])
  8611         1        513.0    513.0      0.0  
  8612                                                   # Base names of affected accounts excluding checking accounts
  8613                                                   affected_account_base_names_sans_checking = affected_account_base_names - checking_base_names
  8614         1          1.0      1.0      0.0  
  8615                                                   if checking_in_txn and len(affected_account_base_names_sans_checking) == 0:
  8616         1          1.0      1.0      0.0              # Only checking accounts are involved in the transaction
  8617                                                       # Update future balances for the checking accounts
  8618                                                       for idx, row in accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking'].iterrows():
  8619                                                           min_balance = row['Min_Balance']
  8620                                                           max_balance = row['Max_Balance']
  8621                                                           relevant_checking_account_name = row['Name']
  8622                                                           checking_delta = row['Delta']
  8623                                                           future_rows_only_df[relevant_checking_account_name] += checking_delta
  8624                                           
  8625                                                       if not future_rows_only_df.empty:
  8626                                                           min_future_acct_bal = min(future_rows_only_df[relevant_checking_account_name])
  8627                                                           max_future_acct_bal = max(future_rows_only_df[relevant_checking_account_name])
  8628                                           
  8629                                                           try:
  8630                                                               assert min_balance <= min_future_acct_bal
  8631                                                           except AssertionError:
  8632                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8633                                                               error_msg += "Account boundaries were violated\n"
  8634                                                               error_msg += "min_balance <= min_future_acct_bal was not True\n"
  8635                                                               error_msg += str(min_balance) + " <= " + str(min_future_acct_bal) + '\n'
  8636                                                               error_msg += future_rows_only_df.to_string()
  8637                                                               raise ValueError(error_msg)
  8638                                           
  8639                                                           try:
  8640                                                               assert max_balance >= max_future_acct_bal
  8641                                                           except AssertionError:
  8642                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8643                                                               error_msg += "Account boundaries were violated\n"
  8644                                                               error_msg += "max_balance >= max_future_acct_bal was not True\n"
  8645                                                               error_msg += str(max_balance) + " <= " + str(max_future_acct_bal) + '\n'
  8646                                                               error_msg += future_rows_only_df.to_string()
  8647                                                               raise ValueError(error_msg)
  8648                                                   else:
  8649                                                       # Process each affected base account name excluding checking accounts
  8650                                                       for account_base_name in affected_account_base_names_sans_checking:
  8651         2          1.0      0.5      0.0                  # Select accounts with the current base name
  8652                                                           accounts_with_base_name = accounts_df[accounts_df['Base_Name'] == account_base_name]
  8653         1        442.0    442.0      0.0  
  8654                                                           # Select accounts with non-zero deltas and the current base name
  8655                                                           accounts_with_base_name_and_delta = accounts_with_base_name[accounts_with_base_name['Delta'] != 0]
  8656         1        492.0    492.0      0.0  
  8657                                                           if accounts_with_base_name_and_delta.empty:
  8658         1         10.0     10.0      0.0                      continue
  8659                                           
  8660                                                           # Get the list of account types involved for this base name
  8661                                                           relevant_account_type_list = accounts_with_base_name_and_delta['Account_Type'].unique().tolist()
  8662         1        112.0    112.0      0.0  
  8663                                                           # If checking accounts are involved, include them
  8664                                                           if checking_in_txn:
  8665         1          1.0      1.0      0.0                      checking_accounts_in_txn = accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking']
  8666         1        450.0    450.0      0.0                      accounts_with_base_name_and_delta = pd.concat(
  8667         2        650.0    325.0      0.0                          [accounts_with_base_name_and_delta, checking_accounts_in_txn])
  8668         1          1.0      1.0      0.0                      if 'checking' not in relevant_account_type_list:
  8669         1          1.0      1.0      0.0                          relevant_account_type_list.append('checking')
  8670         1          1.0      1.0      0.0  
  8671                                                           # Prepare the DataFrame with relevant account information
  8672                                                           relevant_account_info_df = accounts_with_base_name_and_delta
  8673         1          0.0      0.0      0.0  
  8674                                                           # Proceed to handle the transaction based on relevant_account_type_list
  8675                                                           # (Implementation depends on specific business logic)
  8676                                           
  8677                                                           # Identify the appropriate processing function
  8678                                                           account_types_set = frozenset(relevant_account_type_list)
  8679         1          2.0      2.0      0.0                  processing_function = account_type_combinations.get(account_types_set)
  8680         1          2.0      2.0      0.0  
  8681                                                           if processing_function:
  8682         1          0.0      0.0      0.0                      # Call the processing function
  8683                                                               future_rows_only_df = processing_function(
  8684         2      35815.0  17907.5      0.2                          relevant_account_info_df,
  8685         1          0.0      0.0      0.0                          account_deltas_list,
  8686         1          1.0      1.0      0.0                          future_rows_only_df,
  8687         1          0.0      0.0      0.0                          forecast_df,
  8688         1          0.0      0.0      0.0                          account_set_before_p2_plus_txn,
  8689         1          0.0      0.0      0.0                          billing_dates__dict,
  8690         1          1.0      1.0      0.0                          date_string_YYYYMMDD,
  8691         1          1.0      1.0      0.0                          post_txn_row_df
  8692         1          0.0      0.0      0.0                      )
  8693                                                           else:
  8694                                                               print('relevant_account_type_list:', relevant_account_type_list)
  8695                                                               print('affected_account_base_names:', relevant_account_info_df['Name'].unique())
  8696                                                               self.log_stack_depth -= 1
  8697                                                               raise ValueError("Undefined case in process_transactions")
  8698                                           
  8699                                                   if not future_rows_only_df.empty:
  8700         1         10.0     10.0      0.0              # if not boundary violation
  8701                                                       #todo very slow to do this
  8702                                                       index_of_first_future_day = list(forecast_df.Date).index(future_rows_only_df.head(1).Date.iat[0])
  8703         1        168.0    168.0      0.0              future_rows_only_df.index = future_rows_only_df.index + index_of_first_future_day
  8704         1        122.0    122.0      0.0              forecast_df.update(future_rows_only_df)
  8705         1       3412.0   3412.0      0.0  
  8706                                           
  8707                                                       log_in_color(logger, 'cyan', 'debug', 'future_rows_only_df', self.log_stack_depth)
  8708         1         19.0     19.0      0.0              log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  8709         1       6317.0   6317.0      0.0              log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8710         1          8.0      8.0      0.0              log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8711         1       7612.0   7612.0      0.0  
  8712                                                   self.log_stack_depth -= 1
  8713         1          2.0      2.0      0.0          log_in_color(logger, 'cyan', 'debug', 'EXIT propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8714         1          9.0      9.0      0.0          return forecast_df

Total time: 0.943493 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: updateProposedTransactionsBasedOnOtherSets at line 9197

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9197                                               def updateProposedTransactionsBasedOnOtherSets(self, confirmed_df, proposed_df, deferred_df, skipped_df):
  9198                                                   # update remaining_unproposed_transactions_df based on modifications to other sets made during the last loop
  9199                                                   C = 'C:'+str(confirmed_df.shape[0])
  9200        99        931.0      9.4      0.1          P = 'P:'+str(proposed_df.shape[0])
  9201        99        408.0      4.1      0.0          D = 'D:'+str(deferred_df.shape[0])
  9202        99        347.0      3.5      0.0          S = 'S:'+str(skipped_df.shape[0])
  9203        99        378.0      3.8      0.0          # log_in_color(logger,'cyan','debug','ENTER updateProposedTransactionsBasedOnOtherSets( '+C+' '+P+' '+D+' '+S+' )', self.log_stack_depth)
  9204                                                   #
  9205                                                   # log_in_color(logger, 'cyan', 'debug', 'confirmed_df:', self.log_stack_depth)
  9206                                                   # log_in_color(logger, 'cyan', 'debug',confirmed_df.to_string(), self.log_stack_depth)
  9207                                                   #
  9208                                                   # log_in_color(logger, 'cyan', 'debug', 'proposed_df:', self.log_stack_depth)
  9209                                                   # log_in_color(logger, 'cyan', 'debug', proposed_df.to_string(), self.log_stack_depth)
  9210                                                   #
  9211                                                   # log_in_color(logger, 'cyan', 'debug', 'deferred_df:', self.log_stack_depth)
  9212                                                   # log_in_color(logger, 'cyan', 'debug', deferred_df.to_string(), self.log_stack_depth)
  9213                                                   #
  9214                                                   # log_in_color(logger, 'cyan', 'debug', 'skipped_df:', self.log_stack_depth)
  9215                                                   # log_in_color(logger, 'cyan', 'debug', skipped_df.to_string(), self.log_stack_depth)
  9216                                           
  9217                                                   self.log_stack_depth += 1
  9218        99        173.0      1.7      0.0          # log_in_color(logger, 'cyan', 'debug', 'confirmed_df: '+str(confirmed_df))
  9219                                                   # log_in_color(logger, 'cyan', 'debug', 'proposed_df: '+str(proposed_df))
  9220                                                   # log_in_color(logger, 'cyan', 'debug', 'deferred_df: '+str(deferred_df))
  9221                                                   # log_in_color(logger, 'cyan', 'debug', 'skipped_df: '+str(skipped_df))
  9222                                                   #log_in_color(logger, 'cyan', 'debug', 'confirmed_df cols: '+str(confirmed_df.columns))
  9223                                                   #log_in_color(logger, 'cyan', 'debug', 'proposed_df cols: '+str(proposed_df.columns))
  9224                                                   #log_in_color(logger, 'cyan', 'debug', 'deferred_df cols: '+str(deferred_df.columns))
  9225                                                   #log_in_color(logger, 'cyan', 'debug', 'skipped_df cols: '+str(skipped_df.columns))
  9226                                           
  9227                                                   p_LJ_c = pd.merge(proposed_df, confirmed_df, on=['Date', 'Memo', 'Priority'])
  9228        99     325701.0   3289.9     34.5          p_LJ_d = pd.merge(proposed_df, deferred_df, on=['Date', 'Memo', 'Priority'])
  9229        99     276982.0   2797.8     29.4          p_LJ_s = pd.merge(proposed_df, skipped_df, on=['Date', 'Memo', 'Priority'])
  9230        99     275400.0   2781.8     29.2  
  9231                                                   not_confirmed_sel_vec = (~proposed_df.index.isin(p_LJ_c))
  9232        99      15680.0    158.4      1.7          not_deferred_sel_vec = (~proposed_df.index.isin(p_LJ_d))
  9233        99      11474.0    115.9      1.2          not_skipped_sel_vec = (~proposed_df.index.isin(p_LJ_s))
  9234        99      10650.0    107.6      1.1          remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9235        99        291.0      2.9      0.0          remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9236        99      24819.0    250.7      2.6  
  9237                                                   ### this code is equivalent. todo Which is more performant?
  9238                                                   # not_confirmed_sel_vec = (~proposed_df.index.isin(confirmed_df.index))
  9239                                                   # not_deferred_sel_vec = (~proposed_df.index.isin(deferred_df.index))
  9240                                                   # not_skipped_sel_vec = (~proposed_df.index.isin(skipped_df.index))
  9241                                                   # remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9242                                                   # remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9243                                           
  9244                                                   self.log_stack_depth -= 1
  9245        99        223.0      2.3      0.0          # log_in_color(logger, 'cyan', 'debug', 'EXIT updateProposedTransactionsBasedOnOtherSets',self.log_stack_depth)
  9246                                                   return remaining_unproposed_transactions_df

Total time: 239.297 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: assessPotentialOptimizations at line 9399

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9399                                               def assessPotentialOptimizations(self, forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df, raise_satisfice_failed_exception, progress_bar=None):
  9400                                                   F = 'F:'+str(forecast_df.shape[0])
  9401         3         15.0      5.0      0.0          C = 'C:'+str(confirmed_df.shape[0])
  9402         3         10.0      3.3      0.0          P = 'P:'+str(proposed_df.shape[0])
  9403         3         19.0      6.3      0.0          D = 'D:'+str(deferred_df.shape[0])
  9404         3          8.0      2.7      0.0          S = 'S:'+str(skipped_df.shape[0])
  9405         3          6.0      2.0      0.0          log_in_color(logger,'magenta','debug','ENTER assessPotentialOptimizations( '+F+' '+C+' '+P+' '+D+' '+S+' )',self.log_stack_depth)
  9406         3         55.0     18.3      0.0          self.log_stack_depth += 1
  9407         3          2.0      0.7      0.0          all_days = forecast_df.Date
  9408         3         66.0     22.0      0.0  
  9409                                                   # log_in_color(logger, 'magenta', 'debug', 'confirmed_df:', self.log_stack_depth)
  9410                                                   # log_in_color(logger, 'magenta', 'debug', confirmed_df.to_string(), self.log_stack_depth)
  9411                                                   #
  9412                                                   # log_in_color(logger, 'magenta', 'debug', 'proposed_df:', self.log_stack_depth)
  9413                                                   # log_in_color(logger, 'magenta', 'debug', proposed_df.to_string(), self.log_stack_depth)
  9414                                                   #
  9415                                                   # log_in_color(logger, 'magenta', 'debug', 'deferred_df:', self.log_stack_depth)
  9416                                                   # log_in_color(logger, 'magenta', 'debug', deferred_df.to_string(), self.log_stack_depth)
  9417                                                   #
  9418                                                   # log_in_color(logger, 'magenta', 'debug', 'skipped_df:', self.log_stack_depth)
  9419                                                   # log_in_color(logger, 'magenta', 'debug', skipped_df.to_string(), self.log_stack_depth)
  9420                                           
  9421                                                   # Schema is: Date, Priority, Amount, Memo, Deferrable, Partial_Payment_Allowed
  9422                                                   full_budget_schedule_df = pd.concat([confirmed_df, proposed_df, deferred_df, skipped_df])
  9423         3       1651.0    550.3      0.0          full_budget_schedule_df.reset_index(drop=True, inplace=True)
  9424         3         87.0     29.0      0.0  
  9425                                                   unique_priority_indices = full_budget_schedule_df.Priority.unique()
  9426         3        545.0    181.7      0.0          unique_priority_indices.sort()
  9427         3         12.0      4.0      0.0  
  9428                                           
  9429                                                   last_iteration_ts = None #this is here to remove a warning
  9430         3          0.0      0.0      0.0  
  9431                                                   if not raise_satisfice_failed_exception:
  9432         3          1.0      0.3      0.0              # print('Beginning Optimization.')
  9433                                                       # print(forecast_df.to_string())
  9434                                                       log_in_color(logger, 'white', 'info','Beginning Optimization.')
  9435         1         14.0     14.0      0.0              # log_in_color(logger, 'white', 'debug', self.start_date_YYYYMMDD + ' -> ' + self.end_date_YYYYMMDD)
  9436                                                       # log_in_color(logger, 'white', 'debug', 'Priority Indices: ' + str(unique_priority_indices))
  9437                                                       last_iteration_ts = datetime.datetime.now()
  9438         1          7.0      7.0      0.0  
  9439                                                   # print('Beginning unique_priority_indices:'+str(unique_priority_indices))
  9440                                                   for priority_index in unique_priority_indices:
  9441         8         13.0      1.6      0.0              if priority_index == 1:
  9442         6          2.0      0.3      0.0                  continue #because this was handled by satisfice
  9443         3          0.0      0.0      0.0  
  9444                                                       for date_string_YYYYMMDD in all_days:
  9445       104        389.0      3.7      0.0                  if date_string_YYYYMMDD == forecast_df.head(1).Date.iat[0]:
  9446       102      27061.0    265.3      0.0                  #if date_string_YYYYMMDD == self.start_date_YYYYMMDD:
  9447                                                               continue  # first day is considered final
  9448         3          1.0      0.3      0.0  
  9449                                           
  9450                                                           if not raise_satisfice_failed_exception:
  9451        99         73.0      0.7      0.0                      if progress_bar is not None:
  9452        38         25.0      0.7      0.0                          progress_bar.update(1)
  9453        38        130.0      3.4      0.0                          progress_bar.refresh()
  9454        38         62.0      1.6      0.0  
  9455                                                               iteration_time_elapsed = datetime.datetime.now() - last_iteration_ts
  9456        38        361.0      9.5      0.0                      last_iteration_ts = datetime.datetime.now()
  9457        38         53.0      1.4      0.0                      log_string = str(priority_index) + ' ' + datetime.datetime.strptime(date_string_YYYYMMDD,'%Y%m%d').strftime('%Y-%m-%d')
  9458        38       3356.0     88.3      0.0                      log_string += '     ' + str(iteration_time_elapsed)
  9459        38        120.0      3.2      0.0                      # log_in_color(logger, 'white', 'debug', log_string )
  9460                                           
  9461                                                           # log_in_color(logger, 'magenta', 'info', 'p' + str(priority_index) + ' ' + str(date_string_YYYYMMDD),self.log_stack_depth)
  9462                                           
  9463                                                           remaining_unproposed_transactions_df = self.updateProposedTransactionsBasedOnOtherSets(confirmed_df, proposed_df, deferred_df, skipped_df)
  9464        99     948231.0   9578.1      0.4  
  9465                                                           #todo idk if this is necessary
  9466                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9467        99   29970512.0 302732.4     12.5  
  9468                                                           #todo maybe this could be moved down? not sure
  9469                                                           account_set_before_p2_plus_txn = copy.deepcopy(account_set)
  9470        99      56144.0    567.1      0.0  
  9471                                                           #todo not sure if this is necessary
  9472                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9473        99   30607787.0 309169.6     12.8  
  9474                                           
  9475                                           
  9476                                                           forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(account_set=account_set,
  9477       198  121871297.0 615511.6     50.9                                                                                                      forecast_df=forecast_df,
  9478        99         40.0      0.4      0.0                                                                                                      date_YYYYMMDD=date_string_YYYYMMDD,
  9479        99         37.0      0.4      0.0                                                                                                      memo_set=memo_rule_set,
  9480        99         53.0      0.5      0.0                                                                                                      confirmed_df=confirmed_df,
  9481        99         51.0      0.5      0.0                                                                                                      proposed_df=remaining_unproposed_transactions_df,
  9482        99         41.0      0.4      0.0                                                                                                      deferred_df=deferred_df,
  9483        99         39.0      0.4      0.0                                                                                                      skipped_df=skipped_df,
  9484        99         37.0      0.4      0.0                                                                                                      priority_level=priority_index)
  9485        99         29.0      0.3      0.0  
  9486                                                           # log_in_color(logger, 'green', 'info', 'forecast_df after eTFD ('+str(date_string_YYYYMMDD)+'):', self.log_stack_depth)
  9487                                                           # log_in_color(logger, 'green', 'info', forecast_df.to_string(), self.log_stack_depth)
  9488                                           
  9489                                                           # print('assess optimizations case 3 sync')
  9490                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9491        98   30663874.0 312896.7     12.8  
  9492                                                           # this is necessary to make balance deltas propagate only once
  9493                                                           # print('raise_satisfice_failed_exception:'+str(raise_satisfice_failed_exception))
  9494                                                           if raise_satisfice_failed_exception:
  9495        98         49.0      0.5      0.0  
  9496                                                               #regarding why the input params are what they are here:
  9497                                                               # since the budget schedule does not have Account_From and Account_To, we infer which accounts were
  9498                                                               # affected by comparing the before and after, hence this method accepts the prior and current state
  9499                                                               # to modify forecast_df
  9500                                                               # Furthermore, additional loan payments affect the allocation of future minimum loan payments
  9501                                                               # so p1 minimumpayments, which aren't even BudgetItems as of 12/31/23.... must be edited
  9502                                                               # it kind of makes more sense to refactor and have credit card minimum payments and loan minimum
  9503                                                               # # payments as budget items....
  9504                                                               #
  9505                                                               # Doing that though creates a coupling between the AccountSet and BudgetSet classes that I don't like...
  9506                                                               # I only recently got the full detail of what happens into the Memo field, but I think that that is the answer
  9507                                                               # There will be information encoded in the Memo column that will not appear anywhere else
  9508                                                               #
  9509                                                               print('about to propagateOptimizationTransactionsIntoTheFuture')
  9510        60       1381.0     23.0      0.0                      print('BEFORE')
  9511        60        346.0      5.8      0.0                      print(forecast_df.to_string())
  9512        60    1262240.0  21037.3      0.5                      forecast_df = self.propagateOptimizationTransactionsIntoTheFuture(account_set_before_p2_plus_txn,forecast_df, date_string_YYYYMMDD)
  9513        60   22473211.0 374553.5      9.4  
  9514                                                               print('AFTER')
  9515        60       1577.0     26.3      0.0                      print(forecast_df.to_string())
  9516        60    1406101.0  23435.0      0.6  
  9517                                           
  9518                                                   self.log_stack_depth -= 1
  9519         2          6.0      3.0      0.0          log_in_color(logger, 'magenta', 'debug', 'EXIT assessPotentialOptimizations() C:'+str(confirmed_df.shape[0])+' D:'+str(deferred_df.shape[0])+' S:'+str(skipped_df.shape[0]),self.log_stack_depth)
  9520         2         82.0     41.0      0.0          return forecast_df, skipped_df, confirmed_df, deferred_df

Total time: 274.687 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: satisfice at line 9544

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9544                                               def satisfice(self, list_of_date_strings, confirmed_df, account_set, memo_rule_set, forecast_df,
  9545                                                             raise_satisfice_failed_exception, progress_bar=None):
  9546                                                   self.log_stack_depth += 1
  9547         3          5.0      1.7      0.0          all_days = list_of_date_strings  # Rename for clarity
  9548         3          0.0      0.0      0.0  
  9549                                                   for date_str in all_days:
  9550       117         77.0      0.7      0.0              if progress_bar:
  9551       114        169.0      1.5      0.0                  progress_bar.update(1)
  9552        38        121.0      3.2      0.0                  progress_bar.refresh()
  9553        38         69.0      1.8      0.0  
  9554                                                       # Skip the first day, considered as final
  9555                                                       if date_str == self.start_date_YYYYMMDD:
  9556       114        172.0      1.5      0.0                  continue
  9557                                           
  9558                                                       try:
  9559       114         42.0      0.4      0.0                  # Log transaction details if exception handling is not strict
  9560                                                           if not raise_satisfice_failed_exception:
  9561       114         34.0      0.3      0.0                      log_string = f"1 {datetime.datetime.strptime(date_str, '%Y%m%d').strftime('%Y-%m-%d')}"
  9562        38       3977.0    104.7      0.0  
  9563                                                           # Execute transactions for the day, priority 1 (non-negotiable)
  9564                                                           forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(
  9565       228   51981313.0 227988.2     18.9                      account_set=account_set,
  9566       114         49.0      0.4      0.0                      forecast_df=forecast_df,
  9567       114         45.0      0.4      0.0                      date_YYYYMMDD=date_str,
  9568       114         35.0      0.3      0.0                      memo_set=memo_rule_set,
  9569       114         41.0      0.4      0.0                      confirmed_df=confirmed_df,
  9570       114         37.0      0.3      0.0                      proposed_df=confirmed_df.head(0),  # No proposed transactions in satisfice
  9571       114       8813.0     77.3      0.0                      deferred_df=confirmed_df.head(0),  # No deferred transactions in satisfice
  9572       114       5162.0     45.3      0.0                      skipped_df=confirmed_df.head(0),  # No skipped transactions in satisfice
  9573       114       4413.0     38.7      0.0                      priority_level=1
  9574       114         48.0      0.4      0.0                  )
  9575                                           
  9576                                                           # Sync account set after transactions
  9577                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9578       114   36850201.0 323247.4     13.4  
  9579                                                           # Calculate loan interest accruals for the day
  9580                                                           forecast_df.loc[forecast_df.Date == date_str] = self.calculateLoanInterestAccrualsForDay(account_set,
  9581       228   12093941.0  53043.6      4.4                                                                                                           forecast_df[
  9582       228      31827.0    139.6      0.0                                                                                                               forecast_df.Date == date_str])
  9583       114      26759.0    234.7      0.0  
  9584                                                           # print('POST interest caculation')
  9585                                                           # print(forecast_df.to_string())
  9586                                           
  9587                                                           # Sync again after interest accruals
  9588                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9589       114   36783119.0 322658.9     13.4  
  9590                                                           # Execute minimum loan payments
  9591                                                           forecast_df.loc[forecast_df.Date == date_str] = self.executeLoanMinimumPayments(account_set,
  9592       228   49022661.0 215011.7     17.8                                                                                                  forecast_df[
  9593       228      31940.0    140.1      0.0                                                                                                      forecast_df.Date == date_str])
  9594       114      25858.0    226.8      0.0  
  9595                                                           # Sync after loan payments
  9596                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9597       114   36104643.0 316707.4     13.1  
  9598                                                           # Execute credit card minimum payments
  9599                                                           forecast_df.loc[forecast_df.Date == date_str] = self.executeCreditCardMinimumPayments(forecast_df,
  9600       228   15603294.0  68435.5      5.7                                                                                                        account_set,
  9601       114         44.0      0.4      0.0                                                                                                        forecast_df[
  9602       228      32194.0    141.2      0.0                                                                                                            forecast_df.Date == date_str])
  9603       114      26851.0    235.5      0.0  
  9604                                                           # Final sync for the day
  9605                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9606       114   36048563.0 316215.5     13.1  
  9607                                                       except ValueError as e:
  9608                                                           error_message = str(e.args)
  9609                                                           # Handle specific account boundary violations
  9610                                                           if re.search('.*Account boundaries were violated.*',
  9611                                                                        error_message) and not raise_satisfice_failed_exception:
  9612                                                               self.end_date = datetime.datetime.strptime(date_str, '%Y%m%d') - datetime.timedelta(days=1)
  9613                                           
  9614                                                               log_in_color(logger, 'cyan', 'error', 'Account Boundaries were violated', self.log_stack_depth)
  9615                                                               log_in_color(logger, 'cyan', 'error', error_message, self.log_stack_depth)
  9616                                                               log_in_color(logger, 'cyan', 'error', 'State at failure:', self.log_stack_depth)
  9617                                                               log_in_color(logger, 'cyan', 'error', forecast_df.to_string(), self.log_stack_depth)
  9618                                           
  9619                                                               self.log_stack_depth -= 1
  9620                                                               return forecast_df
  9621                                                           else:
  9622                                                               raise e
  9623                                           
  9624                                                   self.log_stack_depth -= 1
  9625         3          7.0      2.3      0.0          return forecast_df  # satisfice_success = True

Total time: 408.331 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: computeOptimalForecast at line 9628

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9628                                               def computeOptimalForecast(self, start_date_YYYYMMDD, end_date_YYYYMMDD, confirmed_df, proposed_df, deferred_df,
  9629                                                                          skipped_df, account_set, memo_rule_set, raise_satisfice_failed_exception=True,
  9630                                                                          progress_bar=None):
  9631                                                   self.log_stack_depth += 1
  9632         3         11.0      3.7      0.0  
  9633                                                   # Reset index for all input DataFrames to ensure clean processing
  9634                                                   for df in [confirmed_df, proposed_df, deferred_df, skipped_df]:
  9635        15         12.0      0.8      0.0              df.reset_index(drop=True, inplace=True)
  9636        12        791.0     65.9      0.0  
  9637                                                   # Generate the list of days for the forecast, excluding the first day
  9638                                                   all_days = pd.date_range(
  9639         6       1883.0    313.8      0.0              datetime.datetime.strptime(start_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(days=1),
  9640         3        793.0    264.3      0.0              datetime.datetime.strptime(end_date_YYYYMMDD, '%Y%m%d')
  9641         3        145.0     48.3      0.0          )
  9642                                                   all_days = [d.strftime('%Y%m%d') for d in all_days]
  9643         3       1021.0    340.3      0.0  
  9644                                                   # Initialize the forecast DataFrame with the first day's account balances
  9645                                                   forecast_df = self.getInitialForecastRow(start_date_YYYYMMDD, account_set)
  9646         3     118574.0  39524.7      0.0  
  9647                                                   # Attempt to satisfice (execute priority 1 transactions for each day)
  9648                                                   satisfice_df = self.satisfice(
  9649         6  274690631.0    5e+07     67.3              all_days, confirmed_df, account_set, memo_rule_set, forecast_df, raise_satisfice_failed_exception,
  9650         3          3.0      1.0      0.0              progress_bar
  9651         3          1.0      0.3      0.0          )
  9652                                           
  9653                                                   # Check if satisfice succeeded by verifying the last date in the forecast
  9654                                                   satisfice_success = satisfice_df.tail(1)['Date'].iat[0] == end_date_YYYYMMDD
  9655         3        371.0    123.7      0.0  
  9656                                                   # Update forecast DataFrame with the result of satisfice
  9657                                                   forecast_df = satisfice_df
  9658         3         17.0      5.7      0.0  
  9659                                                   if satisfice_success:
  9660         3          0.0      0.0      0.0              # Log success message when satisfice completes successfully at the top level
  9661                                                       if not raise_satisfice_failed_exception:
  9662         3          0.0      0.0      0.0                  log_in_color(logger, 'white', 'info', 'Satisfice succeeded.')
  9663         1         26.0     26.0      0.0                  log_in_color(logger, 'white', 'debug', satisfice_df.to_string())
  9664         1       7818.0   7818.0      0.0  
  9665                                                       # Assess potential optimizations across all transaction levels
  9666                                                       forecast_df, skipped_df, confirmed_df, deferred_df = self.assessPotentialOptimizations(
  9667         6  133509073.0    2e+07     32.7                  forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df,
  9668         3          2.0      0.7      0.0                  raise_satisfice_failed_exception, progress_bar
  9669         3          0.0      0.0      0.0              )
  9670                                                   else:
  9671                                                       # Handle satisfice failure: clean up unprocessed transactions
  9672                                                       if not raise_satisfice_failed_exception:
  9673                                                           log_in_color(logger, 'white', 'debug', 'Satisfice failed.')
  9674                                           
  9675                                                       confirmed_df, deferred_df, skipped_df = self.cleanUpAfterFailedSatisfice(
  9676                                                           confirmed_df, proposed_df, deferred_df, skipped_df
  9677                                                       )
  9678                                           
  9679                                                   # Decrement the log stack depth as we exit this method
  9680                                                   self.log_stack_depth -= 1
  9681         2          2.0      1.0      0.0  
  9682                                                   # Return the forecast and updated DataFrames
  9683                                                   return [forecast_df, skipped_df, confirmed_df, deferred_df]

