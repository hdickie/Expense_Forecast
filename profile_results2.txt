Timer unit: 1e-06 s

Total time: 316.296 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: runForecast at line 2040

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2040                                               @profile
  2041                                               def runForecast(self, log_level='WARNING', play_notification_sound=False):
  2042                                                   #print('Starting Forecast #'+str(self.unique_id))
  2043         1         19.0     19.0      0.0          self.start_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2044                                           
  2045         1          0.0      0.0      0.0          if log_level == 'DEBUG':
  2046                                                       loglevel = logging.DEBUG
  2047         1          1.0      1.0      0.0          elif log_level == 'INFO':
  2048                                                       loglevel = logging.INFO
  2049         1          1.0      1.0      0.0          elif log_level == 'WARNING':
  2050         1          2.0      2.0      0.0              loglevel = logging.WARNING
  2051                                                   elif log_level == 'ERROR':
  2052                                                       loglevel = logging.ERROR
  2053                                                   elif log_level == 'CRITICAL':
  2054                                                       loglevel = logging.CRITICAL
  2055                                                   else:
  2056                                                       loglevel = logging.WARNING
  2057         1         15.0     15.0      0.0          logger.setLevel(loglevel)
  2058                                           
  2059         1         26.0     26.0      0.0          log_in_color(logger, 'white', 'info', 'Starting Forecast '+str(self.unique_id))
  2060                                           
  2061                                                   # this is the place to estimate runtime to appropriately update progress bar
  2062                                                   # It could be for each day each priority, but then priority > 1 would have thr bar stop every time it looks ahead
  2063                                                   # I think the way to do it is have the bar be relative to the worst case
  2064                                                   # deferrable are really fucky. we will assume a deferral cadence of 2 weeks though this can be accounted for
  2065                                                   # if a deferral cadence is implemented #todo
  2066                                                   # I'm not sold that it would be that useful though. A look-ahead on income seems reasonable
  2067                                                   # therefore, each p2+ txn may fail, and each partial_payment may fail twice, and each deferrable may fail n times (where n is accounting for every 2 weeks
  2068                                                   #
  2069         1         65.0     65.0      0.0          sd = datetime.datetime.strptime(self.start_date_YYYYMMDD, '%Y%m%d')
  2070         1         35.0     35.0      0.0          ed = datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d')
  2071         1          1.0      1.0      0.0          predicted_satisfice_runtime_in_simulated_days = (ed - sd).days
  2072                                                   # p2plus_txns_max_runtime_in_simulated_days = 0
  2073                                                   # for index, row in self.initial_proposed_df.iterrows():
  2074                                                   #     num_of_lookahead_days = ( ed - datetime.datetime.strptime(row.date.iat[0],'%Y%m%d') ).days
  2075                                                   #     if row.Deferrable:
  2076                                                   #         max_number_of_retries = math.floor(num_of_lookahead_days / 14)
  2077                                                   #         #each retry would be 2 weeks shorter. I'm thinking of it making a triangle shape
  2078                                                   #         #therefore, we add time * n / 2
  2079                                                   #         p2plus_txns_max_runtime_in_simulated_days += max_number_of_retries * num_of_lookahead_days / 2
  2080                                                   #     elif row.Partial_Payment_Allowed:
  2081                                                   #         p2plus_txns_max_runtime_in_simulated_days += 2 * num_of_lookahead_days
  2082                                                   #     else:
  2083                                                   #         p2plus_txns_max_runtime_in_simulated_days += num_of_lookahead_days
  2084                                                   # total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + p2plus_txns_max_runtime_in_simulated_days
  2085                                                   #
  2086                                                   # On second thought, I would rather deal wit ha stilted progress bar than figuring out how to track progress in recursion
  2087         1        128.0    128.0      0.0          no_of_p2plus_priority_levels = len(set(self.initial_proposed_df.Priority))
  2088         1          1.0      1.0      0.0          total_predicted_max_runtime_in_simulated_days = predicted_satisfice_runtime_in_simulated_days + predicted_satisfice_runtime_in_simulated_days * no_of_p2plus_priority_levels
  2089         1      21215.0  21215.0      0.0          progress_bar = tqdm.tqdm(range(total_predicted_max_runtime_in_simulated_days),total=total_predicted_max_runtime_in_simulated_days, desc=self.unique_id, disable=True) #disabled tqdm
  2090                                           
  2091         2  313287299.0    2e+08     99.0          forecast_df, skipped_df, confirmed_df, deferred_df = self.computeOptimalForecast(
  2092         1          3.0      3.0      0.0              start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2093         1          0.0      0.0      0.0              end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2094         1       2338.0   2338.0      0.0              confirmed_df=pd.DataFrame(self.initial_confirmed_df, copy=True),
  2095         1        134.0    134.0      0.0              proposed_df=pd.DataFrame(self.initial_proposed_df, copy=True),
  2096         1         81.0     81.0      0.0              deferred_df=pd.DataFrame(self.initial_deferred_df, copy=True),
  2097         1         67.0     67.0      0.0              skipped_df=pd.DataFrame(self.initial_skipped_df, copy=True),
  2098         1        848.0    848.0      0.0              account_set=copy.deepcopy(self.initial_account_set),
  2099         1       1101.0   1101.0      0.0              memo_rule_set=copy.deepcopy(self.initial_memo_rule_set),
  2100         1          1.0      1.0      0.0              raise_satisfice_failed_exception=False,progress_bar=progress_bar)
  2101                                           
  2102         1          1.0      1.0      0.0          self.forecast_df = forecast_df
  2103         1          1.0      1.0      0.0          self.skipped_df = skipped_df
  2104         1          0.0      0.0      0.0          self.confirmed_df = confirmed_df
  2105         1          0.0      0.0      0.0          self.deferred_df = deferred_df
  2106                                           
  2107         1         26.0     26.0      0.0          self.end_ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  2108         1    2914549.0    3e+06      0.9          self.appendSummaryLines()
  2109         1         13.0     13.0      0.0          self.evaluateMilestones()
  2110                                           
  2111         1         19.0     19.0      0.0          log_in_color(logger, 'white', 'info','Finished Forecast '+str(self.unique_id))
  2112         1      68307.0  68307.0      0.0          log_in_color(logger, 'white', 'info', self.forecast_df.to_string())
  2113                                                   # if play_notification_sound:
  2114                                                   #     notification_sounds.play_notification_sound()
  2115                                           
  2116                                                   #self.forecast_df.to_csv('./out//Forecast_' + self.unique_id + '.csv') #this is only the forecast not the whole ExpenseForecast object
  2117                                                   #self.writeToJSONFile() #this is the whole ExpenseForecast object #todo this should accept a path parameter

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: attemptTransaction at line 2412

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2412                                               @profile
  2413                                               def attemptTransaction(self, forecast_df, account_set, memo_set, confirmed_df, proposed_row_df):
  2414                                                   """
  2415                                                   Attempts to execute a proposed transaction and returns the hypothetical future state of the forecast
  2416                                                   if the transaction is permitted.
  2417                                           
  2418                                                   Parameters:
  2419                                                   - forecast_df: DataFrame containing the current forecast.
  2420                                                   - account_set: AccountSet object representing the current state of accounts.
  2421                                                   - memo_set: MemoSet object containing memo rules.
  2422                                                   - confirmed_df: DataFrame of confirmed transactions.
  2423                                                   - proposed_row: Series representing the proposed transaction.
  2424                                           
  2425                                                   Returns:
  2426                                                   - hypothetical_future_forecast: DataFrame representing the updated forecast if the transaction is permitted.
  2427                                           
  2428                                                   Raises:
  2429                                                   - ValueError: If an exception occurs that is not due to account boundary violations.
  2430                                                   """
  2431                                                   self.log_stack_depth += 1
  2432                                           
  2433                                                   try:
  2434                                                       # Prepare the proposed transaction DataFrame
  2435                                                       single_proposed_transaction_df = proposed_row_df.to_frame().T.copy()
  2436                                           
  2437                                                       # Combine the confirmed transactions with the proposed transaction
  2438                                                       updated_confirmed_df = pd.concat([confirmed_df, single_proposed_transaction_df], ignore_index=True)
  2439                                           
  2440                                                       # Create an empty DataFrame for proposed, deferred, and skipped transactions
  2441                                                       empty_df = pd.DataFrame(
  2442                                                           columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  2443                                           
  2444                                                       # Determine the transaction date and previous date
  2445                                                       txn_date = proposed_row_df['Date']
  2446                                                       txn_datetime = pd.to_datetime(txn_date, format='%Y%m%d')
  2447                                           
  2448                                                       # Find the previous date for synchronization
  2449                                                       previous_date = self.start_date_YYYYMMDD  # Optimization removed due to credit card prepayment considerations
  2450                                           
  2451                                                       # Synchronize the account set with the forecast on the previous date
  2452                                                       synced_account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, previous_date)
  2453                                           
  2454                                                       # Compute the hypothetical future forecast starting from the previous date
  2455                                                       hypothetical_future_forecast = self.computeOptimalForecast(
  2456                                                           start_date_YYYYMMDD=previous_date,
  2457                                                           end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2458                                                           confirmed_df=updated_confirmed_df,
  2459                                                           proposed_df=empty_df,
  2460                                                           deferred_df=empty_df,
  2461                                                           skipped_df=empty_df,
  2462                                                           account_set=synced_account_set,
  2463                                                           memo_rule_set=memo_set
  2464                                                       )[0]
  2465                                           
  2466                                                       # Exclude the first row since it's considered final and not part of the new forecast
  2467                                                       hypothetical_future_forecast = hypothetical_future_forecast.iloc[1:].copy()
  2468                                           
  2469                                                       # Extract past forecast rows before the transaction date
  2470                                                       past_forecast = forecast_df[forecast_df['Date'] < txn_date].copy()
  2471                                           
  2472                                                       # Combine past forecast with the hypothetical future forecast
  2473                                                       updated_forecast = pd.concat([past_forecast, hypothetical_future_forecast], ignore_index=True)
  2474                                           
  2475                                                       self.log_stack_depth -= 1
  2476                                           
  2477                                                       return updated_forecast  # Transaction is permitted
  2478                                           
  2479                                                   except ValueError as e:
  2480                                                       # Log the exception
  2481                                                       log_in_color(logger, 'red', 'debug', str(e), self.log_stack_depth)
  2482                                           
  2483                                                       # Reraise the exception if it's not due to account boundary violations
  2484                                                       if 'Account boundaries were violated' not in str(e):
  2485                                                           raise e
  2486                                           
  2487                                                       self.log_stack_depth -= 1
  2488                                           
  2489                                                       # Return None to indicate that the transaction is not permitted
  2490                                                       return None
  2491                                           
  2492                                           
  2493                                                   # #print('ENTER attemptTransaction '+proposed_row_df.Memo.iat[0])
  2494                                                   # # log_in_color(logger,'green','info','ENTER attemptTransaction( C:'+str(confirmed_df.shape[0])+' P:'+str(proposed_row_df.Memo)+')',self.log_stack_depth)
  2495                                                   # # log_in_color(logger, 'magenta', 'debug', 'forecast_df BEFORE:')
  2496                                                   # # log_in_color(logger, 'magenta', 'debug', forecast_df.to_string() )
  2497                                                   # self.log_stack_depth += 1
  2498                                                   # try:
  2499                                                   #     single_proposed_transaction_df = pd.DataFrame(copy.deepcopy(proposed_row_df)).T
  2500                                                   #     # print('single_proposed_transaction_df:')
  2501                                                   #     # print(single_proposed_transaction_df.to_string())
  2502                                                   #     not_yet_validated_confirmed_df = copy.deepcopy(pd.concat([confirmed_df, single_proposed_transaction_df]))
  2503                                                   #     empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  2504                                                   #
  2505                                                   #     # hypothetical_future_state_of_forecast = \
  2506                                                   #     #     self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  2507                                                   #     #                                 end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2508                                                   #     #                                 confirmed_df=not_yet_validated_confirmed_df,
  2509                                                   #     #                                 proposed_df=empty_df,
  2510                                                   #     #                                 deferred_df=empty_df,
  2511                                                   #     #                                 skipped_df=empty_df,
  2512                                                   #     #                                 account_set=copy.deepcopy(
  2513                                                   #     #                                     self.sync_account_set_w_forecast_day(account_set, forecast_df,
  2514                                                   #     #                                                                          self.start_date_YYYYMMDD)),
  2515                                                   #     #                                 memo_rule_set=memo_set)[0]
  2516                                                   #
  2517                                                   #     txn_date = proposed_row_df.Date
  2518                                                   #     d_sel_vec = ( datetime.datetime.strptime(d,'%Y%m%d') <= datetime.datetime.strptime(txn_date,'%Y%m%d') for d in forecast_df.Date )
  2519                                                   #     previous_row_df = forecast_df.loc[ d_sel_vec, : ].tail(2).head(1)
  2520                                                   #
  2521                                                   #     # log_in_color(logger, 'white', 'debug', 'previous_row_df:',self.log_stack_depth)
  2522                                                   #     # log_in_color(logger, 'white', 'debug', previous_row_df.to_string(),self.log_stack_depth)
  2523                                                   #
  2524                                                   #     #previous_date = previous_row_df.Date.iat[0]
  2525                                                   #     previous_date = self.start_date_YYYYMMDD #todo this optimization had to be removed bc of cc prepayment
  2526                                                   #
  2527                                                   #     #note that there may also be confirmed txns on the same day as the proposed txn
  2528                                                   #     # print('attempt transaction case 1 sync')
  2529                                                   #
  2530                                                   #     hypothetical_future_state_of_forecast_future_rows_only = \
  2531                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=previous_date,
  2532                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  2533                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  2534                                                   #                                     proposed_df=empty_df,
  2535                                                   #                                     deferred_df=empty_df,
  2536                                                   #                                     skipped_df=empty_df,
  2537                                                   #                                     account_set=copy.deepcopy(
  2538                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,previous_date)),
  2539                                                   #                                     memo_rule_set=memo_set)[0]
  2540                                                   #
  2541                                                   #     #we started the sub-forecast on the previous date, bc that day is considered final
  2542                                                   #     #therefore, we can drop it from the concat bc it is not new
  2543                                                   #     hypothetical_future_state_of_forecast_future_rows_only = hypothetical_future_state_of_forecast_future_rows_only.iloc[1:,:]
  2544                                                   #
  2545                                                   #     # log_in_color(logger,'white','debug','hypothetical_future_state_of_forecast_future_rows_only:',self.log_stack_depth)
  2546                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2547                                                   #
  2548                                                   #     date_array = [ datetime.datetime.strptime(d,'%Y%m%d') for d in forecast_df.Date ]
  2549                                                   #     row_sel_vec = [ d < datetime.datetime.strptime(txn_date,'%Y%m%d') for d in date_array ]
  2550                                                   #
  2551                                                   #     past_confirmed_forecast_rows_df = forecast_df[ row_sel_vec ]
  2552                                                   #
  2553                                                   #     # log_in_color(logger, 'white', 'debug', 'past_confirmed_forecast_rows_df:', self.log_stack_depth)
  2554                                                   #     # log_in_color(logger, 'white', 'debug', past_confirmed_forecast_rows_df.to_string(), self.log_stack_depth)
  2555                                                   #     # log_in_color(logger, 'white', 'debug', 'hypothetical_future_state_of_forecast_future_rows_only:', self.log_stack_depth)
  2556                                                   #     # log_in_color(logger, 'white', 'debug', hypothetical_future_state_of_forecast_future_rows_only.to_string(),self.log_stack_depth)
  2557                                                   #
  2558                                                   #     hypothetical_future_state_of_forecast = pd.concat([past_confirmed_forecast_rows_df,hypothetical_future_state_of_forecast_future_rows_only])
  2559                                                   #     # log_in_color(logger, 'green', 'info', hypothetical_future_state_of_forecast.to_string(), self.log_stack_depth)
  2560                                                   #
  2561                                                   #     self.log_stack_depth -= 1
  2562                                                   #
  2563                                                   #     #log_in_color(logger, 'green', 'debug',hypothetical_future_state_of_forecast.to_string())
  2564                                                   #     # log_in_color(logger, 'magenta', 'debug', 'forecast_df AFTER:')
  2565                                                   #     # log_in_color(logger, 'magenta', 'debug', hypothetical_future_state_of_forecast.to_string())
  2566                                                   #     # log_in_color(logger, 'green', 'info', 'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (SUCCESS)', self.log_stack_depth)
  2567                                                   #     #print('EXIT attemptTransaction')
  2568                                                   #     return hypothetical_future_state_of_forecast #transaction is permitted
  2569                                                   # except ValueError as e:
  2570                                                   #     self.log_stack_depth -= 5  # several decrements were skipped over by the exception
  2571                                                   #     # log_in_color(logger, 'white', 'debug', 'forecast_df AFTER:')
  2572                                                   #     # log_in_color(logger, 'white', 'debug', forecast_df.to_string())
  2573                                                   #     log_in_color(logger, 'red', 'debug',str(e), self.log_stack_depth)
  2574                                                   #     # log_in_color(logger, 'red', 'debug', account_set.getAccounts().to_string(), self.log_stack_depth)
  2575                                                   #     # log_in_color(logger, 'red', 'info',
  2576                                                   #     #              'EXIT attemptTransaction(' + str(proposed_row_df.Memo) + ')' + ' (FAIL)', self.log_stack_depth)
  2577                                                   #     # print(e.args)
  2578                                                   #     #print('EXIT attemptTransaction')
  2579                                                   #     if re.search('.*Account boundaries were violated.*',str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  2580                                                   #         raise e

Total time: 128.782 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processConfirmedTransactions at line 2582

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2582                                               @profile
  2583                                               def processConfirmedTransactions(self, forecast_df, relevant_confirmed_df, memo_set, account_set, date_YYYYMMDD):
  2584                                                   # log_in_color(logger, 'green', 'debug', 'ENTER processConfirmedTransactions( C:'+str(relevant_confirmed_df.shape[0])+' ) '+str(date_YYYYMMDD), self.log_stack_depth)
  2585       324        395.0      1.2      0.0          self.log_stack_depth += 1
  2586                                                   # print('BEGIN processConfirmedTransactions('+date_YYYYMMDD+')')
  2587                                           
  2588       780      49745.0     63.8      0.0          for confirmed_index, confirmed_row in relevant_confirmed_df.iterrows():
  2589                                                       # print('    '+str(confirmed_row.Memo)+' '+str(confirmed_row.Amount))
  2590       457    8766422.0  19182.5      6.8              relevant_memo_rule_set = memo_set.findMatchingMemoRule(confirmed_row.Memo, confirmed_row.Priority)
  2591       457     760818.0   1664.8      0.6              memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  2592                                           
  2593       457      17121.0     37.5      0.0              income_flag = self.checkIfTxnIsIncome(confirmed_row)
  2594                                           
  2595       914   12934492.0  14151.5     10.0              account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  2596       457       9228.0     20.2      0.0                                             Account_To=memo_rule_row.Account_To,
  2597       457       7503.0     16.4      0.0                                             Amount=confirmed_row.Amount,
  2598       457        169.0      0.4      0.0                                             income_flag=income_flag)
  2599                                           
  2600       912  106235123.0 116485.9     82.5              forecast_df = self.updateBalancesAndMemo(forecast_df, account_set, confirmed_row, memo_rule_row,
  2601       456        158.0      0.3      0.0                                                       date_YYYYMMDD)
  2602                                           
  2603       323        640.0      2.0      0.0          self.log_stack_depth -= 1
  2604                                                   # log_in_color(logger, 'green', 'debug', 'EXIT processConfirmedTransactions()', self.log_stack_depth)
  2605                                                   # print('EXIT processConfirmedTransactions(' + date_YYYYMMDD + ')')
  2606       323         99.0      0.3      0.0          return forecast_df

Total time: 0.302289 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getTotalPrepaidInCreditCardBillingCycle at line 2963

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2963                                               @profile
  2964                                               def getTotalPrepaidInCreditCardBillingCycle(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  2965                                                   """
  2966                                                   Calculates the total prepaid amount made towards a credit card in the billing cycle up to the given date.
  2967                                           
  2968                                                   Parameters:
  2969                                                   - account_name (str): The name of the credit card account.
  2970                                                   - account_set (AccountSet): The account set containing account information.
  2971                                                   - forecast_df (pd.DataFrame): The forecast DataFrame with financial data.
  2972                                                   - date_YYYYMMDD (str): The current date in 'YYYYMMDD' format.
  2973                                           
  2974                                                   Returns:
  2975                                                   - float: The total prepaid amount in the current billing cycle.
  2976                                                   """
  2977                                                   # Extract the base account name (without sub-accounts)
  2978        10         14.0      1.4      0.0          base_account_name = account_name.split(':')[0]
  2979                                           
  2980                                                   # Filter the account row for the given account name and type
  2981        10     264651.0  26465.1     87.5          accounts_df = account_set.getAccounts()
  2982        20       5524.0    276.2      1.8          account_row = accounts_df[
  2983        20       5410.0    270.5      1.8              (accounts_df['Name'].str.startswith(base_account_name)) &
  2984        10       2250.0    225.0      0.7              (accounts_df['Account_Type'] == 'credit prev stmt bal')
  2985                                                       ]
  2986                                           
  2987        10         90.0      9.0      0.0          if account_row.empty:
  2988                                                       raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  2989                                           
  2990                                                   # Get the billing start date
  2991        10        788.0     78.8      0.3          billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  2992        10       3132.0    313.2      1.0          billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  2993                                           
  2994                                                   # Convert the current date to datetime
  2995        10       2430.0    243.0      0.8          current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  2996                                           
  2997                                                   # Generate billing dates up to the current date
  2998        20         17.0      0.8      0.0          num_months = (current_date.year - billing_start_date.year) * 12 + (
  2999        10          5.0      0.5      0.0                      current_date.month - billing_start_date.month)
  3000        10       6272.0    627.2      2.1          billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 1, freq='MS').strftime('%Y%m%d')
  3001                                           
  3002                                                   # Determine the start and end of the billing cycle
  3003        10         37.0      3.7      0.0          if billing_dates.empty:
  3004                                                       billing_cycle_start_date = billing_start_date_str
  3005                                                   else:
  3006        10         35.0      3.5      0.0              billing_cycle_start_date = billing_dates[-1]
  3007                                           
  3008                                                   # Define the time window to search for payments
  3009        10        514.0     51.4      0.2          lookback_period_start = (current_date - pd.Timedelta(days=35)).strftime('%Y%m%d')
  3010        10          6.0      0.6      0.0          lookback_period_end = date_YYYYMMDD
  3011                                           
  3012                                                   # Filter forecast_df for the relevant date range
  3013        20       2103.0    105.2      0.7          date_filtered_df = forecast_df[
  3014        20       3221.0    161.1      1.1              (forecast_df['Date'] > billing_cycle_start_date) &
  3015        10       1605.0    160.5      0.5              (forecast_df['Date'] <= lookback_period_end)
  3016                                                       ]
  3017                                           
  3018                                                   # Check for additional credit card payments in the memo directives
  3019        10         14.0      1.4      0.0          def extract_payment_amount(memo):
  3020                                                       matches = re.findall(r'ADDTL CC PAYMENT \((.*?)\$\s*([0-9]*\.[0-9]{1,2})\)', memo)
  3021                                                       total = 0.0
  3022                                                       for acc_name, amount_str in matches:
  3023                                                           acc_name = acc_name.replace('-', '').strip()
  3024                                                           if acc_name == account_row['Name'].iloc[0].replace('-', '').strip():
  3025                                                               try:
  3026                                                                   amount = float(amount_str)
  3027                                                                   total += amount
  3028                                                               except ValueError:
  3029                                                                   continue
  3030                                                       return total
  3031                                           
  3032                                                   # Calculate the total prepaid amount
  3033        10       4167.0    416.7      1.4          total_prepaid_amount = date_filtered_df['Memo Directives'].apply(extract_payment_amount).sum()
  3034                                           
  3035        10          4.0      0.4      0.0          return total_prepaid_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getFutureMinPaymentAmount at line 3118

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3118                                               @profile
  3119                                               def getFutureMinPaymentAmount(self, account_name, account_set, forecast_df, date_YYYYMMDD):
  3120                                                   """
  3121                                                   Calculates the future minimum payment amount for a given credit card account starting from a specific date.
  3122                                           
  3123                                                   Parameters:
  3124                                                   - account_name (str): The name of the credit card account.
  3125                                                   - account_set (AccountSet): The account set containing account information.
  3126                                                   - forecast_df (pd.DataFrame): The forecast DataFrame containing financial data.
  3127                                                   - date_YYYYMMDD (str): The date from which to start the calculation, in 'YYYYMMDD' format.
  3128                                           
  3129                                                   Returns:
  3130                                                   - float: The minimum payment amount due in the future, or 0.0 if no payment is due.
  3131                                                   """
  3132                                                   import pandas as pd
  3133                                           
  3134                                                   # Extract the base account name (before any colons)
  3135                                                   base_account_name = account_name.split(':')[0]
  3136                                           
  3137                                                   # Get the account row for the specified account name and account type 'credit prev stmt bal'
  3138                                                   accounts_df = account_set.getAccounts()
  3139                                                   account_row = accounts_df[
  3140                                                       (accounts_df['Name'].str.startswith(base_account_name)) &
  3141                                                       (accounts_df['Account_Type'] == 'credit prev stmt bal')
  3142                                                       ]
  3143                                           
  3144                                                   if account_row.empty:
  3145                                                       raise ValueError(f"Account '{account_name}' with type 'credit prev stmt bal' not found in account_set.")
  3146                                           
  3147                                                   # Get the forecast row for the specified date
  3148                                                   current_forecast_row_df = forecast_df[forecast_df['Date'] == date_YYYYMMDD]
  3149                                           
  3150                                                   if current_forecast_row_df.empty:
  3151                                                       raise ValueError(f"Date '{date_YYYYMMDD}' not found in forecast DataFrame.")
  3152                                           
  3153                                                   # Check if there is a minimum payment on the current date
  3154                                                   memo_directives = current_forecast_row_df['Memo Directives'].iat[0]
  3155                                                   min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3156                                           
  3157                                                   if min_payment_amount > 0:
  3158                                                       return min_payment_amount
  3159                                           
  3160                                                   # If no minimum payment on the current date, find the next billing date
  3161                                           
  3162                                                   # Convert dates to datetime objects
  3163                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3164                                                   billing_start_date_str = account_row['Billing_Start_Date'].iloc[0]
  3165                                                   billing_start_date = pd.to_datetime(billing_start_date_str, format='%Y%m%d')
  3166                                           
  3167                                                   # Generate billing dates starting from the billing start date
  3168                                                   if current_date < billing_start_date:
  3169                                                       next_billing_date = billing_start_date
  3170                                                   else:
  3171                                                       # Calculate the number of months between the billing start date and current date
  3172                                                       num_months = (current_date.year - billing_start_date.year) * 12 + (
  3173                                                                   current_date.month - billing_start_date.month)
  3174                                                       billing_dates = pd.date_range(start=billing_start_date, periods=num_months + 2, freq='MS')
  3175                                           
  3176                                                       # Find the next billing date after the current date
  3177                                                       future_billing_dates = billing_dates[billing_dates > current_date]
  3178                                                       if not future_billing_dates.empty:
  3179                                                           next_billing_date = future_billing_dates.min()
  3180                                                       else:
  3181                                                           # If no future billing dates are found, set next billing date to billing start date
  3182                                                           next_billing_date = billing_start_date
  3183                                           
  3184                                                   # Check if next billing date is beyond the forecast end date
  3185                                                   forecast_end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3186                                                   if next_billing_date > forecast_end_date:
  3187                                                       return 0.0
  3188                                           
  3189                                                   # Get the forecast row for the next billing date
  3190                                                   next_billing_date_str = next_billing_date.strftime('%Y%m%d')
  3191                                                   next_forecast_row_df = forecast_df[forecast_df['Date'] == next_billing_date_str]
  3192                                           
  3193                                                   if next_forecast_row_df.empty:
  3194                                                       return 0.0
  3195                                           
  3196                                                   # Extract minimum payment amount from the memo directives on the next billing date
  3197                                                   memo_directives = next_forecast_row_df['Memo Directives'].iat[0]
  3198                                                   min_payment_amount = self._extract_min_payment_amount(memo_directives, base_account_name)
  3199                                           
  3200                                                   return min_payment_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _extract_min_payment_amount at line 3202

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3202                                               @profile
  3203                                               def _extract_min_payment_amount(self, memo_directives, base_account_name):
  3204                                                   """
  3205                                                   Helper function to extract the minimum payment amount from memo directives.
  3206                                           
  3207                                                   Parameters:
  3208                                                   - memo_directives (str): The memo directives string.
  3209                                                   - base_account_name (str): The base account name.
  3210                                           
  3211                                                   Returns:
  3212                                                   - float: The total minimum payment amount found in the memo directives.
  3213                                                   """
  3214                                                   import re
  3215                                           
  3216                                                   min_payment_amount = 0.0
  3217                                                   memo_items = memo_directives.split(';')
  3218                                                   for memo in memo_items:
  3219                                                       memo = memo.strip()
  3220                                                       if not memo:
  3221                                                           continue
  3222                                                       # Check for minimum payment directives for both previous and current statement balances
  3223                                                       if (f'CC MIN PAYMENT ({base_account_name}: Prev Stmt Bal' in memo or
  3224                                                               f'CC MIN PAYMENT ({base_account_name}: Curr Stmt Bal' in memo):
  3225                                                           match = re.search(r'\(.*-\$(\d+(\.\d{1,2})?)\)', memo)
  3226                                                           if match:
  3227                                                               amount = float(match.group(1))
  3228                                                               min_payment_amount += amount
  3229                                                   return min_payment_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processProposedTransactions at line 3536

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3536                                               @profile
  3537                                               def processProposedTransactions(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df,
  3538                                                                                 relevant_proposed_df, priority_level):
  3539                                                   """
  3540                                                   Processes proposed transactions by attempting to execute them, handling partial payments, deferrals,
  3541                                                   and updating the forecast accordingly.
  3542                                           
  3543                                                   Parameters:
  3544                                                   - account_set: AccountSet object representing the current state of accounts.
  3545                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3546                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3547                                                   - memo_set: MemoSet object containing memo rules.
  3548                                                   - confirmed_df: DataFrame of confirmed transactions.
  3549                                                   - relevant_proposed_df: DataFrame of proposed transactions for the current date.
  3550                                                   - priority_level: Integer representing the priority level.
  3551                                           
  3552                                                   Returns:
  3553                                                   - forecast_df: Updated forecast DataFrame.
  3554                                                   - new_confirmed_df: DataFrame of newly confirmed transactions.
  3555                                                   - new_deferred_df: DataFrame of newly deferred transactions.
  3556                                                   - new_skipped_df: DataFrame of newly skipped transactions.
  3557                                                   """
  3558                                                   # Increment the log stack depth
  3559                                                   self.log_stack_depth += 1
  3560                                           
  3561                                                   # Initialize DataFrames to hold new deferred, skipped, and confirmed transactions
  3562                                                   new_deferred_df = relevant_proposed_df.iloc[0:0].copy()  # Empty DataFrame with the same schema
  3563                                                   new_skipped_df = relevant_proposed_df.iloc[0:0].copy()
  3564                                                   new_confirmed_df = relevant_proposed_df.iloc[0:0].copy()
  3565                                           
  3566                                                   # If there are no proposed transactions, return early
  3567                                                   if relevant_proposed_df.empty:
  3568                                                       self.log_stack_depth -= 1
  3569                                                       return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df
  3570                                           
  3571                                                   # Iterate over each proposed transaction
  3572                                                   for proposed_index, proposed_row in relevant_proposed_df.iterrows():
  3573                                                       # Find the matching memo rule for the proposed transaction
  3574                                                       memo_rule_set = memo_set.findMatchingMemoRule(proposed_row['Memo'], proposed_row['Priority'])
  3575                                                       memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  3576                                           
  3577                                                       # Attempt to execute the transaction
  3578                                                       result = self.attemptTransaction(
  3579                                                           forecast_df=forecast_df,
  3580                                                           account_set=copy.deepcopy(account_set),
  3581                                                           memo_set=memo_set,
  3582                                                           confirmed_df=confirmed_df,
  3583                                                           proposed_row_df=proposed_row
  3584                                                       )
  3585                                           
  3586                                           
  3587                                                       # Check if the transaction is permitted (returns a DataFrame if successful)
  3588                                                       transaction_permitted = isinstance(result, pd.DataFrame)
  3589                                           
  3590                                                       if transaction_permitted:
  3591                                                           # Transaction is permitted; update the hypothetical future forecast and account set
  3592                                                           hypothetical_forecast = result
  3593                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3594                                                       else:
  3595                                                           hypothetical_forecast = None
  3596                                           
  3597                                                       # Handle partial payments if transaction is not permitted and partial payments are allowed
  3598                                                       if not transaction_permitted and proposed_row['Partial_Payment_Allowed']:
  3599                                                           # Get the minimum future available balances
  3600                                                           min_future_balances = self.getMinimumFutureAvailableBalances(account_set, forecast_df, date_YYYYMMDD)
  3601                                                           max_available_funds = min_future_balances.get(memo_rule_row['Account_From'], 0.0)
  3602                                           
  3603                                                           # Determine the maximum amount that can be transferred to the destination account
  3604                                                           reduced_amount = self.calculate_reduced_amount(
  3605                                                               account_set=account_set,
  3606                                                               memo_rule_row=memo_rule_row,
  3607                                                               max_available_funds=max_available_funds,
  3608                                                               forecast_df=forecast_df,
  3609                                                               date_YYYYMMDD=date_YYYYMMDD
  3610                                                           )
  3611                                           
  3612                                                           # Attempt the transaction with the reduced amount if it's greater than zero
  3613                                                           if reduced_amount > 0:
  3614                                                               proposed_row['Amount'] = reduced_amount
  3615                                           
  3616                                                               result = self.attemptTransaction(
  3617                                                                   forecast_df=forecast_df,
  3618                                                                   account_set=copy.deepcopy(account_set),
  3619                                                                   memo_set=memo_set,
  3620                                                                   confirmed_df=confirmed_df,
  3621                                                                   proposed_row_df=proposed_row
  3622                                                               )
  3623                                           
  3624                                                               transaction_permitted = isinstance(result, pd.DataFrame)
  3625                                           
  3626                                                               if transaction_permitted:
  3627                                                                   hypothetical_forecast = result
  3628                                                                   account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3629                                                               else:
  3630                                                                   hypothetical_forecast = None
  3631                                           
  3632                                                       # Handle deferrable transactions if not permitted
  3633                                                       if not transaction_permitted and proposed_row['Deferrable']:
  3634                                                           # Find the next income date
  3635                                                           next_income_date = self.find_next_income_date(forecast_df, date_YYYYMMDD)
  3636                                           
  3637                                                           # Update the date of the proposed transaction to the next income date
  3638                                                           proposed_row['Date'] = next_income_date
  3639                                           
  3640                                                           # Add the transaction to the deferred DataFrame
  3641                                                           new_deferred_df = pd.concat([new_deferred_df, proposed_row.to_frame().T], ignore_index=True)
  3642                                           
  3643                                                       elif not transaction_permitted and not proposed_row['Deferrable']:
  3644                                                           # Add the transaction to the skipped DataFrame
  3645                                                           new_skipped_df = pd.concat([new_skipped_df, proposed_row.to_frame().T], ignore_index=True)
  3646                                           
  3647                                                       elif transaction_permitted:
  3648                                                           # Transaction is permitted; execute it and update the forecast and account set
  3649                                                           if priority_level > 1:
  3650                                                               account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  3651                                           
  3652                                                           account_set.executeTransaction(
  3653                                                               Account_From=memo_rule_row['Account_From'],
  3654                                                               Account_To=memo_rule_row['Account_To'],
  3655                                                               Amount=proposed_row['Amount'],
  3656                                                               income_flag=False
  3657                                                           )
  3658                                           
  3659                                                           # Add the transaction to the confirmed DataFrame
  3660                                                           new_confirmed_df = pd.concat([new_confirmed_df, proposed_row.to_frame().T], ignore_index=True)
  3661                                           
  3662                                                           # Update the forecast DataFrame with the hypothetical future forecast
  3663                                                           forecast_df = self.update_forecast_with_hypothetical(
  3664                                                               forecast_df=forecast_df,
  3665                                                               hypothetical_forecast=hypothetical_forecast,
  3666                                                               date_YYYYMMDD=date_YYYYMMDD
  3667                                                           )
  3668                                           
  3669                                                           # Update the account balances in the forecast DataFrame for the current date
  3670                                                           self.update_forecast_balances(
  3671                                                               forecast_df=forecast_df,
  3672                                                               account_set=account_set,
  3673                                                               date_YYYYMMDD=date_YYYYMMDD
  3674                                                           )
  3675                                                       else:
  3676                                                           # This case should not occur; raise an error
  3677                                                           raise ValueError(
  3678                                                               "Unexpected case in process_proposed_transactions:\n"
  3679                                                               f"transaction_permitted: {transaction_permitted}\n"
  3680                                                               f"Deferrable: {proposed_row['Deferrable']}\n"
  3681                                                               f"Partial_Payment_Allowed: {proposed_row['Partial_Payment_Allowed']}\n"
  3682                                                           )
  3683                                           
  3684                                                   # Decrement the log stack depth
  3685                                                   self.log_stack_depth -= 1
  3686                                           
  3687                                                   return forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculate_reduced_amount at line 3689

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3689                                               @profile
  3690                                               def calculate_reduced_amount(self, account_set, memo_rule_row, max_available_funds, forecast_df, date_YYYYMMDD):
  3691                                                   """
  3692                                                   Calculates the maximum amount that can be transferred based on available funds and account types.
  3693                                           
  3694                                                   Parameters:
  3695                                                   - account_set: AccountSet object representing the current state of accounts.
  3696                                                   - memo_rule_row: Series representing the memo rule for the transaction.
  3697                                                   - max_available_funds: Float representing the maximum available funds from the source account.
  3698                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3699                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3700                                           
  3701                                                   Returns:
  3702                                                   - reduced_amount: Float representing the reduced transaction amount.
  3703                                                   """
  3704                                                   # Get the account types for the destination account
  3705                                                   account_base_names = account_set.getAccounts()['Name'].apply(lambda x: x.split(':')[0])
  3706                                                   destination_accounts = account_set.getAccounts()[account_base_names == memo_rule_row['Account_To']]
  3707                                                   account_types = destination_accounts['Account_Type'].tolist()
  3708                                           
  3709                                                   # Determine the account type
  3710                                                   if 'credit curr stmt bal' in account_types and 'credit prev stmt bal' in account_types:
  3711                                                       account_type = 'credit'
  3712                                                   elif 'principal balance' in account_types and 'interest' in account_types:
  3713                                                       account_type = 'loan'
  3714                                                   elif len(account_types) == 1 and account_types[0] == 'checking':
  3715                                                       account_type = 'checking'
  3716                                                   else:
  3717                                                       account_type = 'none'
  3718                                           
  3719                                                   # Calculate the maximum amount that can be transferred to the destination account
  3720                                                   if account_type == 'credit':
  3721                                                       total_balance = destination_accounts['Balance'].sum()
  3722                                                       future_min_payment = self.getFutureMinPaymentAmount(
  3723                                                           account_name=memo_rule_row['Account_To'],
  3724                                                           account_set=account_set,
  3725                                                           forecast_df=forecast_df,
  3726                                                           date_YYYYMMDD=date_YYYYMMDD
  3727                                                       )
  3728                                                       reduced_amount = min(max_available_funds, total_balance)
  3729                                                   elif account_type in ['checking', 'loan']:
  3730                                                       total_balance = destination_accounts['Balance'].sum()
  3731                                                       reduced_amount = min(max_available_funds, total_balance)
  3732                                                   elif account_type == 'none':
  3733                                                       reduced_amount = max_available_funds
  3734                                                   else:
  3735                                                       raise ValueError('Invalid account type in calculate_reduced_amount')
  3736                                           
  3737                                                   return reduced_amount

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: find_next_income_date at line 3739

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3739                                               @profile
  3740                                               def find_next_income_date(self, forecast_df, date_YYYYMMDD):
  3741                                                   """
  3742                                                   Finds the next income date after the given date.
  3743                                           
  3744                                                   Parameters:
  3745                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3746                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3747                                           
  3748                                                   Returns:
  3749                                                   - next_income_date: String representing the next income date in 'YYYYMMDD' format.
  3750                                                   """
  3751                                                   current_date = pd.to_datetime(date_YYYYMMDD, format='%Y%m%d')
  3752                                           
  3753                                                   # Filter future dates
  3754                                                   future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  3755                                           
  3756                                                   # Filter rows where the memo indicates income
  3757                                                   income_rows = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  3758                                           
  3759                                                   if not income_rows.empty:
  3760                                                       next_income_date = income_rows['Date'].iloc[0]
  3761                                                   else:
  3762                                                       # If no future income dates, set to one day after the forecast end date
  3763                                                       end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  3764                                                       next_income_date = (end_date + pd.Timedelta(days=1)).strftime('%Y%m%d')
  3765                                           
  3766                                                   return next_income_date

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_with_hypothetical at line 3768

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3768                                               @profile
  3769                                               def update_forecast_with_hypothetical(self, forecast_df, hypothetical_forecast, date_YYYYMMDD):
  3770                                                   """
  3771                                                   Updates the forecast DataFrame with the hypothetical future forecast starting from the given date.
  3772                                           
  3773                                                   Parameters:
  3774                                                   - forecast_df: DataFrame containing the current forecast data.
  3775                                                   - hypothetical_forecast: DataFrame containing the hypothetical future forecast.
  3776                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3777                                           
  3778                                                   Returns:
  3779                                                   - Updated forecast_df.
  3780                                                   """
  3781                                                   # Split the forecast into past and future
  3782                                                   past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  3783                                                   future_forecast = hypothetical_forecast[hypothetical_forecast['Date'] >= date_YYYYMMDD]
  3784                                           
  3785                                                   # Concatenate the past and updated future forecasts
  3786                                                   updated_forecast = pd.concat([past_forecast, future_forecast], ignore_index=True)
  3787                                           
  3788                                                   # Ensure no duplicate dates
  3789                                                   updated_forecast = updated_forecast.drop_duplicates(subset=['Date'])
  3790                                           
  3791                                                   return updated_forecast

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: update_forecast_balances at line 3793

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3793                                               @profile
  3794                                               def update_forecast_balances(self, forecast_df, account_set, date_YYYYMMDD):
  3795                                                   """
  3796                                                   Updates the account balances in the forecast DataFrame for the current date based on the account set.
  3797                                           
  3798                                                   Parameters:
  3799                                                   - forecast_df: DataFrame containing the forecasted financial data.
  3800                                                   - account_set: AccountSet object representing the current state of accounts.
  3801                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  3802                                                   """
  3803                                                   # Update each account balance in the forecast
  3804                                                   for index, account_row in account_set.getAccounts().iterrows():
  3805                                                       account_name = account_row['Name']
  3806                                                       balance = account_row['Balance']
  3807                                           
  3808                                                       if account_name in forecast_df.columns:
  3809                                                           forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = balance

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: processDeferredTransactions at line 4107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4107                                               @profile
  4108                                               def processDeferredTransactions(self,account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df, priority_level, confirmed_df):
  4109                                                   """
  4110                                                       Processes deferred transactions by attempting to execute them, updating the forecast,
  4111                                                       and handling further deferrals if necessary.
  4112                                           
  4113                                                       Parameters:
  4114                                                       - account_set: AccountSet object representing the current state of accounts.
  4115                                                       - forecast_df: DataFrame containing the forecasted financial data.
  4116                                                       - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  4117                                                       - memo_set: MemoSet object containing memo rules.
  4118                                                       - relevant_deferred_df: DataFrame of deferred transactions relevant to the current date.
  4119                                                       - priority_level: Integer representing the priority level.
  4120                                                       - confirmed_df: DataFrame of confirmed transactions.
  4121                                           
  4122                                                       Returns:
  4123                                                       - forecast_df: Updated forecast DataFrame.
  4124                                                       - new_confirmed_df: DataFrame of newly confirmed transactions.
  4125                                                       - new_deferred_df: DataFrame of transactions that remain deferred.
  4126                                                       """
  4127                                                   # Increment log stack depth for logging purposes
  4128                                                   self.log_stack_depth += 1
  4129                                           
  4130                                                   # Initialize DataFrames for new confirmed and deferred transactions, preserving the schema
  4131                                                   new_confirmed_df = confirmed_df.iloc[0:0].copy()
  4132                                                   new_deferred_df = relevant_deferred_df.iloc[0:0].copy()
  4133                                           
  4134                                                   # Return early if there are no deferred transactions to process
  4135                                                   if relevant_deferred_df.empty:
  4136                                                       self.log_stack_depth -= 1
  4137                                                       return forecast_df, new_confirmed_df, new_deferred_df
  4138                                           
  4139                                                   # Iterate over each deferred transaction
  4140                                                   for deferred_index, deferred_row in relevant_deferred_df.iterrows():
  4141                                                       # Skip if the deferred date is beyond the forecast end date
  4142                                                       deferred_date = deferred_row['Date']
  4143                                                       if datetime.datetime.strptime(deferred_date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD,
  4144                                                                                                                                           '%Y%m%d'):
  4145                                                           continue
  4146                                           
  4147                                                       # Find the matching memo rule for the deferred transaction
  4148                                                       memo_rule_set = memo_set.findMatchingMemoRule(deferred_row['Memo'], deferred_row['Priority'])
  4149                                                       memo_rule_row = memo_rule_set.getMemoRules().iloc[0]
  4150                                           
  4151                                                       # Initialize an empty forecast DataFrame for the hypothetical future state
  4152                                                       hypothetical_future_forecast = forecast_df.iloc[0:0].copy()
  4153                                           
  4154                                                       try:
  4155                                                           # Combine the confirmed transactions with the deferred transaction
  4156                                                           updated_confirmed_df = pd.concat([confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4157                                           
  4158                                                           # Create empty DataFrames for proposed, deferred, and skipped transactions
  4159                                                           empty_df = pd.DataFrame(
  4160                                                               columns=['Date', 'Priority', 'Amount', 'Memo', 'Deferrable', 'Partial_Payment_Allowed'])
  4161                                           
  4162                                                           # Compute the optimal forecast including the deferred transaction
  4163                                                           hypothetical_future_forecast = self.computeOptimalForecast(
  4164                                                               start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4165                                                               end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4166                                                               confirmed_df=updated_confirmed_df,
  4167                                                               proposed_df=empty_df,
  4168                                                               deferred_df=empty_df,
  4169                                                               skipped_df=empty_df,
  4170                                                               account_set=copy.deepcopy(
  4171                                                                   self.sync_account_set_w_forecast_day(account_set, forecast_df, self.start_date_YYYYMMDD)
  4172                                                               ),
  4173                                                               memo_rule_set=memo_set
  4174                                                           )[0]
  4175                                           
  4176                                                           transaction_permitted = True
  4177                                                       except ValueError as e:
  4178                                                           # Check if the exception is due to account boundary violations
  4179                                                           if 'Account boundaries were violated' not in str(e):
  4180                                                               # Reraise the exception if it's not expected
  4181                                                               raise e
  4182                                                           transaction_permitted = False
  4183                                           
  4184                                                       if not transaction_permitted and deferred_row['Deferrable']:
  4185                                                           # Look ahead for the next income date
  4186                                                           future_dates = forecast_df[forecast_df['Date'] > date_YYYYMMDD]
  4187                                                           income_dates = future_dates[future_dates['Memo'].str.contains('income', case=False, na=False)]
  4188                                                           if not income_dates.empty:
  4189                                                               next_income_date = income_dates['Date'].iloc[0]
  4190                                                           else:
  4191                                                               # If no future income date, set to one day after forecast end date
  4192                                                               next_income_date = (
  4193                                                                           datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(
  4194                                                                       days=1)).strftime('%Y%m%d')
  4195                                           
  4196                                                           # Update the deferred transaction's date
  4197                                                           deferred_row['Date'] = next_income_date
  4198                                           
  4199                                                           # Add the deferred transaction to the new deferred DataFrame
  4200                                                           new_deferred_df = pd.concat([new_deferred_df, deferred_row.to_frame().T], ignore_index=True)
  4201                                                       elif transaction_permitted:
  4202                                                           # If priority level is greater than 1, sync the account set with the forecast
  4203                                                           if priority_level > 1:
  4204                                                               account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4205                                           
  4206                                                           # Execute the transaction
  4207                                                           account_set.executeTransaction(
  4208                                                               Account_From=memo_rule_row['Account_From'],
  4209                                                               Account_To=memo_rule_row['Account_To'],
  4210                                                               Amount=deferred_row['Amount'],
  4211                                                               income_flag=False
  4212                                                           )
  4213                                           
  4214                                                           # Add the transaction to the new confirmed DataFrame
  4215                                                           new_confirmed_df = pd.concat([new_confirmed_df, deferred_row.to_frame().T], ignore_index=True)
  4216                                           
  4217                                                           # Remove the transaction from relevant deferred transactions
  4218                                                           relevant_deferred_df = relevant_deferred_df.drop(deferred_index)
  4219                                           
  4220                                                           # Update the forecast DataFrame with the hypothetical future forecast
  4221                                                           past_forecast = forecast_df[forecast_df['Date'] < date_YYYYMMDD]
  4222                                                           future_forecast = hypothetical_future_forecast[hypothetical_future_forecast['Date'] >= date_YYYYMMDD]
  4223                                                           forecast_df = pd.concat([past_forecast, future_forecast], ignore_index=True)
  4224                                                           forecast_df.drop_duplicates(subset=['Date'], inplace=True)
  4225                                                           forecast_df.reset_index(drop=True, inplace=True)
  4226                                           
  4227                                                           # Update the account balances in the forecast DataFrame for the current date
  4228                                                           for account_row in account_set.getAccounts().itertuples():
  4229                                                               account_name = account_row.Name
  4230                                                               account_balance = account_row.Balance
  4231                                                               if account_name in forecast_df.columns:
  4232                                                                   forecast_df.loc[forecast_df['Date'] == date_YYYYMMDD, account_name] = account_balance
  4233                                                       else:
  4234                                                           # This case should not occur; raise an error
  4235                                                           raise ValueError(f"""This is an edge case that should not be possible
  4236                                                                   transaction_permitted...............: {transaction_permitted}
  4237                                                                   deferred_row.Deferrable.............: {deferred_row['Deferrable']}
  4238                                                                   deferred_row.Partial_Payment_Allowed: {deferred_row['Partial_Payment_Allowed']}
  4239                                                                   """)
  4240                                           
  4241                                                   # Decrement log stack depth
  4242                                                   self.log_stack_depth -= 1
  4243                                           
  4244                                                   # Return the updated forecast and DataFrames
  4245                                                   return forecast_df, new_confirmed_df, new_deferred_df
  4246                                           
  4247                                                   # # log_in_color(logger, 'green', 'debug','ENTER processDeferredTransactions( D:'+str(relevant_deferred_df.shape[0])+' )', self.log_stack_depth)
  4248                                                   # self.log_stack_depth += 1
  4249                                                   #
  4250                                                   # #new_confirmed_df = pd.DataFrame(
  4251                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4252                                                   # #new_deferred_df = pd.DataFrame(
  4253                                                   # #    {'Date': [], 'Priority': [], 'Amount': [], 'Memo': [], 'Deferrable': [], 'Partial_Payment_Allowed': []})
  4254                                                   # new_confirmed_df = confirmed_df.head(0) #to preserve schema
  4255                                                   # new_deferred_df = relevant_deferred_df.head(0)  # to preserve schema. same as above line btw
  4256                                                   #
  4257                                                   # if relevant_deferred_df.shape[0] == 0:
  4258                                                   #
  4259                                                   #     self.log_stack_depth -= 1
  4260                                                   #     # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4261                                                   #     return forecast_df, new_confirmed_df, new_deferred_df
  4262                                                   #
  4263                                                   # for deferred_item_index, deferred_row_df in relevant_deferred_df.iterrows():
  4264                                                   #     if datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') > datetime.datetime.strptime(self.end_date_YYYYMMDD, '%Y%m%d'):
  4265                                                   #         continue
  4266                                                   #
  4267                                                   #     relevant_memo_rule_set = memo_set.findMatchingMemoRule(deferred_row_df.Memo, deferred_row_df.Priority)
  4268                                                   #     memo_rule_row = relevant_memo_rule_set.getMemoRules().loc[0, :]
  4269                                                   #
  4270                                                   #     hypothetical_future_state_of_forecast = copy.deepcopy(forecast_df.head(0))
  4271                                                   #
  4272                                                   #     try:
  4273                                                   #
  4274                                                   #         not_yet_validated_confirmed_df = pd.concat([confirmed_df, pd.DataFrame(deferred_row_df).T])
  4275                                                   #         #not_yet_validated_confirmed_df = confirmed_df.append(deferred_row_df)
  4276                                                   #
  4277                                                   #         empty_df = pd.DataFrame({'Date':[],'Priority':[],'Amount':[],'Memo':[],'Deferrable':[],'Partial_Payment_Allowed':[]})
  4278                                                   #
  4279                                                   #         # print('process deferred case 1 sync')
  4280                                                   #         hypothetical_future_state_of_forecast = \
  4281                                                   #         self.computeOptimalForecast(start_date_YYYYMMDD=self.start_date_YYYYMMDD,
  4282                                                   #                                     end_date_YYYYMMDD=self.end_date_YYYYMMDD,
  4283                                                   #                                     confirmed_df=not_yet_validated_confirmed_df,
  4284                                                   #                                     proposed_df=empty_df,
  4285                                                   #                                     deferred_df=empty_df,
  4286                                                   #                                     skipped_df=empty_df,
  4287                                                   #                                     account_set=copy.deepcopy(
  4288                                                   #                                         self.sync_account_set_w_forecast_day(account_set, forecast_df,
  4289                                                   #                                                                              self.start_date_YYYYMMDD)),
  4290                                                   #                                     memo_rule_set=memo_set)[0]
  4291                                                   #
  4292                                                   #         transaction_is_permitted = True
  4293                                                   #     except ValueError as e:
  4294                                                   #         # log_in_color(logger, 'red', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4295                                                   #         if re.search('.*Account boundaries were violated.*',
  4296                                                   #                      str(e.args)) is None:  # this is the only exception where we don't want to stop immediately
  4297                                                   #             raise e
  4298                                                   #
  4299                                                   #         transaction_is_permitted = False
  4300                                                   #
  4301                                                   #     if not transaction_is_permitted and deferred_row_df.Deferrable:
  4302                                                   #
  4303                                                   #         # deferred_row_df.Date = (datetime.datetime.strptime(deferred_row_df.Date, '%Y%m%d') + datetime.timedelta(
  4304                                                   #         #     days=1)).strftime('%Y%m%d')
  4305                                                   #
  4306                                                   #         #look ahead for next income date
  4307                                                   #         future_date_sel_vec = ( d > datetime.datetime.strptime(date_YYYYMMDD,'%Y%m%d') for d in forecast_df.Date )
  4308                                                   #         income_date_sel_vec = ( 'income' in m for m in forecast_df.Memo )
  4309                                                   #         next_income_date = forecast_df[ future_date_sel_vec & income_date_sel_vec ].head(1)['Date']
  4310                                                   #
  4311                                                   #         deferred_row_df.Date = next_income_date
  4312                                                   #         # print('new deferred row')
  4313                                                   #         # print(deferred_row_df.to_string())
  4314                                                   #
  4315                                                   #         #todo what is no future income date
  4316                                                   #
  4317                                                   #         new_deferred_df = pd.concat([new_deferred_df,pd.DataFrame(deferred_row_df).T])
  4318                                                   #
  4319                                                   #     elif transaction_is_permitted:
  4320                                                   #
  4321                                                   #         if priority_level > 1:
  4322                                                   #             # print('process deferred sync case 2')
  4323                                                   #             account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4324                                                   #
  4325                                                   #         account_set.executeTransaction(Account_From=memo_rule_row.Account_From,
  4326                                                   #                                        Account_To=memo_rule_row.Account_To, Amount=deferred_row_df.Amount,
  4327                                                   #                                        income_flag=False)
  4328                                                   #
  4329                                                   #
  4330                                                   #         new_confirmed_df = pd.concat([new_confirmed_df, pd.DataFrame(deferred_row_df).T])
  4331                                                   #
  4332                                                   #         remaining_unproposed_deferred_transactions_df = relevant_deferred_df[
  4333                                                   #             ~relevant_deferred_df.index.isin(deferred_row_df.index)]
  4334                                                   #         relevant_deferred_df = remaining_unproposed_deferred_transactions_df
  4335                                                   #
  4336                                                   #         # forecast_df, skipped_df, confirmed_df, deferred_df
  4337                                                   #         forecast_with_accurately_updated_future_rows = hypothetical_future_state_of_forecast
  4338                                                   #
  4339                                                   #         row_sel_vec = [
  4340                                                   #             datetime.datetime.strptime(d, '%Y%m%d') < datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4341                                                   #             in forecast_df.Date]
  4342                                                   #         forecast_rows_to_keep_df = forecast_df.loc[row_sel_vec, :]
  4343                                                   #
  4344                                                   #         row_sel_vec = [
  4345                                                   #             datetime.datetime.strptime(d, '%Y%m%d') >= datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') for d
  4346                                                   #             in forecast_with_accurately_updated_future_rows.Date]
  4347                                                   #         new_forecast_rows_df = forecast_with_accurately_updated_future_rows.loc[row_sel_vec, :]
  4348                                                   #
  4349                                                   #         forecast_df = pd.concat([forecast_rows_to_keep_df, new_forecast_rows_df])
  4350                                                   #         assert forecast_df.shape[0] == forecast_df.drop_duplicates().shape[0]
  4351                                                   #         forecast_df.reset_index(drop=True, inplace=True)
  4352                                                   #
  4353                                                   #         for account_index, account_row in account_set.getAccounts().iterrows():
  4354                                                   #             if (account_index + 1) == account_set.getAccounts().shape[1]:
  4355                                                   #                 break
  4356                                                   #             relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  4357                                                   #
  4358                                                   #             row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  4359                                                   #             col_sel_vec = (forecast_df.columns == account_row.Name)
  4360                                                   #             forecast_df.iloc[row_sel_vec, col_sel_vec] = relevant_balance
  4361                                                   #     else:
  4362                                                   #         raise ValueError("""This is an edge case that should not be possible
  4363                                                   #                 transaction_is_permitted...............:""" + str(transaction_is_permitted) + """
  4364                                                   #                 budget_item_row.Deferrable.............:""" + str(deferred_row_df.Deferrable) + """
  4365                                                   #                 budget_item_row.Partial_Payment_Allowed:""" + str(deferred_row_df.Partial_Payment_Allowed) + """
  4366                                                   #                 """)
  4367                                                   #
  4368                                                   # self.log_stack_depth -= 1
  4369                                                   # # log_in_color(logger, 'green', 'debug', 'EXIT processDeferredTransactions()', self.log_stack_depth)
  4370                                                   # return forecast_df, new_confirmed_df, new_deferred_df

Total time: 130.64 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeTransactionsForDay at line 4501

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4501                                               @profile
  4502                                               def executeTransactionsForDay(self, account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, proposed_df,
  4503                                                                             deferred_df, skipped_df, priority_level):
  4504       324        266.0      0.8      0.0          isP1 = (priority_level == 1)
  4505                                           
  4506                                                   # Filter transactions relevant to the current day and priority level
  4507       648      89595.0    138.3      0.1          relevant_proposed_df = proposed_df[
  4508       324     196974.0    607.9      0.2              (proposed_df.Priority == priority_level) & (proposed_df.Date == date_YYYYMMDD)]
  4509       648      67300.0    103.9      0.1          relevant_confirmed_df = confirmed_df[
  4510       324     177313.0    547.3      0.1              (confirmed_df.Priority == priority_level) & (confirmed_df.Date == date_YYYYMMDD)]
  4511       648      83752.0    129.2      0.1          relevant_deferred_df = deferred_df[
  4512       324     189933.0    586.2      0.1              (deferred_df.Priority <= priority_level) & (deferred_df.Date == date_YYYYMMDD)]
  4513                                           
  4514       324        469.0      1.4      0.0          self.log_stack_depth += 1
  4515                                           
  4516                                                   # Ensure no proposed transactions exist for priority 1
  4517       324        212.0      0.7      0.0          if isP1:
  4518       324       2840.0      8.8      0.0              assert relevant_proposed_df.empty
  4519                                           
  4520                                                   # Check if there are pending confirmed transactions
  4521       324       2130.0      6.6      0.0          thereArePendingConfirmedTransactions = not relevant_confirmed_df.empty
  4522                                           
  4523                                                   # Check if the current day exists in the forecast and if it's within the forecast range
  4524       324      59228.0    182.8      0.0          date_sel_vec = forecast_df['Date'] == date_YYYYMMDD
  4525       324      67890.0    209.5      0.1          noMatchingDayInForecast = forecast_df.loc[date_sel_vec].empty
  4526       648      28768.0     44.4      0.0          notPastEndOfForecast = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d') <= datetime.datetime.strptime(
  4527       324        257.0      0.8      0.0              self.end_date_YYYYMMDD, '%Y%m%d')
  4528                                           
  4529                                                   # Add a new day to the forecast if required
  4530       324        169.0      0.5      0.0          if isP1 and noMatchingDayInForecast and notPastEndOfForecast:
  4531       324     445167.0   1374.0      0.3              forecast_df = self.addANewDayToTheForecast(forecast_df, date_YYYYMMDD)
  4532                                           
  4533                                                   # Sort transactions to prioritize income first
  4534       324        192.0      0.6      0.0          if isP1 and thereArePendingConfirmedTransactions:
  4535       324     429230.0   1324.8      0.3              relevant_confirmed_df = self.sortTxnsToPutIncomeFirst(relevant_confirmed_df)
  4536                                           
  4537                                                   # Sync account set with the forecast for non-priority 1 transactions
  4538       324        226.0      0.7      0.0          if priority_level > 1:
  4539                                                       account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_YYYYMMDD)
  4540                                           
  4541                                                   # Process confirmed transactions
  4542       648  128796687.0 198760.3     98.6          forecast_df = self.processConfirmedTransactions(forecast_df, relevant_confirmed_df, memo_set, account_set,
  4543       324        113.0      0.3      0.0                                                          date_YYYYMMDD)
  4544                                           
  4545                                                   # Process proposed transactions for priority levels greater than 1
  4546       323        250.0      0.8      0.0          if priority_level > 1:
  4547                                                       forecast_df, new_confirmed_df, new_deferred_df, new_skipped_df = self.processProposedTransactions(
  4548                                                           account_set, forecast_df, date_YYYYMMDD, memo_set, confirmed_df, relevant_proposed_df, priority_level
  4549                                                       )
  4550                                           
  4551                                                       # Update confirmed, deferred, and skipped DataFrames
  4552                                                       confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4553                                                       deferred_df = pd.concat([deferred_df, new_deferred_df]).reset_index(drop=True)
  4554                                                       skipped_df = pd.concat([skipped_df, new_skipped_df]).reset_index(drop=True)
  4555                                           
  4556                                                       # Process deferred transactions if any exist
  4557                                                       if not deferred_df.empty:
  4558                                                           relevant_deferred_before_processing = relevant_deferred_df.copy()  # Keep original for comparison
  4559                                           
  4560                                                           forecast_df, new_confirmed_df, new_deferred_df = self.processDeferredTransactions(
  4561                                                               account_set, forecast_df, date_YYYYMMDD, memo_set, relevant_deferred_df.copy(), priority_level,
  4562                                                               confirmed_df
  4563                                                           )
  4564                                           
  4565                                                           # Update confirmed DataFrame with newly confirmed transactions
  4566                                                           confirmed_df = pd.concat([confirmed_df, new_confirmed_df]).reset_index(drop=True)
  4567                                           
  4568                                                           # Adjust deferred DataFrame by removing processed transactions and adding new deferred ones
  4569                                                           not_relevant_deferred_df = deferred_df[
  4570                                                               (deferred_df.Priority > priority_level) | (deferred_df.Date != date_YYYYMMDD)]
  4571                                                           deferred_df = pd.concat([not_relevant_deferred_df, new_deferred_df]).reset_index(drop=True)
  4572                                           
  4573       323        348.0      1.1      0.0          self.log_stack_depth -= 1
  4574                                           
  4575       323        235.0      0.7      0.0          return [forecast_df, confirmed_df, deferred_df, skipped_df]

Total time: 30.7475 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: calculateLoanInterestAccrualsForDay at line 5429

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5429                                               @profile
  5430                                               def calculateLoanInterestAccrualsForDay(self, account_set, current_forecast_row_df):
  5431                                                   """
  5432                                                   Calculates and applies interest accruals for loans on the current day.
  5433                                           
  5434                                                   Parameters:
  5435                                                   - account_set: AccountSet object containing account information.
  5436                                                   - current_forecast_row_df: DataFrame containing the forecast row for the current date.
  5437                                           
  5438                                                   Returns:
  5439                                                   - Updated current_forecast_row_df with applied interest accruals.
  5440                                                   """
  5441                                                   # Increment log stack depth for logging purposes
  5442       323        503.0      1.6      0.0          self.log_stack_depth += 1
  5443                                           
  5444                                                   # print('PRE INTEREST ACCRUAL FORECAST ROW')
  5445                                                   # print(current_forecast_row_df.to_string())
  5446                                           
  5447                                                   # Extract the current date
  5448       323      22157.0     68.6      0.1          current_date = current_forecast_row_df['Date'].iat[0]
  5449                                           
  5450                                                   # Iterate over each account to calculate interest accruals
  5451      2584    9335579.0   3612.8     30.4          for account_index, account_row in account_set.getAccounts().iterrows():
  5452                                                       # Skip accounts that are not interest-bearing or are previous statement balances
  5453      2261      45759.0     20.2      0.1              if account_row['Account_Type'] == 'credit prev stmt bal':
  5454       323        109.0      0.3      0.0                  continue
  5455                                           
  5456                                                       # Get the interest cadence and type
  5457      1938      22189.0     11.4      0.1              if account_row.get('Interest_Cadence', '') is not None:
  5458       646       6776.0     10.5      0.0                  interest_cadence = account_row.get('Interest_Cadence', '').lower()
  5459                                                       else:
  5460                                                           continue
  5461                                           
  5462       646       6379.0      9.9      0.0              if account_row.get('Interest_Type', '') is not None:
  5463       646       6303.0      9.8      0.0                  interest_type = account_row.get('Interest_Type', '').lower()
  5464                                                       else:
  5465                                                           continue
  5466                                           
  5467                                                       # # Skip if interest cadence or type is not defined
  5468                                                       # if not interest_cadence or interest_cadence == 'none' or not interest_type:
  5469                                                       #     continue
  5470                                           
  5471                                                       # Calculate the number of days since the billing start date
  5472       646       5805.0      9.0      0.0              billing_start_date = account_row['Billing_Start_Date']
  5473      1292     405338.0    313.7      1.3              num_days = (pd.to_datetime(current_date, format='%Y%m%d') - pd.to_datetime(billing_start_date,
  5474       646        292.0      0.5      0.0                                                                                         format='%Y%m%d')).days
  5475                                           
  5476                                                       # Skip if current date is before billing start date
  5477       646        409.0      0.6      0.0              if num_days < 0:
  5478                                                           continue
  5479                                           
  5480                                                       # Generate date sequence based on billing start date and interest cadence
  5481                                                       # Assume generate_date_sequence is a function that returns a set of dates
  5482      1292    1090815.0    844.3      3.5              dseq = generate_date_sequence(start_date_YYYYMMDD=billing_start_date, num_days=num_days,
  5483       646        242.0      0.4      0.0                                            cadence=interest_cadence)
  5484                                           
  5485                                                       # Include billing start date if current date matches
  5486       646        521.0      0.8      0.0              if current_date == billing_start_date:
  5487                                                           dseq.append(current_date)
  5488                                           
  5489                                                       # Check if current date is in the interest accrual dates
  5490       646       4165.0      6.4      0.0              if current_date in dseq:
  5491       646      13320.0     20.6      0.0                  apr = account_row['APR']
  5492       646       6800.0     10.5      0.0                  balance = account_row['Balance']
  5493                                           
  5494                                                           # Calculate interest based on type and cadence
  5495       646        349.0      0.5      0.0                  if interest_type == 'compound':
  5496                                                               if interest_cadence == 'monthly':
  5497                                                                   # Compound interest, monthly accrual
  5498                                                                   interest_accrued = balance * (apr / 12)
  5499                                                                   # Update account balance
  5500                                                                   account_set.accounts[account_index].balance += interest_accrued
  5501                                           
  5502                                                                   # # Move current statement balance to previous statement balance for credit accounts
  5503                                                                   # if account_row['Account_Type'] == 'credit curr stmt bal':
  5504                                                                   #     prev_account_index = account_index - 1
  5505                                                                   #     prev_stmt_balance = account_set.accounts[prev_account_index].balance
  5506                                                                   #     account_set.accounts[account_index].balance += prev_stmt_balance
  5507                                                                   #     account_set.accounts[prev_account_index].balance = 0
  5508                                                               else:
  5509                                                                   # Other compound interest cadences not implemented
  5510                                                                   raise NotImplementedError(
  5511                                                                       f"Compound interest with '{interest_cadence}' cadence is not implemented.")
  5512       646        482.0      0.7      0.0                  elif interest_type == 'simple':
  5513       646        300.0      0.5      0.0                      if interest_cadence == 'daily':
  5514                                                                   # Simple interest, daily accrual
  5515       646        629.0      1.0      0.0                          interest_accrued = balance * (apr / 365.25)
  5516                                           
  5517                                                                   # print('current_date, Name, interest '+str(current_date)+' '+str(account_row.Name)+' '+str(round(interest_accrued,2)))
  5518                                           
  5519                                                                   # Update interest account balance (assuming it's the next account)
  5520       646        352.0      0.5      0.0                          interest_account_index = account_index + 1
  5521       646       1100.0      1.7      0.0                          if interest_account_index < len(account_set.accounts):
  5522       646       1140.0      1.8      0.0                              account_set.accounts[interest_account_index].balance += interest_accrued
  5523                                                                       # Round small balances to zero
  5524       646        736.0      1.1      0.0                              if abs(account_set.accounts[interest_account_index].balance) < 0.01:
  5525       323        308.0      1.0      0.0                                  account_set.accounts[interest_account_index].balance = 0.0
  5526                                                               else:
  5527                                                                   # Other simple interest cadences not implemented
  5528                                                                   raise NotImplementedError(
  5529                                                                       f"Simple interest with '{interest_cadence}' cadence is not implemented.")
  5530                                                           else:
  5531                                                               raise ValueError(f"Unknown interest type '{interest_type}' for account '{account_row['Name']}'.")
  5532                                           
  5533                                                       # print('PRE-UPDATE ACCRUAL FORECAST ROW')
  5534                                                       # print(current_forecast_row_df.to_string())
  5535                                           
  5536                                                       # Update the current forecast row with the updated account balances
  5537      5168   18643444.0   3607.5     60.6              for idx, acc_row in account_set.getAccounts().iterrows():
  5538      4522      96819.0     21.4      0.3                  account_name = acc_row['Name']
  5539      4522      60786.0     13.4      0.2                  balance = acc_row['Balance']
  5540      4522      12255.0      2.7      0.0                  if account_name in current_forecast_row_df.columns:
  5541      4522     954594.0    211.1      3.1                      current_forecast_row_df.iloc[0,current_forecast_row_df.columns == account_name] = round(balance,2)
  5542                                                               #current_forecast_row_df.at[0, account_name] = balance
  5543                                           
  5544                                                       # print('POST-UPDATE ACCRUAL FORECAST ROW')
  5545                                                       # print(current_forecast_row_df.to_string())
  5546                                           
  5547                                                   # Decrement log stack depth
  5548       323        595.0      1.8      0.0          self.log_stack_depth -= 1
  5549                                           
  5550                                                   # print('POST INTEREST ACCRUAL FORECAST ROW')
  5551                                                   # print(current_forecast_row_df.to_string())
  5552                                           
  5553                                                   # Return the updated forecast row DataFrame
  5554       323        132.0      0.4      0.0          return current_forecast_row_df

Total time: 22.1887 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeCreditCardMinimumPayments at line 5694

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5694                                               @profile
  5695                                               def executeCreditCardMinimumPayments(self, forecast_df, account_set, current_forecast_row_df):
  5696                                                   """
  5697                                                   Executes minimum payments for credit card accounts.
  5698                                           
  5699                                                   Parameters:
  5700                                                   - forecast_df: DataFrame containing forecasted financial data.
  5701                                                   - account_set: The current set of accounts.
  5702                                                   - current_forecast_row_df: The forecast row for the current date.
  5703                                           
  5704                                                   Returns:
  5705                                                   - Updated current_forecast_row_df after executing credit card minimum payments.
  5706                                                   """
  5707                                                   #log_in_color(logger, 'cyan', 'debug', 'ENTER executeMinimumPayments() ', self.log_stack_depth)
  5708       323        550.0      1.7      0.0          self.log_stack_depth += 1
  5709       323        748.0      2.3      0.0          primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5710                                           
  5711                                                   # Loop through accounts to process credit card minimum payments
  5712      2584    9616973.0   3721.7     43.3          for account_index, account_row in account_set.getAccounts().iterrows():
  5713      2261      69041.0     30.5      0.3              if account_row.Account_Type != 'credit prev stmt bal':
  5714      1938        642.0      0.3      0.0                  continue
  5715                                           
  5716                                                       # Skip accounts without a billing start date
  5717       323       5767.0     17.9      0.0              billing_start_date = account_row.Billing_Start_Date
  5718       323       1354.0      4.2      0.0              if pd.isnull(billing_start_date) or billing_start_date == 'None':
  5719                                                           continue
  5720                                           
  5721       323      28783.0     89.1      0.1              current_date_str = current_forecast_row_df.Date.iloc[0]
  5722       323      22223.0     68.8      0.1              current_date = datetime.datetime.strptime(current_date_str, '%Y%m%d')
  5723                                           
  5724       323      11706.0     36.2      0.1              billing_start_datetime = datetime.datetime.strptime(billing_start_date, '%Y%m%d')
  5725       323        420.0      1.3      0.0              num_days = (current_date - billing_start_datetime).days
  5726                                           
  5727                                                       # Generate billing days
  5728       323        127.0      0.4      0.0              if num_days >= 0:
  5729       323     290908.0    900.6      1.3                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5730                                                       else:
  5731                                                           billing_days = set()
  5732                                           
  5733       323        235.0      0.7      0.0              if current_date_str == billing_start_date:
  5734                                                           billing_days.add(current_date_str)
  5735                                           
  5736       323        165.0      0.5      0.0              if current_date_str not in billing_days:
  5737       313         98.0      0.3      0.0                  continue
  5738                                           
  5739                                                       # Calculate advance payments made during the billing cycle
  5740        20     302804.0  15140.2      1.4              advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  5741        10        277.0     27.7      0.0                  account_row.Name, account_set, forecast_df, current_date_str
  5742                                                       )
  5743                                           
  5744                                                       # Determine the earliest billing date within the forecast range
  5745        10        438.0     43.8      0.0              first_day_of_forecast_str = forecast_df.Date.iloc[0]
  5746        10        562.0     56.2      0.0              first_day_of_forecast = datetime.datetime.strptime(first_day_of_forecast_str, '%Y%m%d')
  5747                                           
  5748        20       4870.0    243.5      0.0              relevant_billing_days = [
  5749        10          5.0      0.5      0.0                  d for d in billing_days
  5750                                                           if datetime.datetime.strptime(d, '%Y%m%d') > first_day_of_forecast
  5751                                                       ]
  5752                                           
  5753        10          6.0      0.6      0.0              if not relevant_billing_days:
  5754                                                           continue
  5755                                           
  5756        10         16.0      1.6      0.0              earliest_billing_date_within_forecast_range = min(relevant_billing_days)
  5757        10          3.0      0.3      0.0              if current_date_str == earliest_billing_date_within_forecast_range:
  5758                                                           # First billing date in forecast range
  5759         1        277.0    277.0      0.0                  current_prev_stmt_balance = forecast_df.iloc[0][account_row.Name]
  5760         1          0.0      0.0      0.0                  prev_prev_stmt_balance = current_prev_stmt_balance
  5761         1      31211.0  31211.0      0.1                  current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5762                                                       else:
  5763                                                           # Get previous billing cycle data
  5764         9         29.0      3.2      0.0                  left_check_bound = current_date - datetime.timedelta(days=35)
  5765         9      50983.0   5664.8      0.2                  forecast_dates = forecast_df['Date'].apply(lambda d: datetime.datetime.strptime(d, '%Y%m%d'))
  5766        18       1809.0    100.5      0.0                  check_region = forecast_df[
  5767         9       4727.0    525.2      0.0                      (forecast_dates > left_check_bound) & (forecast_dates <= current_date)
  5768                                                               ]
  5769                                           
  5770         9       3267.0    363.0      0.0                  previous_min_payment_dates = check_region['Memo Directives'].str.contains('CC MIN PAYMENT')
  5771         9        814.0     90.4      0.0                  if previous_min_payment_dates.any():
  5772         9       2656.0    295.1      0.0                      prev_prev_stmt_balance = check_region.loc[previous_min_payment_dates, account_row.Name].iat[0]
  5773                                                           else:
  5774                                                               prev_prev_stmt_balance = 0
  5775                                           
  5776         9        238.0     26.4      0.0                  current_prev_stmt_balance = account_row.Balance
  5777         9     244209.0  27134.3      1.1                  current_curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5778                                           
  5779                                                       # Calculate interest and principal to be charged
  5780        10        251.0     25.1      0.0              interest_rate_monthly = account_row.APR / 12
  5781        10         69.0      6.9      0.0              interest_charged = round(prev_prev_stmt_balance * interest_rate_monthly, 2)
  5782        10          6.0      0.6      0.0              principal_charged = prev_prev_stmt_balance * 0.01
  5783        10          5.0      0.5      0.0              current_due = principal_charged + interest_charged
  5784                                           
  5785                                           
  5786                                                       # blindly copied from gpt
  5787        10          8.0      0.8      0.0              min_payment = (
  5788        10        190.0     19.0      0.0                  current_due if current_due > 0 and current_due > account_row.Minimum_Payment else
  5789                                                           (
  5790                                                               account_row.Minimum_Payment if (current_prev_stmt_balance + current_curr_stmt_balance) > account_row.Minimum_Payment else (current_prev_stmt_balance + current_curr_stmt_balance)) if current_due > 0 else 0
  5791                                                       )
  5792                                           
  5793        10         10.0      1.0      0.0              total_payment_due = min_payment - advance_payment_amount
  5794        10          7.0      0.7      0.0              if total_payment_due <= 0:
  5795                                                           payment_toward_prev = 0
  5796                                                           payment_toward_curr = 0
  5797                                                       else:
  5798        10          7.0      0.7      0.0                  if current_prev_stmt_balance >= total_payment_due:
  5799        10          3.0      0.3      0.0                      payment_toward_prev = total_payment_due
  5800        10          4.0      0.4      0.0                      payment_toward_curr = 0
  5801                                                           else:
  5802                                                               payment_toward_prev = current_prev_stmt_balance
  5803                                                               payment_toward_curr = total_payment_due - payment_toward_prev
  5804                                           
  5805                                                       # Update account balances and memo directives
  5806        10          4.0      0.4      0.0              if interest_charged > 0:
  5807        10         29.0      2.9      0.0                  account_set.accounts[account_index].balance += interest_charged
  5808        10        210.0     21.0      0.0                  interest_md_text = f'; CC INTEREST ({account_row.Name} +${interest_charged:.2f}); '
  5809        10        621.0     62.1      0.0                  if interest_md_text not in current_forecast_row_df['Memo Directives'].iat[0]:
  5810        10       4245.0    424.5      0.0                      current_forecast_row_df['Memo Directives'] += interest_md_text
  5811                                           
  5812        10          9.0      0.9      0.0              total_payment = payment_toward_prev + payment_toward_curr
  5813        10          7.0      0.7      0.0              if total_payment > 0:
  5814        20     830477.0  41523.8      3.7                  account_set.executeTransaction(
  5815        10          5.0      0.5      0.0                      Account_From=primary_checking_account_name,
  5816        10        273.0     27.3      0.0                      Account_To=account_row.Name.split(':')[0],
  5817        10          3.0      0.3      0.0                      Amount=total_payment
  5818                                                           )
  5819                                           
  5820        10          6.0      0.6      0.0                  memo_parts = []
  5821        10          8.0      0.8      0.0                  if payment_toward_prev > 0:
  5822        20         15.0      0.8      0.0                      memo_parts.append(
  5823        10        343.0     34.3      0.0                          f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Prev Stmt Bal -${payment_toward_prev:.2f}); '
  5824                                                               )
  5825        10          5.0      0.5      0.0                  if payment_toward_curr > 0:
  5826                                                               memo_parts.append(
  5827                                                                   f'CC MIN PAYMENT ({account_row.Name.split(":")[0]}: Curr Stmt Bal -${payment_toward_curr:.2f}); '
  5828                                                               )
  5829        10          8.0      0.8      0.0                  if total_payment > 0:
  5830        20          9.0      0.5      0.0                      memo_parts.append(
  5831        10         12.0      1.2      0.0                          f'CC MIN PAYMENT ({primary_checking_account_name} -${total_payment:.2f}); '
  5832                                                               )
  5833        10       3535.0    353.5      0.0                  current_forecast_row_df['Memo Directives'] += ''.join(memo_parts)
  5834                                                       elif 'CC MIN PAYMENT' in current_forecast_row_df['Memo Directives'] or advance_payment_amount > 0:
  5835                                                               current_forecast_row_df['Memo Directives'] += (
  5836                                                                   f'CC MIN PAYMENT ALREADY MADE ({account_row.Name.split(":")[0]}: Prev Stmt Bal -$0.00); '
  5837                                                                   f'CC MIN PAYMENT ALREADY MADE ({primary_checking_account_name} -$0.00); '
  5838                                                               )
  5839                                                       #else:  there was no min payment, and one is not necessary now
  5840                                           
  5841                                                       # Clean up memo directives
  5842        20         65.0      3.2      0.0              memo_directives = [
  5843        10        599.0     59.9      0.0                  md.strip() for md in current_forecast_row_df['Memo Directives'].iat[0].split(';') if md.strip()
  5844                                                       ]
  5845        10        837.0     83.7      0.0              current_forecast_row_df['Memo Directives'] = '; '.join(memo_directives)
  5846                                           
  5847                                                   # Update balances in current forecast row
  5848      2584    9535895.0   3690.4     43.0          for account_index, account_row in account_set.getAccounts().iterrows():
  5849      2261      47306.0     20.9      0.2              current_balance = account_row['Balance']
  5850      2261      23178.0     10.3      0.1              account_name = account_row['Name']
  5851      2261     420854.0    186.1      1.9              current_forecast_row_df[account_name] = current_balance
  5852                                           
  5853                                                       # Move current statement balance to previous if it's a billing day
  5854      2261      60438.0     26.7      0.3              if account_row.Account_Type == 'credit prev stmt bal':
  5855       323       5808.0     18.0      0.0                  billing_start_date = account_row.Billing_Start_Date
  5856       323     282888.0    875.8      1.3                  billing_days = set(generate_date_sequence(billing_start_date, num_days, 'monthly'))
  5857       323        328.0      1.0      0.0                  if current_date_str in billing_days:
  5858        10     268272.0  26827.2      1.2                      curr_stmt_balance = account_set.getAccounts().iloc[account_index - 1]['Balance']
  5859        10         35.0      3.5      0.0                      account_set.accounts[account_index].balance += curr_stmt_balance
  5860        10          9.0      0.9      0.0                      account_set.accounts[account_index - 1].balance = 0
  5861        10       1251.0    125.1      0.0                      current_forecast_row_df[account_row.Name] = account_set.accounts[account_index].balance
  5862        10        880.0     88.0      0.0                      current_forecast_row_df[account_set.accounts[account_index - 1].name] = 0
  5863                                           
  5864       323        649.0      2.0      0.0          self.log_stack_depth -= 1
  5865       323        107.0      0.3      0.0          return current_forecast_row_df

Total time: 87.4152 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: executeLoanMinimumPayments at line 5867

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  5867                                               @profile
  5868                                               def executeLoanMinimumPayments(self, account_set, current_forecast_row_df):
  5869                                           
  5870       323      60919.0    188.6      0.1          primary_checking_account_name = account_set.getPrimaryCheckingAccountName()
  5871                                           
  5872                                                   #logger.debug('self.log_stack_depth += 1')
  5873       323        378.0      1.2      0.0          self.log_stack_depth += 1
  5874                                           
  5875                                                   # the branch logic here assumes the sort order of accounts in account list
  5876      2584    9483813.0   3670.2     10.8          for account_index, account_row in account_set.getAccounts().iterrows():
  5877                                           
  5878      2261      74325.0     32.9      0.1              if account_row.Account_Type == 'prev smt bal':
  5879                                                           continue
  5880                                           
  5881                                                       #not sure why both of these checks are necessary
  5882      2261      40897.0     18.1      0.0              if account_row.Billing_Start_Date == 'None':
  5883                                                           continue
  5884                                           
  5885      2261      42425.0     18.8      0.0              if pd.isnull(account_row.Billing_Start_Date):
  5886      1292        457.0      0.4      0.0                  continue
  5887                                           
  5888                                                       # print(BEGIN_GREEN + row.to_string() + RESET_COLOR)
  5889                                                       # print('current_forecast_row_df.Date - row.Billing_Start_Date:')
  5890                                                       # print('current_forecast_row_df.Date:')
  5891                                                       # print(current_forecast_row_df.Date)
  5892                                                       # print('row.Billing_Start_Date:')
  5893                                                       # print(row.Billing_Start_Date)
  5894                                           
  5895       969     164664.0    169.9      0.2              num_days = (datetime.datetime.strptime(current_forecast_row_df.Date.iloc[0],'%Y%m%d') - datetime.datetime.strptime(account_row.Billing_Start_Date,'%Y%m%d')).days
  5896                                                       #billing_days = set(generate_date_sequence(account_row.Billing_Start_Date.strftime('%Y%m%d'), num_days, account_row.Interest_Cadence))
  5897       969     741396.0    765.1      0.8              billing_days = set(generate_date_sequence(account_row.Billing_Start_Date, num_days, 'monthly'))
  5898                                           
  5899                                                       # if the input date matches the start date, add it to the set (bc range where start = end == null set)
  5900       969      68321.0     70.5      0.1              if current_forecast_row_df.Date.iloc[0] == account_row.Billing_Start_Date:
  5901                                                           billing_days = set(current_forecast_row_df.Date).union(billing_days)
  5902                                           
  5903       969      31118.0     32.1      0.0              if current_forecast_row_df.Date.iloc[0] in billing_days:
  5904                                                           # log_in_color(logger,'green', 'debug', 'Processing minimum payments', self.log_stack_depth)
  5905                                                           # log_in_color(logger,'green', 'debug', 'account_row:', self.log_stack_depth)
  5906                                                           # log_in_color(logger,'green', 'debug', account_row.to_string(), self.log_stack_depth)
  5907                                           
  5908                                                           # print(row)
  5909                                                           # if account_row.Account_Type == 'credit prev stmt bal':  # cc min payment
  5910                                                           #
  5911                                                           #     #minimum_payment_amount = max(40, account_row.Balance * 0.033) #this is an estimate
  5912                                                           #     minimum_payment_amount = max(40, account_row.Balance * account_row.APR/12)
  5913                                                           #     #todo it turns out that the way this really works is that Chase uses 1% PLUS the interest accrued to be charged immediately, not added to the principal
  5914                                                           #     #very much not how I designed this but not earth-shatteringly different
  5915                                                           #
  5916                                                           #
  5917                                                           #     payment_toward_prev = round(min(minimum_payment_amount, account_row.Balance),2)
  5918                                                           #     payment_toward_curr = round(min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev),2)
  5919                                                           #
  5920                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  5921                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  5922                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  5923                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  5924                                                           #
  5925                                                           #         if payment_toward_prev > 0:
  5926                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Prev Stmt Bal -$'+str(payment_toward_prev) + '); '
  5927                                                           #         if payment_toward_curr > 0:
  5928                                                           #             current_forecast_row_df.Memo += ' cc min payment ('+account_row.Name.split(':')[0]+': Curr Stmt Bal -$' + str(payment_toward_curr) + '); '
  5929                                                           #         #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' cc min payment ($' + str(minimum_payment_amount) + ') ; '
  5930                                                           #
  5931                                                           # el
  5932        31        654.0     21.1      0.0                  if account_row.Account_Type == 'principal balance':  # loan min payment
  5933                                           
  5934        21     594330.0  28301.4      0.7                      minimum_payment_amount = account_set.getAccounts().loc[account_index, :].Minimum_Payment
  5935                                           
  5936                                                               #todo I notice that this depends on the order of accounts
  5937                                                               #if an accountset was created by manually adding sub accounts, and this is done in the wrong order
  5938                                                               #there will be unexpected behavior BECAUSE OF this part of the code
  5939                                           
  5940                                                               #new
  5941        21        460.0     21.9      0.0                      current_pbal_balance = account_row.Balance
  5942        21     600003.0  28571.6      0.7                      current_interest_balance = account_set.getAccounts().loc[account_index + 1, :].Balance
  5943        21         34.0      1.6      0.0                      current_debt_balance = current_pbal_balance + current_interest_balance
  5944                                           
  5945                                                               # payment_toward_interest = round(min(minimum_payment_amount, current_interest_balance),2)
  5946                                                               # payment_toward_principal = round(min(current_pbal_balance, minimum_payment_amount - payment_toward_interest),2)
  5947                                           
  5948        21         46.0      2.2      0.0                      payment_toward_interest = min(minimum_payment_amount, current_interest_balance)
  5949        21         23.0      1.1      0.0                      payment_toward_principal = min(current_pbal_balance, minimum_payment_amount - payment_toward_interest)
  5950                                           
  5951                                                               #old
  5952                                                               #current_debt_balance = account_set.getBalances()[account_row.Name.split(':')[0]]
  5953                                           
  5954                                           
  5955        21         19.0      0.9      0.0                      loan_payment_amount = min(current_debt_balance,minimum_payment_amount)
  5956                                           
  5957        21         12.0      0.6      0.0                      if loan_payment_amount > 0:
  5958        42    1757459.0  41844.3      2.0                          account_set.executeTransaction(Account_From=primary_checking_account_name, Account_To=account_row.Name.split(':')[0],
  5959                                                                                                  # Note that the execute transaction method will split the amount paid between the 2 accounts
  5960        21          6.0      0.3      0.0                                                         Amount=loan_payment_amount)
  5961                                           
  5962        21         62.0      3.0      0.0                          if payment_toward_interest > 0:
  5963                                                                       #current_forecast_row_df.Memo += ' loan min payment (' + account_row.Name.split(':')[0] + ': Interest -$' + str(round(payment_toward_interest,2)) + '); ' #
  5964        10       5061.0    506.1      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Interest -$' + str(f'{payment_toward_interest:.2f}') + '); '
  5965                                           
  5966        21         30.0      1.4      0.0                          if payment_toward_principal > 0:
  5967                                                                       #current_forecast_row_df.Memo += ' loan min payment ('+account_row.Name.split(':')[0] +': Principal Balance -$' + str(round(payment_toward_principal,2)) + '); '
  5968        21       9530.0    453.8      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT (' + account_row.Name.split(':')[0] + ': Principal Balance -$' + str(f'{payment_toward_principal:.2f}') + '); '
  5969                                           
  5970                                                                   #add checking note
  5971        21         42.0      2.0      0.0                          if ( payment_toward_interest + payment_toward_principal ) > 0 :
  5972        21       6710.0    319.5      0.0                              current_forecast_row_df['Memo Directives'] += ' LOAN MIN PAYMENT ('+primary_checking_account_name+' -$' + str(f'{( payment_toward_interest + payment_toward_principal ):.2f}') + '); '
  5973                                           
  5974                                                                   #current_forecast_row_df.Memo += account_row.Name.split(':')[0] + ' loan min payment ($' + str(minimum_payment_amount) + '); '
  5975                                           
  5976                                           
  5977                                                           # if account_row.Account_Type == 'credit prev stmt bal' or account_row.Account_Type == 'interest':
  5978                                                           #
  5979                                                           #     payment_toward_prev = min(minimum_payment_amount, account_row.Balance)
  5980                                                           #     payment_toward_curr = min(account_set.getAccounts().loc[account_index - 1, :].Balance, minimum_payment_amount - payment_toward_prev)
  5981                                                           #     surplus_payment = minimum_payment_amount - (payment_toward_prev + payment_toward_curr)
  5982                                                           #
  5983                                                           #     if (payment_toward_prev + payment_toward_curr) > 0:
  5984                                                           #         account_set.executeTransaction(Account_From='Checking', Account_To=account_row.Name.split(':')[0],
  5985                                                           #                                        # Note that the execute transaction method will split the amount paid between the 2 accounts
  5986                                                           #                                        Amount=(payment_toward_prev + payment_toward_curr))
  5987                                           
  5988                                                   # print('current_forecast_row_df pre-update')
  5989                                                   # print(current_forecast_row_df.to_string())
  5990      2584    9413099.0   3642.8     10.8          for account_index, account_row in account_set.getAccounts().iterrows():
  5991      2261   63631220.0  28143.0     72.8              relevant_balance = account_set.getAccounts().iloc[account_index, 1]
  5992      2261     260939.0    115.4      0.3              col_sel_vec = (current_forecast_row_df.columns == account_row.Name)
  5993                                                       #print('Setting '+account_row.Name+' to '+str(relevant_balance))
  5994      2261     425925.0    188.4      0.5              current_forecast_row_df.iloc[0, col_sel_vec] = round(relevant_balance,2)
  5995                                           
  5996                                                   # print('current_forecast_row_df post-update')
  5997                                                   # print(current_forecast_row_df.to_string())
  5998                                           
  5999                                                   # log_in_color(logger,'green', 'debug', 'return this row:', self.log_stack_depth)
  6000                                                   # log_in_color(logger,'green', 'debug', current_forecast_row_df.to_string(), self.log_stack_depth)
  6001       323        672.0      2.1      0.0          self.log_stack_depth -= 1
  6002                                                   #log_in_color(logger,'cyan', 'debug', 'EXIT  executeMinimumPayments() ', self.log_stack_depth)
  6003                                                   #logger.debug('self.log_stack_depth -= 1')
  6004                                           
  6005       323        131.0      0.4      0.0          return current_forecast_row_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: getMinimumFutureAvailableBalances at line 6007

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6007                                               @profile
  6008                                               def getMinimumFutureAvailableBalances(self, account_set, forecast_df, date_YYYYMMDD):
  6009                                                   """
  6010                                                   Calculates the minimum future available balances for each account starting from the specified date.
  6011                                           
  6012                                                   Parameters:
  6013                                                   - account_set: AccountSet object containing account information.
  6014                                                   - forecast_df: DataFrame containing the forecasted financial data.
  6015                                                   - date_YYYYMMDD: String representing the current date in 'YYYYMMDD' format.
  6016                                           
  6017                                                   Returns:
  6018                                                   - future_available_balances: Dictionary mapping account names to their minimum future available balances.
  6019                                                   """
  6020                                                   import datetime
  6021                                                   import pandas as pd
  6022                                           
  6023                                                   # Increment log stack depth (if used for logging)
  6024                                                   self.log_stack_depth += 1
  6025                                           
  6026                                                   # Convert date string to datetime object for comparison
  6027                                                   current_date = datetime.datetime.strptime(date_YYYYMMDD, '%Y%m%d')
  6028                                           
  6029                                                   # Ensure 'Date' column is in datetime format
  6030                                                   #forecast_df['Date_dt'] = pd.to_datetime(forecast_df['Date'], format='%Y%m%d')
  6031                                           
  6032                                                   # Filter forecast_df for current and future dates
  6033                                                   current_and_future_forecast_df = forecast_df[ [ datetime.datetime.strptime(d,'%Y%m%d') >= current_date for d in forecast_df['Date'] ] ]
  6034                                           
  6035                                                   # Get the account information
  6036                                                   accounts_df = account_set.getAccounts()
  6037                                                   future_available_balances = {}
  6038                                           
  6039                                                   for account_index, account_row in accounts_df.iterrows():
  6040                                                       full_account_name = account_row['Name']
  6041                                                       account_name = full_account_name.split(':')[0]
  6042                                                       account_type = account_row['Account_Type'].lower()
  6043                                           
  6044                                                       # Check if account exists in forecast_df columns
  6045                                                       if account_name not in forecast_df.columns:
  6046                                                           continue
  6047                                           
  6048                                                       if account_type == 'checking':
  6049                                                           # Calculate minimum future balance minus minimum required balance
  6050                                                           min_future_balance = current_and_future_forecast_df[account_name].min()
  6051                                                           min_available_balance = min_future_balance - account_row['Min_Balance']
  6052                                                           future_available_balances[account_name] = min_available_balance
  6053                                           
  6054                                                       elif account_type == 'credit prev stmt bal':
  6055                                                           # Get indices for previous and current statement balance accounts
  6056                                                           prev_index = account_index
  6057                                                           curr_index = account_index - 1
  6058                                           
  6059                                                           # Ensure the current index is valid
  6060                                                           if curr_index < 0:
  6061                                                               continue
  6062                                           
  6063                                                           prev_stmt_account_name = accounts_df.iloc[prev_index]['Name']
  6064                                                           curr_stmt_account_name = accounts_df.iloc[curr_index]['Name']
  6065                                           
  6066                                                           # Check if both accounts exist in forecast_df columns
  6067                                                           if prev_stmt_account_name not in forecast_df.columns or curr_stmt_account_name not in forecast_df.columns:
  6068                                                               continue
  6069                                           
  6070                                                           # Sum the balances of previous and current statement balances
  6071                                                           total_credit_balance = current_and_future_forecast_df[prev_stmt_account_name] + \
  6072                                                                                  current_and_future_forecast_df[curr_stmt_account_name]
  6073                                           
  6074                                                           # Calculate the minimum total credit balance
  6075                                                           min_total_credit_balance = total_credit_balance.min()
  6076                                           
  6077                                                           # Calculate available credit
  6078                                                           max_balance = account_row['Max_Balance']
  6079                                                           min_available_credit = max_balance - min_total_credit_balance - account_row['Min_Balance']
  6080                                                           future_available_balances[account_name] = min_available_credit
  6081                                           
  6082                                                   # Decrement log stack depth
  6083                                                   self.log_stack_depth -= 1
  6084                                           
  6085                                                   return future_available_balances

Total time: 40.7558 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: sync_account_set_w_forecast_day at line 6087

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  6087                                               @profile
  6088                                               def sync_account_set_w_forecast_day(self, account_set, forecast_df, date_YYYYMMDD):
  6089                                           
  6090      1292   36658696.0  28373.6     89.9          Accounts_df = account_set.getAccounts()
  6091      1292     674088.0    521.7      1.7          relevant_forecast_day = forecast_df[forecast_df.Date == date_YYYYMMDD]
  6092                                           
  6093     10336    1170479.0    113.2      2.9          for account_index, account_row in Accounts_df.iterrows():
  6094      9044      30760.0      3.4      0.1              if (account_index + 1) == Accounts_df.shape[1]:
  6095                                                           break
  6096                                           
  6097      9044    1652919.0    182.8      4.1              row_sel_vec = (forecast_df.Date == date_YYYYMMDD)
  6098                                           
  6099      9044       3982.0      0.4      0.0              try:
  6100      9044     158124.0     17.5      0.4                  assert sum(row_sel_vec) > 0
  6101                                                       except Exception as e:
  6102                                                           error_msg = "error in sync_account_set_w_forecast_day\n"
  6103                                                           error_msg += "date_YYYYMMDD: "+date_YYYYMMDD+"\n"
  6104                                                           error_msg += "min date of forecast:"+min(forecast_df.Date)+"\n"
  6105                                                           error_msg += "max date of forecast:"+max(forecast_df.Date)+"\n"
  6106                                                           raise AssertionError(error_msg)
  6107                                           
  6108      9044     396238.0     43.8      1.0              relevant_balance = relevant_forecast_day.iat[0, account_index + 1]
  6109      9044      10095.0      1.1      0.0              account_set.accounts[account_index].balance = relevant_balance
  6110                                           
  6111      1292        438.0      0.3      0.0          return account_set

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_stmt_balance at line 7244

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7244                                               @profile
  7245                                               def _propagate_credit_curr_stmt_balance(self, relevant_account_info_df,
  7246                                                                                       account_deltas_list,
  7247                                                                                       future_rows_only_df,
  7248                                                                                       forecast_df):
  7249                                                   """
  7250                                                   Propagates changes to the credit card current statement balance into the future forecast.
  7251                                           
  7252                                                   Parameters:
  7253                                                   - relevant_account_info_df: DataFrame containing account information.
  7254                                                   - account_deltas_list: List of deltas for each account (excluding 'Date' column).
  7255                                                   - future_rows_only_df: DataFrame containing future forecast rows.
  7256                                                   - forecast_df: The original forecast DataFrame.
  7257                                           
  7258                                                   Returns:
  7259                                                   - Updated future_rows_only_df DataFrame.
  7260                                                   """
  7261                                                   # Extract the account name for the current statement balance
  7262                                                   curr_stmt_bal_account_series = relevant_account_info_df[
  7263                                                       relevant_account_info_df['Account_Type'] == 'credit curr stmt bal']['Name']
  7264                                                   if curr_stmt_bal_account_series.empty:
  7265                                                       # Handle the case where the account type is not found
  7266                                                       raise ValueError("Account type 'credit curr stmt bal' not found in relevant_account_info_df")
  7267                                                   curr_stmt_bal_account_name = curr_stmt_bal_account_series.iat[0]
  7268                                           
  7269                                                   # Create a Series mapping account names to deltas
  7270                                                   account_names = forecast_df.columns[1:]  # Exclude 'Date' column
  7271                                                   account_deltas_series = pd.Series(account_deltas_list, index=account_names)
  7272                                           
  7273                                                   # Get the delta for the current statement balance account
  7274                                                   try:
  7275                                                       curr_stmt_delta = account_deltas_series[curr_stmt_bal_account_name]
  7276                                                   except KeyError:
  7277                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in account_deltas_list")
  7278                                           
  7279                                                   # Update the future forecast DataFrame
  7280                                                   if curr_stmt_bal_account_name in future_rows_only_df.columns:
  7281                                                       future_rows_only_df[curr_stmt_bal_account_name] += curr_stmt_delta
  7282                                                   else:
  7283                                                       raise KeyError(f"Account '{curr_stmt_bal_account_name}' not found in future_rows_only_df columns")
  7284                                           
  7285                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_curr_only at line 7288

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7288                                               @profile
  7289                                               def _propagate_credit_curr_only(self, relevant_account_info_df,
  7290                                                                                       account_deltas_list,
  7291                                                                                       future_rows_only_df,
  7292                                                                                       forecast_df,
  7293                                                                                       account_set_before_p2_plus_txn,
  7294                                                                                       billing_dates_dict,
  7295                                                                                       date_string_YYYYMMDD,
  7296                                                                                       post_txn_row_df):
  7297                                                   """
  7298                                                   Propagates credit card payments involving only the current statement balance into the future forecast.
  7299                                           
  7300                                                   Parameters:
  7301                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7302                                                   - account_deltas_list: List of account balance changes (deltas).
  7303                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7304                                                   - forecast_df: The original forecast DataFrame.
  7305                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7306                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7307                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7308                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7309                                           
  7310                                                   Returns:
  7311                                                   - Updated future_rows_only_df DataFrame.
  7312                                                   """
  7313                                           
  7314                                                   # Extract relevant account names
  7315                                                   checking_account_name = relevant_account_info_df[
  7316                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7317                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  7318                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  7319                                                   # Construct the previous statement balance account name
  7320                                                   prev_stmt_bal_account_name = curr_stmt_bal_account_name.replace('Curr Stmt Bal', 'Prev Stmt Bal')
  7321                                           
  7322                                                   # Get billing dates and next billing date
  7323                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7324                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7325                                                   if future_billing_dates:
  7326                                                       next_billing_date = str(min(future_billing_dates))
  7327                                                   else:
  7328                                                       next_billing_date = None
  7329                                           
  7330                                                   # Get account indices in forecast_df
  7331                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7332                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7333                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  7334                                           
  7335                                                   # Get account deltas
  7336                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  7337                                                   checking_delta = curr_stmt_delta
  7338                                                   previous_stmt_delta = 0.0
  7339                                           
  7340                                                   # Iterate over future forecast rows
  7341                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7342                                                       date_iat = f_row['Date']
  7343                                                       md_to_keep = []
  7344                                           
  7345                                                       if date_iat == next_billing_date:
  7346                                                           # At the next billing date, process memo directives
  7347                                           
  7348                                                           # Initialize memo variables
  7349                                                           og_curr_memo = ''
  7350                                                           og_check_memo = ''
  7351                                                           og_curr_amount = 0.0
  7352                                                           og_check_amount = 0.0
  7353                                           
  7354                                                           # Parse memo directives
  7355                                                           for md in f_row['Memo Directives'].split(';'):
  7356                                                               md = md.strip()
  7357                                                               if not md:
  7358                                                                   continue
  7359                                           
  7360                                                               if f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  7361                                                                   og_curr_memo = md
  7362                                                                   og_curr_amount = self._parse_memo_amount(md)
  7363                                                                   curr_stmt_delta += og_curr_amount
  7364                                                                   checking_delta += og_curr_amount
  7365                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7366                                                                   og_check_memo = md
  7367                                                                   og_check_amount = self._parse_memo_amount(md)
  7368                                                               else:
  7369                                                                   md_to_keep.append(md)
  7370                                           
  7371                                                           # Move curr_stmt_delta to previous_stmt_delta as the current balance moves to previous
  7372                                                           previous_stmt_delta += curr_stmt_delta
  7373                                                           curr_stmt_delta = 0.0
  7374                                           
  7375                                                           # Update memo directives
  7376                                                           new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  7377                                                           md_to_keep.append(new_curr_memo)
  7378                                           
  7379                                                           if og_check_memo:
  7380                                                               # Adjust the checking memo amount
  7381                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - og_curr_amount)
  7382                                                               md_to_keep.append(new_check_memo)
  7383                                           
  7384                                                       else:
  7385                                                           # No adjustments needed on other dates
  7386                                                           pass
  7387                                           
  7388                                                       # Update balances
  7389                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7390                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  7391                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7392                                           
  7393                                                       # Clean and update memo directives
  7394                                                       md_to_keep = [md for md in md_to_keep if md]
  7395                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7396                                           
  7397                                                       # Reset deltas for the next iteration
  7398                                                       checking_delta = 0.0
  7399                                                       curr_stmt_delta = 0.0
  7400                                                       previous_stmt_delta = 0.0
  7401                                           
  7402                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_only at line 7404

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7404                                               @profile
  7405                                               def _propagate_credit_payment_prev_only(self, relevant_account_info_df,
  7406                                                                                       account_deltas_list,
  7407                                                                                       future_rows_only_df,
  7408                                                                                       forecast_df,
  7409                                                                                       account_set_before_p2_plus_txn,
  7410                                                                                       billing_dates_dict,
  7411                                                                                       date_string_YYYYMMDD,
  7412                                                                                       post_txn_row_df):
  7413                                                   """
  7414                                                   Propagates credit card payments involving only the previous statement balance into the future forecast.
  7415                                           
  7416                                                   Parameters:
  7417                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7418                                                   - account_deltas_list: List of account balance changes (deltas).
  7419                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7420                                                   - forecast_df: The original forecast DataFrame.
  7421                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7422                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7423                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7424                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7425                                           
  7426                                                   Returns:
  7427                                                   - Updated future_rows_only_df DataFrame.
  7428                                                   """
  7429                                           
  7430                                                   # Extract relevant account names
  7431                                                   checking_account_name = relevant_account_info_df[
  7432                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7433                                                   prev_stmt_bal_account_name = relevant_account_info_df[
  7434                                                       relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  7435                                           
  7436                                                   # Get billing dates and next billing date
  7437                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  7438                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7439                                                   if future_billing_dates:
  7440                                                       next_billing_date = str(min(future_billing_dates))
  7441                                                   else:
  7442                                                       next_billing_date = None
  7443                                           
  7444                                                   # Get account indices in forecast_df
  7445                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7446                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  7447                                           
  7448                                                   # Get account deltas
  7449                                                   previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  7450                                                   checking_delta = previous_stmt_delta
  7451                                           
  7452                                                   # Initialize previous previous statement balance
  7453                                                   previous_prev_stmt_bal = 0.0
  7454                                           
  7455                                                   # Iterate over future forecast rows
  7456                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7457                                                       date_iat = f_row['Date']
  7458                                                       md_to_keep = []
  7459                                           
  7460                                                       if date_iat == next_billing_date:
  7461                                                           # Handle next billing date (payment due date)
  7462                                           
  7463                                                           # Initialize memo variables
  7464                                                           og_check_memo = ''
  7465                                                           og_prev_memo = ''
  7466                                                           og_min_payment_amount = 0.0
  7467                                           
  7468                                                           # Parse memo directives
  7469                                                           for md in f_row['Memo Directives'].split(';'):
  7470                                                               md = md.strip()
  7471                                                               if not md:
  7472                                                                   continue
  7473                                           
  7474                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7475                                                                   og_prev_memo = md
  7476                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7477                                                                   og_check_memo = md
  7478                                                               else:
  7479                                                                   md_to_keep.append(md)
  7480                                           
  7481                                                           # Get advance payment amount
  7482                                                           advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  7483                                                               prev_stmt_bal_account_name,
  7484                                                               account_set_before_p2_plus_txn,
  7485                                                               forecast_df,
  7486                                                               date_iat
  7487                                                           )
  7488                                           
  7489                                                           # Get minimum payment amount
  7490                                                           og_min_payment_amount = self._parse_memo_amount(og_check_memo)
  7491                                           
  7492                                                           # Adjust deltas
  7493                                                           payment_to_apply = min(og_min_payment_amount, advance_payment_amount)
  7494                                                           previous_stmt_delta += payment_to_apply
  7495                                                           checking_delta += payment_to_apply
  7496                                           
  7497                                                           # Update previous_prev_stmt_bal
  7498                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7499                                           
  7500                                                           # Adjust memo directives
  7501                                                           if advance_payment_amount >= og_min_payment_amount:
  7502                                                               new_check_memo = self._update_memo_amount(og_check_memo, 0.00)
  7503                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  7504                                                           else:
  7505                                                               remaining_payment = og_min_payment_amount - advance_payment_amount
  7506                                                               new_check_memo = self._update_memo_amount(og_check_memo, remaining_payment)
  7507                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, remaining_payment)
  7508                                           
  7509                                                           md_to_keep.extend([new_check_memo, new_prev_memo])
  7510                                           
  7511                                                       elif date_iat in cc_billing_dates and previous_prev_stmt_bal != 0:
  7512                                                           # Handle other billing dates after payment has been made
  7513                                           
  7514                                                           # Initialize memo variables
  7515                                                           og_min_payment_amount = 0.0
  7516                                           
  7517                                                           # Parse memo directives
  7518                                                           for md in f_row['Memo Directives'].split(';'):
  7519                                                               md = md.strip()
  7520                                                               if not md:
  7521                                                                   continue
  7522                                           
  7523                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  7524                                                                   og_min_payment_amount = self._parse_memo_amount(md)
  7525                                           
  7526                                                                   # Calculate interest and current due
  7527                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7528                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7529                                                                       ]
  7530                                                                   apr = account_row['APR'].iat[0]
  7531                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7532                                                                   principal_due = previous_prev_stmt_bal * 0.01
  7533                                                                   current_due = principal_due + interest_to_be_charged
  7534                                           
  7535                                                                   new_min_payment_amount = round(current_due, 2)
  7536                                           
  7537                                                                   # Adjust deltas
  7538                                                                   previous_stmt_delta += new_min_payment_amount
  7539                                                                   checking_delta += new_min_payment_amount
  7540                                           
  7541                                                                   # Update memo directive
  7542                                                                   new_md = self._update_memo_amount(md, new_min_payment_amount)
  7543                                                                   md_to_keep.append(new_md)
  7544                                           
  7545                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  7546                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7547                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7548                                                                       ]
  7549                                                                   apr = account_row['APR'].iat[0]
  7550                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7551                                           
  7552                                                                   og_interest_amount = self._parse_memo_amount(md)
  7553                                                                   previous_stmt_delta += interest_to_be_charged
  7554                                           
  7555                                                                   # Update memo directive
  7556                                                                   new_md = self._update_memo_amount(md, interest_to_be_charged)
  7557                                                                   md_to_keep.append(new_md)
  7558                                           
  7559                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  7560                                                                   og_check_amount = self._parse_memo_amount(md)
  7561                                           
  7562                                                                   # Calculate interest and current due
  7563                                                                   account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  7564                                                                       account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  7565                                                                       ]
  7566                                                                   apr = account_row['APR'].iat[0]
  7567                                                                   interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  7568                                                                   principal_due = previous_prev_stmt_bal * 0.01
  7569                                                                   current_due = principal_due + interest_to_be_charged
  7570                                           
  7571                                                                   new_min_payment_amount = round(current_due, 2)
  7572                                           
  7573                                                                   # Update memo directive
  7574                                                                   new_md = self._update_memo_amount(md, new_min_payment_amount)
  7575                                                                   md_to_keep.append(new_md)
  7576                                           
  7577                                                               else:
  7578                                                                   md_to_keep.append(md)
  7579                                           
  7580                                                           # Update previous_prev_stmt_bal
  7581                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  7582                                           
  7583                                                       else:
  7584                                                           # No adjustments needed
  7585                                                           pass
  7586                                           
  7587                                                       # Update balances
  7588                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7589                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  7590                                           
  7591                                                       # Clean and update memo directives
  7592                                                       md_to_keep = [md for md in md_to_keep if md]
  7593                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7594                                           
  7595                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_interest_only at line 7597

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7597                                               @profile
  7598                                               def _propagate_loan_payment_interest_only(self, relevant_account_info_df,
  7599                                                                                         account_deltas_list,
  7600                                                                                         future_rows_only_df,
  7601                                                                                         forecast_df,
  7602                                                                                         account_set_before_p2_plus_txn,
  7603                                                                                         billing_dates_dict,
  7604                                                                                         date_string_YYYYMMDD,
  7605                                                                                         post_txn_row_df):
  7606                                                   """
  7607                                                   Propagates loan payments involving only the interest into the future forecast.
  7608                                           
  7609                                                   Parameters:
  7610                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7611                                                   - account_deltas_list: List of account balance changes (deltas).
  7612                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7613                                                   - forecast_df: The original forecast DataFrame.
  7614                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7615                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7616                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7617                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7618                                           
  7619                                                   Returns:
  7620                                                   - Updated future_rows_only_df DataFrame.
  7621                                                   """
  7622                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_interest_only', self.log_stack_depth)
  7623                                                   self.log_stack_depth += 1
  7624                                                   # log_in_color(logger, 'cyan', 'debug', 'BEFORE future_rows_only_df', self.log_stack_depth)
  7625                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7626                                           
  7627                                                   # Extract relevant account names
  7628                                                   checking_account_name = relevant_account_info_df[
  7629                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7630                                                   interest_account_name = relevant_account_info_df[
  7631                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  7632                                                   # Construct the principal balance account name based on the interest account name
  7633                                                   pbal_account_name = interest_account_name.split(':')[0] + ': Principal Balance'
  7634                                           
  7635                                                   # Get the APR for the principal balance account
  7636                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7637                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7638                                                   apr = pbal_row_df['APR'].iat[0]
  7639                                           
  7640                                                   # Get billing dates and next billing date
  7641                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7642                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7643                                                   if future_billing_dates:
  7644                                                       next_billing_date = str(min(future_billing_dates))
  7645                                                   else:
  7646                                                       next_billing_date = None
  7647                                           
  7648                                                   # Get account indices in forecast_df
  7649                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7650                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7651                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7652                                           
  7653                                                   # Get account deltas
  7654                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  7655                                                   checking_delta = interest_delta  # Since only interest is involved
  7656                                           
  7657                                                   # Iterate over future forecast rows
  7658                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7659                                                       date_iat = f_row['Date']
  7660                                                       md_to_keep = []
  7661                                           
  7662                                                       if date_iat == next_billing_date:
  7663                                                           # Handle next billing date (payment due date)
  7664                                           
  7665                                                           # Initialize amounts
  7666                                                           interest_amount = 0.0
  7667                                           
  7668                                                           # Parse memo directives
  7669                                                           for md in f_row['Memo Directives'].split(';'):
  7670                                                               md = md.strip()
  7671                                                               if not md:
  7672                                                                   continue
  7673                                           
  7674                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7675                                                                   interest_amount = self._parse_memo_amount(md)
  7676                                                                   interest_delta += interest_amount
  7677                                                                   checking_delta += interest_amount
  7678                                                               else:
  7679                                                                   md_to_keep.append(md)
  7680                                           
  7681                                                           # Remove the checking memo directive
  7682                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${interest_amount:.2f})'
  7683                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7684                                           
  7685                                                       elif date_iat in loan_billing_dates:
  7686                                                           # Handle other billing dates
  7687                                           
  7688                                                           # Initialize variables
  7689                                                           interest_paid_amount = 0.0
  7690                                                           og_interest_md = ''
  7691                                           
  7692                                                           # Parse memo directives
  7693                                                           for md in f_row['Memo Directives'].split(';'):
  7694                                                               md = md.strip()
  7695                                                               if not md:
  7696                                                                   continue
  7697                                           
  7698                                                               if f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  7699                                                                   interest_paid_amount = self._parse_memo_amount(md)
  7700                                                                   og_interest_md = md
  7701                                                               else:
  7702                                                                   md_to_keep.append(md)
  7703                                           
  7704                                                           # Get interest balance at the time of charge
  7705                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  7706                                           
  7707                                                           # Adjust interest memo
  7708                                                           if interest_balance <= interest_paid_amount:
  7709                                                               new_interest_amount = interest_balance
  7710                                                               og_interest_surplus = interest_paid_amount - interest_balance
  7711                                                               new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  7712                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7713                                                           else:
  7714                                                               new_interest_amount = interest_paid_amount
  7715                                                               og_interest_surplus = 0.0
  7716                                                               new_interest_md = og_interest_md
  7717                                                               new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  7718                                           
  7719                                                           # Update memo directives
  7720                                                           md_to_keep.extend([new_interest_md, new_checking_interest_md])
  7721                                           
  7722                                                           # Adjust deltas
  7723                                                           checking_delta += og_interest_surplus
  7724                                                           interest_delta += og_interest_surplus
  7725                                           
  7726                                                       else:
  7727                                                           # No adjustments needed for other dates
  7728                                                           pass
  7729                                           
  7730                                                       # Apply daily interest accrual
  7731                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  7732                                                           if f_i == 0:
  7733                                                               # Set interest to the value after the transaction
  7734                                           
  7735                                                               #this is the OG line, but I think this keeps the OG index so this fails
  7736                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  7737                                                               #instead of reindexing (bc expensive) lets try this:
  7738                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  7739                                                           else:
  7740                                                               # Set interest equal to the previous day's interest
  7741                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  7742                                                                   f_i - 1, interest_account_name]
  7743                                           
  7744                                                           # Calculate interest accrued on this day
  7745                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7746                                                           interest_accrued = pbal_balance * (apr / 365.25)
  7747                                           
  7748                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  7749                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  7750                                           
  7751                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  7752                                           
  7753                                                       # Update balances
  7754                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7755                                           
  7756                                                       # Clean and update memo directives
  7757                                                       md_to_keep = [md for md in md_to_keep if md]
  7758                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7759                                           
  7760                                                       log_in_color(logger, 'cyan', 'debug', 'f_i:'+str(f_i), self.log_stack_depth)
  7761                                           
  7762                                                   # log_in_color(logger, 'cyan', 'debug', 'AFTER future_rows_only_df', self.log_stack_depth)
  7763                                                   # log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  7764                                                   self.log_stack_depth -= 1
  7765                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_interest_only', self.log_stack_depth)
  7766                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_only at line 7768

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7768                                               @profile
  7769                                               def _propagate_loan_payment_pbal_only(self, relevant_account_info_df,
  7770                                                                                     account_deltas_list,
  7771                                                                                     future_rows_only_df,
  7772                                                                                     forecast_df,
  7773                                                                                     account_set_before_p2_plus_txn,
  7774                                                                                     billing_dates_dict,
  7775                                                                                     date_string_YYYYMMDD,
  7776                                                                                     post_txn_row_df):
  7777                                                   """
  7778                                                   Propagates loan payments involving only the principal balance into the future forecast.
  7779                                           
  7780                                                   Parameters:
  7781                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7782                                                   - account_deltas_list: List of account balance changes (deltas).
  7783                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7784                                                   - forecast_df: The original forecast DataFrame.
  7785                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7786                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7787                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7788                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7789                                           
  7790                                                   Returns:
  7791                                                   - Updated future_rows_only_df DataFrame.
  7792                                                   """
  7793                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_only', self.log_stack_depth)
  7794                                                   self.log_stack_depth += 1
  7795                                           
  7796                                                   # Extract relevant account names
  7797                                                   checking_account_name = relevant_account_info_df[
  7798                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7799                                                   pbal_account_name = relevant_account_info_df[
  7800                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  7801                                                   # Construct the interest account name based on the principal balance account name
  7802                                                   interest_account_name = pbal_account_name.split(':')[0] + ': Interest'
  7803                                           
  7804                                                   # Get the APR for the principal balance account
  7805                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7806                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7807                                                   apr = pbal_row_df['APR'].iat[0]
  7808                                           
  7809                                                   # Get billing dates and next billing date
  7810                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7811                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7812                                                   if future_billing_dates:
  7813                                                       next_billing_date = str(min(future_billing_dates))
  7814                                                   else:
  7815                                                       next_billing_date = None
  7816                                           
  7817                                                   # Get account indices in forecast_df
  7818                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7819                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7820                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7821                                           
  7822                                                   # Get account deltas
  7823                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  7824                                                   checking_delta = pbal_delta  # Since only principal balance is involved
  7825                                           
  7826                                                   # Iterate over future forecast rows
  7827                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7828                                                       date_iat = f_row['Date']
  7829                                                       md_to_keep = []
  7830                                           
  7831                                                       if date_iat == next_billing_date:
  7832                                                           # Handle next billing date (payment due date)
  7833                                           
  7834                                                           # Initialize amounts
  7835                                                           pbal_amount = 0.0
  7836                                           
  7837                                                           # Parse memo directives
  7838                                                           for md in f_row['Memo Directives'].split(';'):
  7839                                                               md = md.strip()
  7840                                                               if not md:
  7841                                                                   continue
  7842                                           
  7843                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7844                                                                   pbal_amount = self._parse_memo_amount(md)
  7845                                                                   pbal_delta += pbal_amount
  7846                                                                   checking_delta += pbal_amount
  7847                                                               else:
  7848                                                                   md_to_keep.append(md)
  7849                                           
  7850                                                           # Remove the checking memo directive
  7851                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${pbal_amount:.2f})'
  7852                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  7853                                           
  7854                                                       elif date_iat in loan_billing_dates:
  7855                                                           # Handle other billing dates
  7856                                           
  7857                                                           # Initialize variables
  7858                                                           pbal_paid_amount = 0.0
  7859                                                           og_pbal_md = ''
  7860                                           
  7861                                                           # Parse memo directives
  7862                                                           for md in f_row['Memo Directives'].split(';'):
  7863                                                               md = md.strip()
  7864                                                               if not md:
  7865                                                                   continue
  7866                                           
  7867                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  7868                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  7869                                                                   og_pbal_md = md
  7870                                                               else:
  7871                                                                   md_to_keep.append(md)
  7872                                           
  7873                                                           # Get balance at the time of charge
  7874                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7875                                           
  7876                                                           # Adjust principal balance memo
  7877                                                           if pbal_balance <= pbal_paid_amount:
  7878                                                               new_pbal_amount = pbal_balance
  7879                                                               og_pbal_surplus = pbal_paid_amount - pbal_balance
  7880                                                               final_recredit_checking = og_pbal_surplus
  7881                                                               new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  7882                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7883                                                           else:
  7884                                                               new_pbal_amount = pbal_paid_amount
  7885                                                               og_pbal_surplus = 0.0
  7886                                                               final_recredit_checking = 0.0
  7887                                                               new_pbal_md = og_pbal_md
  7888                                                               new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  7889                                           
  7890                                                           # Update memo directives
  7891                                                           md_to_keep.extend([new_pbal_md, new_checking_pbal_md])
  7892                                           
  7893                                                           # Adjust deltas
  7894                                                           checking_delta += final_recredit_checking
  7895                                                           pbal_delta += og_pbal_surplus
  7896                                           
  7897                                                       else:
  7898                                                           # No adjustments needed for other dates
  7899                                                           pass
  7900                                           
  7901                                                       # Update balances
  7902                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  7903                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  7904                                           
  7905                                                       # Apply daily interest accrual
  7906                                                       if int(date_iat) >= int(min(loan_billing_dates)):
  7907                                                           if f_i == 0:
  7908                                                               # Set interest to the value after the transaction
  7909                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  7910                                                           else:
  7911                                                               # Set interest equal to the previous day's interest
  7912                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  7913                                                                   f_i - 1, interest_account_name]
  7914                                           
  7915                                                           # Calculate interest accrued on this day
  7916                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  7917                                                           interest_accrued = pbal_balance * (apr / 365.25)
  7918                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  7919                                           
  7920                                                       # Clean and update memo directives
  7921                                                       md_to_keep = [md for md in md_to_keep if md]
  7922                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  7923                                           
  7924                                                   self.log_stack_depth -= 1
  7925                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_only', self.log_stack_depth)
  7926                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_loan_payment_pbal_interest at line 7928

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  7928                                               @profile
  7929                                               def _propagate_loan_payment_pbal_interest(self, relevant_account_info_df,
  7930                                                                                         account_deltas_list,
  7931                                                                                         future_rows_only_df,
  7932                                                                                         forecast_df,
  7933                                                                                         account_set_before_p2_plus_txn,
  7934                                                                                         billing_dates_dict,
  7935                                                                                         date_string_YYYYMMDD,
  7936                                                                                         post_txn_row_df):
  7937                                                   """
  7938                                                   Propagates loan payments involving principal balance and interest into the future forecast.
  7939                                           
  7940                                                   Parameters:
  7941                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  7942                                                   - account_deltas_list: List of account balance changes (deltas).
  7943                                                   - future_rows_only_df: DataFrame with future forecast rows.
  7944                                                   - forecast_df: The original forecast DataFrame.
  7945                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  7946                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  7947                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  7948                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  7949                                           
  7950                                                   Returns:
  7951                                                   - Updated future_rows_only_df DataFrame.
  7952                                                   """
  7953                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  7954                                                   self.log_stack_depth += 1
  7955                                           
  7956                                                   # Extract relevant account names
  7957                                                   checking_account_name = relevant_account_info_df[
  7958                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  7959                                                   pbal_account_name = relevant_account_info_df[
  7960                                                       relevant_account_info_df.Account_Type == 'principal balance'].Name.iat[0]
  7961                                                   interest_account_name = relevant_account_info_df[
  7962                                                       relevant_account_info_df.Account_Type == 'interest'].Name.iat[0]
  7963                                           
  7964                                                   # Get the APR for the principal balance account
  7965                                                   pbal_sel = account_set_before_p2_plus_txn.getAccounts()['Name'] == pbal_account_name
  7966                                                   pbal_row_df = account_set_before_p2_plus_txn.getAccounts()[pbal_sel]
  7967                                                   apr = pbal_row_df['APR'].iat[0]
  7968                                           
  7969                                                   # Get billing dates and next billing date
  7970                                                   loan_billing_dates = billing_dates_dict[pbal_account_name]
  7971                                                   future_billing_dates = [int(d) for d in loan_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  7972                                                   if future_billing_dates:
  7973                                                       next_billing_date = str(min(future_billing_dates))
  7974                                                   else:
  7975                                                       next_billing_date = None
  7976                                           
  7977                                                   # Get account indices in forecast_df
  7978                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  7979                                                   pbal_account_index = forecast_df.columns.get_loc(pbal_account_name)
  7980                                                   interest_account_index = forecast_df.columns.get_loc(interest_account_name)
  7981                                           
  7982                                                   # Get account deltas
  7983                                                   pbal_delta = account_deltas_list[pbal_account_index - 1]
  7984                                                   interest_delta = account_deltas_list[interest_account_index - 1]
  7985                                                   checking_delta = pbal_delta + interest_delta
  7986                                           
  7987                                                   # Iterate over future forecast rows
  7988                                                   for f_i, f_row in future_rows_only_df.iterrows():
  7989                                                       date_iat = f_row['Date']
  7990                                                       md_to_keep = []
  7991                                           
  7992                                                       if date_iat == next_billing_date:
  7993                                                           # Handle next billing date (payment due date)
  7994                                           
  7995                                                           # Initialize amounts
  7996                                                           pbal_amount = 0.0
  7997                                                           interest_amount = 0.0
  7998                                           
  7999                                                           # Parse memo directives
  8000                                                           for md in f_row['Memo Directives'].split(';'):
  8001                                                               md = md.strip()
  8002                                                               if not md:
  8003                                                                   continue
  8004                                           
  8005                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8006                                                                   pbal_amount = self._parse_memo_amount(md)
  8007                                                                   pbal_delta += pbal_amount
  8008                                                                   checking_delta += pbal_amount
  8009                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8010                                                                   interest_amount = self._parse_memo_amount(md)
  8011                                                                   interest_delta += interest_amount
  8012                                                                   checking_delta += interest_amount
  8013                                                               else:
  8014                                                                   md_to_keep.append(md)
  8015                                           
  8016                                                           # Remove the checking memo directive
  8017                                                           total_payment = pbal_amount + interest_amount
  8018                                                           checking_memo_to_delete = f'LOAN MIN PAYMENT ({checking_account_name} -${total_payment:.2f})'
  8019                                                           md_to_keep = [md for md in md_to_keep if md != checking_memo_to_delete]
  8020                                           
  8021                                                       elif date_iat in loan_billing_dates:
  8022                                                           # Handle other billing dates (interest accrual)
  8023                                           
  8024                                                           # Initialize variables
  8025                                                           pbal_paid_amount = 0.0
  8026                                                           interest_paid_amount = 0.0
  8027                                                           og_pbal_md = ''
  8028                                                           og_interest_md = ''
  8029                                           
  8030                                                           # Parse memo directives
  8031                                                           for md in f_row['Memo Directives'].split(';'):
  8032                                                               md = md.strip()
  8033                                                               if not md:
  8034                                                                   continue
  8035                                           
  8036                                                               if f'LOAN MIN PAYMENT ({pbal_account_name}' in md:
  8037                                                                   pbal_paid_amount = self._parse_memo_amount(md)
  8038                                                                   og_pbal_md = md
  8039                                                               elif f'LOAN MIN PAYMENT ({interest_account_name}' in md:
  8040                                                                   interest_paid_amount = self._parse_memo_amount(md)
  8041                                                                   og_interest_md = md
  8042                                                               else:
  8043                                                                   md_to_keep.append(md)
  8044                                           
  8045                                                           # Get balances at the time of charge
  8046                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8047                                                           interest_balance = future_rows_only_df.at[f_i, interest_account_name]
  8048                                           
  8049                                                           # Adjust interest memo
  8050                                                           if interest_balance <= interest_paid_amount:
  8051                                                               new_interest_amount = interest_balance
  8052                                                               og_interest_surplus = interest_paid_amount - interest_balance
  8053                                                           else:
  8054                                                               new_interest_amount = interest_paid_amount
  8055                                                               og_interest_surplus = 0.0
  8056                                                           new_interest_md = self._update_memo_amount(og_interest_md, new_interest_amount)
  8057                                                           new_checking_interest_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_interest_amount:.2f})'
  8058                                           
  8059                                                           # Adjust principal balance memo
  8060                                                           total_pbal_payment = pbal_paid_amount + og_interest_surplus
  8061                                                           if pbal_balance <= total_pbal_payment:
  8062                                                               new_pbal_amount = pbal_balance
  8063                                                               og_pbal_surplus = total_pbal_payment - pbal_balance
  8064                                                               final_recredit_checking = og_pbal_surplus
  8065                                                           else:
  8066                                                               new_pbal_amount = total_pbal_payment
  8067                                                               og_pbal_surplus = 0.0
  8068                                                               final_recredit_checking = 0.0
  8069                                                           new_pbal_md = f'LOAN MIN PAYMENT ({pbal_account_name} -${new_pbal_amount:.2f})'
  8070                                                           new_checking_pbal_md = f'LOAN MIN PAYMENT ({checking_account_name} -${new_pbal_amount:.2f})'
  8071                                           
  8072                                                           # Update memo directives
  8073                                                           md_to_keep.extend([new_interest_md, new_pbal_md, new_checking_pbal_md, new_checking_interest_md])
  8074                                           
  8075                                                           # Adjust deltas
  8076                                                           checking_delta += (og_pbal_surplus + og_interest_surplus)
  8077                                                           pbal_delta += og_pbal_surplus
  8078                                                           interest_delta += og_interest_surplus
  8079                                           
  8080                                                       else:
  8081                                                           # No adjustments needed for other dates
  8082                                                           pass
  8083                                           
  8084                                                       # Update balances
  8085                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8086                                                       future_rows_only_df.at[f_i, pbal_account_name] += pbal_delta
  8087                                           
  8088                                                       # Apply daily interest accrual
  8089                                                       if date_iat >= min(loan_billing_dates):
  8090                                                           if f_i == 0:
  8091                                                               # Set interest to the value after the transaction
  8092                                                               #future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.at[0, interest_account_name]
  8093                                                               future_rows_only_df.at[f_i, interest_account_name] = post_txn_row_df.head(1)[interest_account_name].iat[0]
  8094                                                           else:
  8095                                                               # Set interest equal to the previous day's interest
  8096                                                               future_rows_only_df.at[f_i, interest_account_name] = future_rows_only_df.at[
  8097                                                                   f_i - 1, interest_account_name]
  8098                                           
  8099                                                           # Calculate interest accrued on this day
  8100                                                           pbal_balance = future_rows_only_df.at[f_i, pbal_account_name]
  8101                                                           interest_accrued = pbal_balance * (apr / 365.25)
  8102                                                           future_rows_only_df.at[f_i, interest_account_name] += interest_accrued
  8103                                                           future_rows_only_df.at[f_i, interest_account_name] = round(future_rows_only_df.at[f_i, interest_account_name],2)
  8104                                                           interest_delta = 0.0  # Reset interest delta to prevent accumulation
  8105                                           
  8106                                                       # Clean and update memo directives
  8107                                                       md_to_keep = [md for md in md_to_keep if md]
  8108                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8109                                           
  8110                                                   self.log_stack_depth -= 1
  8111                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_loan_payment_pbal_interest', self.log_stack_depth)
  8112                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _propagate_credit_payment_prev_curr at line 8114

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8114                                               @profile
  8115                                               def _propagate_credit_payment_prev_curr(self, relevant_account_info_df,
  8116                                                                                       account_deltas_list,
  8117                                                                                       future_rows_only_df,
  8118                                                                                       forecast_df,
  8119                                                                                       account_set_before_p2_plus_txn,
  8120                                                                                       billing_dates_dict,
  8121                                                                                       date_string_YYYYMMDD,
  8122                                                                                       post_txn_row_df):
  8123                                                   """
  8124                                                   Propagates credit card payments into the future forecast when both previous and current statement balances are involved.
  8125                                           
  8126                                                   Parameters:
  8127                                                   - relevant_account_info_df: DataFrame with account info for relevant accounts.
  8128                                                   - account_deltas_list: List of account balance changes (deltas).
  8129                                                   - future_rows_only_df: DataFrame with future forecast rows.
  8130                                                   - forecast_df: The original forecast DataFrame.
  8131                                                   - account_set_before_p2_plus_txn: Account set before processing the transaction.
  8132                                                   - billing_dates_dict: Dictionary mapping account names to billing dates.
  8133                                                   - date_string_YYYYMMDD: Current date as a string in 'YYYYMMDD' format.
  8134                                                   - post_txn_row_df: DataFrame with the forecast row after transactions.
  8135                                           
  8136                                                   Returns:
  8137                                                   - Updated future_rows_only_df DataFrame.
  8138                                                   """
  8139                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8140                                                   self.log_stack_depth += 1
  8141                                           
  8142                                                   # Extract relevant account names
  8143                                                   checking_account_name = relevant_account_info_df[
  8144                                                       relevant_account_info_df.Account_Type == 'checking'].Name.iat[0]
  8145                                                   curr_stmt_bal_account_name = relevant_account_info_df[
  8146                                                       relevant_account_info_df.Account_Type == 'credit curr stmt bal'].Name.iat[0]
  8147                                                   prev_stmt_bal_account_name = relevant_account_info_df[
  8148                                                       relevant_account_info_df.Account_Type == 'credit prev stmt bal'].Name.iat[0]
  8149                                           
  8150                                                   # Get billing dates and next billing date
  8151                                                   cc_billing_dates = billing_dates_dict[prev_stmt_bal_account_name]
  8152                                                   future_billing_dates = [int(d) for d in cc_billing_dates if int(d) > int(date_string_YYYYMMDD)]
  8153                                                   if future_billing_dates:
  8154                                                       next_billing_date = str(min(future_billing_dates))
  8155                                                   else:
  8156                                                       next_billing_date = None
  8157                                           
  8158                                                   # Get account indices in forecast_df
  8159                                                   checking_account_index = forecast_df.columns.get_loc(checking_account_name)
  8160                                                   prev_stmt_bal_account_index = forecast_df.columns.get_loc(prev_stmt_bal_account_name)
  8161                                                   curr_stmt_bal_account_index = forecast_df.columns.get_loc(curr_stmt_bal_account_name)
  8162                                           
  8163                                                   # Get account deltas
  8164                                                   previous_stmt_delta = account_deltas_list[prev_stmt_bal_account_index - 1]
  8165                                                   curr_stmt_delta = account_deltas_list[curr_stmt_bal_account_index - 1]
  8166                                                   checking_delta = previous_stmt_delta + curr_stmt_delta
  8167                                           
  8168                                                   # Initialize previous previous statement balance (used in future billing dates)
  8169                                                   previous_prev_stmt_bal = 0
  8170                                           
  8171                                                   # Iterate over future forecast rows
  8172                                                   for f_i, f_row in future_rows_only_df.iterrows():
  8173                                                       date_iat = f_row['Date']
  8174                                           
  8175                                                       md_to_keep = []
  8176                                           
  8177                                                       if date_iat == next_billing_date:
  8178                                                           # Handle next billing date
  8179                                           
  8180                                                           # Initialize memo variables
  8181                                                           og_prev_memo = ''
  8182                                                           og_curr_memo = ''
  8183                                                           og_check_memo = ''
  8184                                                           og_interest_memo = ''
  8185                                                           og_prev_amount = 0.0
  8186                                                           og_curr_amount = 0.0
  8187                                                           og_check_amount = 0.0
  8188                                                           og_interest_amount = 0.0
  8189                                           
  8190                                                           # Parse memo directives
  8191                                                           for md in f_row['Memo Directives'].split(';'):
  8192                                                               md = md.strip()
  8193                                                               if not md:
  8194                                                                   continue
  8195                                           
  8196                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8197                                                                   og_prev_memo = md
  8198                                                                   og_prev_amount = self._parse_memo_amount(md)
  8199                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8200                                                                   og_curr_memo = md
  8201                                                                   og_curr_amount = self._parse_memo_amount(md)
  8202                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8203                                                                   og_check_memo = md
  8204                                                                   og_check_amount = self._parse_memo_amount(md)
  8205                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8206                                                                   og_interest_memo = md
  8207                                                                   og_interest_amount = self._parse_memo_amount(md)
  8208                                                               else:
  8209                                                                   md_to_keep.append(md)
  8210                                           
  8211                                                           # Get advance payment amount
  8212                                                           advance_payment_amount = self.getTotalPrepaidInCreditCardBillingCycle(
  8213                                                               prev_stmt_bal_account_name,
  8214                                                               account_set_before_p2_plus_txn,
  8215                                                               forecast_df,
  8216                                                               date_iat
  8217                                                           )
  8218                                           
  8219                                                           min_payment_amount = og_check_amount
  8220                                           
  8221                                                           # Adjust deltas
  8222                                                           curr_stmt_delta += og_curr_amount
  8223                                                           previous_stmt_delta += og_prev_amount
  8224                                                           checking_delta += og_prev_amount + og_curr_amount
  8225                                           
  8226                                                           # Apply advance payments
  8227                                                           if advance_payment_amount >= min_payment_amount:
  8228                                                               # All payments already made
  8229                                                               new_check_memo = f'CC MIN PAYMENT ALREADY MADE ({checking_account_name} -$0.00)'
  8230                                                               new_prev_memo = (f'CC MIN PAYMENT ALREADY MADE ({prev_stmt_bal_account_name} -$0.00)'
  8231                                                                                if og_prev_amount > 0 else '')
  8232                                                               new_curr_memo = (f'CC MIN PAYMENT ALREADY MADE ({curr_stmt_bal_account_name} -$0.00)'
  8233                                                                                if og_curr_amount > 0 else '')
  8234                                                           else:
  8235                                                               remaining_payment = min_payment_amount - advance_payment_amount
  8236                                                               if advance_payment_amount >= og_prev_amount:
  8237                                                                   # Advance payments cover previous statement balance
  8238                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, 0.00)
  8239                                                                   curr_amount_remaining = og_curr_amount - (advance_payment_amount - og_prev_amount)
  8240                                                                   new_curr_memo = self._update_memo_amount(og_curr_memo, curr_amount_remaining)
  8241                                                               else:
  8242                                                                   # Advance payments partially cover previous statement balance
  8243                                                                   prev_amount_remaining = og_prev_amount - advance_payment_amount
  8244                                                                   new_prev_memo = self._update_memo_amount(og_prev_memo, prev_amount_remaining)
  8245                                                                   new_curr_memo = og_curr_memo
  8246                                                               new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - advance_payment_amount)
  8247                                           
  8248                                                           # Move current statement delta to previous
  8249                                                           previous_stmt_delta += curr_stmt_delta
  8250                                                           curr_stmt_delta = 0
  8251                                           
  8252                                                           # Update memo directives
  8253                                                           md_to_keep.extend(filter(None, [new_check_memo, new_curr_memo, new_prev_memo, og_interest_memo]))
  8254                                           
  8255                                                           # Compute previous previous statement balance
  8256                                                           previous_prev_stmt_bal = round(
  8257                                                               future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta, 2
  8258                                                           )
  8259                                           
  8260                                                       elif date_iat in cc_billing_dates:
  8261                                                           # Handle other billing dates
  8262                                           
  8263                                                           # Ensure we have a valid previous_prev_stmt_bal
  8264                                                           if previous_prev_stmt_bal == 0:
  8265                                                               continue  # Skip if we don't have previous balance
  8266                                           
  8267                                                           # Initialize memo variables
  8268                                                           og_prev_memo = ''
  8269                                                           og_curr_memo = ''
  8270                                                           og_check_memo = ''
  8271                                                           og_interest_memo = ''
  8272                                                           og_prev_amount = 0.0
  8273                                                           og_curr_amount = 0.0
  8274                                                           og_check_amount = 0.0
  8275                                                           og_interest_amount = 0.0
  8276                                                           og_min_payment_amount = 0.0
  8277                                           
  8278                                                           # Parse memo directives
  8279                                                           for md in f_row['Memo Directives'].split(';'):
  8280                                                               md = md.strip()
  8281                                                               if not md:
  8282                                                                   continue
  8283                                           
  8284                                                               if f'CC MIN PAYMENT ({prev_stmt_bal_account_name}' in md:
  8285                                                                   og_prev_memo = md
  8286                                                                   og_prev_amount = self._parse_memo_amount(md)
  8287                                                                   og_min_payment_amount += og_prev_amount
  8288                                                               elif f'CC MIN PAYMENT ({curr_stmt_bal_account_name}' in md:
  8289                                                                   og_curr_memo = md
  8290                                                                   og_curr_amount = self._parse_memo_amount(md)
  8291                                                                   og_min_payment_amount += og_curr_amount
  8292                                                               elif f'CC MIN PAYMENT ({checking_account_name}' in md:
  8293                                                                   og_check_memo = md
  8294                                                                   og_check_amount = self._parse_memo_amount(md)
  8295                                                               elif f'CC INTEREST ({prev_stmt_bal_account_name}' in md:
  8296                                                                   og_interest_memo = md
  8297                                                                   og_interest_amount = self._parse_memo_amount(md)
  8298                                                               else:
  8299                                                                   md_to_keep.append(md)
  8300                                           
  8301                                                           # Get account row for APR
  8302                                                           account_row = account_set_before_p2_plus_txn.getAccounts().loc[
  8303                                                               account_set_before_p2_plus_txn.getAccounts().Name == prev_stmt_bal_account_name
  8304                                                               ]
  8305                                           
  8306                                                           # Compute interest and current due
  8307                                                           apr = account_row.APR.iat[0]
  8308                                                           interest_to_be_charged = round(previous_prev_stmt_bal * (apr / 12), 2)
  8309                                                           principal_due = previous_prev_stmt_bal * 0.01
  8310                                                           current_due = principal_due + interest_to_be_charged
  8311                                           
  8312                                                           # Adjusted payment amounts
  8313                                                           curr_prev_stmt_bal = f_row[prev_stmt_bal_account_name]  # Should we adjust for interest?
  8314                                           
  8315                                                           new_min_payment_amount = max(min(40, current_due), curr_prev_stmt_bal)
  8316                                           
  8317                                                           adjusted_payment_amount = round(og_min_payment_amount - new_min_payment_amount, 2)
  8318                                           
  8319                                                           previous_stmt_delta += adjusted_payment_amount
  8320                                                           checking_delta += adjusted_payment_amount
  8321                                                           interest_delta = interest_to_be_charged - og_interest_amount
  8322                                                           previous_stmt_delta += round(interest_delta, 2)
  8323                                           
  8324                                                           # Adjust memos
  8325                                                           new_check_memo = self._update_memo_amount(og_check_memo, og_check_amount - adjusted_payment_amount)
  8326                                                           if adjusted_payment_amount >= curr_prev_stmt_bal:
  8327                                                               # Adjust curr and prev memos
  8328                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, adjusted_payment_amount - curr_prev_stmt_bal)
  8329                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, curr_prev_stmt_bal)
  8330                                                           else:
  8331                                                               new_curr_memo = self._update_memo_amount(og_curr_memo, 0.00)
  8332                                                               new_prev_memo = self._update_memo_amount(og_prev_memo, adjusted_payment_amount)
  8333                                                           new_interest_memo = self._update_memo_amount(og_interest_memo, interest_to_be_charged)
  8334                                           
  8335                                                           # Update memo directives
  8336                                                           md_to_keep.extend([new_check_memo, new_curr_memo, new_prev_memo, new_interest_memo])
  8337                                           
  8338                                                           # Update previous_prev_stmt_bal
  8339                                                           previous_prev_stmt_bal = future_rows_only_df.at[f_i, prev_stmt_bal_account_name] + previous_stmt_delta
  8340                                           
  8341                                                       else:
  8342                                                           # No adjustments needed
  8343                                                           pass
  8344                                           
  8345                                                       # Update balances
  8346                                                       future_rows_only_df.at[f_i, checking_account_name] += checking_delta
  8347                                                       future_rows_only_df.at[f_i, prev_stmt_bal_account_name] += previous_stmt_delta
  8348                                                       future_rows_only_df.at[f_i, curr_stmt_bal_account_name] += curr_stmt_delta
  8349                                           
  8350                                                       # Clean and update memo directives
  8351                                                       md_to_keep = [md for md in md_to_keep if md]
  8352                                                       future_rows_only_df.at[f_i, 'Memo Directives'] = ';'.join(md_to_keep)
  8353                                           
  8354                                                   self.log_stack_depth -= 1
  8355                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT _propagate_credit_payment_prev_curr', self.log_stack_depth)
  8356                                                   return future_rows_only_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _parse_memo_amount at line 8358

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8358                                               @profile
  8359                                               def _parse_memo_amount(self, memo_line):
  8360                                                   """
  8361                                                   Parses a memo line and extracts the amount.
  8362                                                   Returns the amount as a float.
  8363                                                   """
  8364                                                   match = re.search(r'\((.*?)-\$(.*?)\)', memo_line)
  8365                                                   if match:
  8366                                                       amount_str = match.group(2).strip()
  8367                                                       try:
  8368                                                           amount = float(amount_str)
  8369                                                           return amount
  8370                                                       except ValueError:
  8371                                                           return 0.0
  8372                                                   else:
  8373                                                       return 0.0

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: _update_memo_amount at line 8375

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8375                                               @profile
  8376                                               def _update_memo_amount(self, memo_line, new_amount):
  8377                                                   """
  8378                                                   Updates the amount in a memo line with a new amount.
  8379                                                   Returns the updated memo line.
  8380                                                   """
  8381                                                   return re.sub(r'\((.*?)-\$(.*?)\)', r'(\1-$' + f'{new_amount:.2f}' + ')', memo_line)

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: propagateOptimizationTransactionsIntoTheFuture at line 8383

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  8383                                               @profile
  8384                                               def propagateOptimizationTransactionsIntoTheFuture(self, account_set_before_p2_plus_txn, forecast_df, date_string_YYYYMMDD):
  8385                                                   """
  8386                                                   Propagates optimization transactions into the future forecast.
  8387                                           
  8388                                                   Parameters:
  8389                                                   - account_set_before_p2_plus_txn: Account set before processing transactions.
  8390                                                   - forecast_df: DataFrame containing the financial forecast.
  8391                                                   - date_string_YYYYMMDD: The current date in 'YYYYMMDD' format.
  8392                                           
  8393                                                   Returns:
  8394                                                   - Updated forecast_df with propagated transactions.
  8395                                                   """
  8396                                                   log_in_color(logger, 'cyan', 'debug', 'ENTER propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8397                                                   self.log_stack_depth += 1
  8398                                                   log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8399                                                   log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8400                                           
  8401                                                   account_set_after_p2_plus_txn = self.sync_account_set_w_forecast_day(
  8402                                                       copy.deepcopy(account_set_before_p2_plus_txn), forecast_df, date_string_YYYYMMDD
  8403                                                   )
  8404                                           
  8405                                                   A_df = account_set_after_p2_plus_txn.getAccounts()
  8406                                                   B_df = account_set_before_p2_plus_txn.getAccounts()
  8407                                           
  8408                                                   # Compute account deltas
  8409                                                   account_deltas = A_df['Balance'] - B_df['Balance']
  8410                                           
  8411                                                   # Sanity check: For certain account types, deltas should be <= 0
  8412                                                   account_types_to_check = ['checking', 'principal balance', 'interest']
  8413                                                   is_account_type = A_df['Account_Type'].isin(account_types_to_check)
  8414                                                   violations = account_deltas[is_account_type] > 0
  8415                                           
  8416                                                   if violations.any():
  8417                                                       log_in_color(logger, 'red', 'error', str(account_deltas[violations]), self.log_stack_depth)
  8418                                                       raise AssertionError('Account delta positive for checking, principal balance, or interest accounts.')
  8419                                           
  8420                                                   account_deltas_list = account_deltas.tolist()
  8421                                           
  8422                                                   if account_deltas.sum() == 0:
  8423                                                       return forecast_df
  8424                                           
  8425                                                   # log_in_color(
  8426                                                   #     logger,
  8427                                                   #     'magenta',
  8428                                                   #     'debug',
  8429                                                   #     f'ENTER propagateOptimizationTransactionsIntoTheFuture({date_string_YYYYMMDD})',
  8430                                                   #     self.log_stack_depth
  8431                                                   # )
  8432                                           
  8433                                                   future_rows_only_row_sel_vec = [ datetime.datetime.strptime(d, '%Y%m%d') > datetime.datetime.strptime(date_string_YYYYMMDD, '%Y%m%d') for d in forecast_df.Date]  # not sure if still need this
  8434                                           
  8435                                                   post_txn_row_df = forecast_df[forecast_df['Date'] == date_string_YYYYMMDD]
  8436                                           
  8437                                                   future_rows_only_df = forecast_df[forecast_df['Date'] > date_string_YYYYMMDD].reset_index(drop=True)
  8438                                           
  8439                                                   # Generate interest accrual dates
  8440                                                   interest_accrual_dates__list_of_lists = []
  8441                                                   for _, a_row in A_df.iterrows():
  8442                                                       interest_cadence = a_row['Interest_Cadence']
  8443                                                       if pd.isnull(interest_cadence) or interest_cadence == 'None':
  8444                                                           interest_accrual_dates__list_of_lists.append([])
  8445                                                           continue
  8446                                           
  8447                                                       start_date = pd.to_datetime(a_row['Billing_Start_Date'], format='%Y%m%d')
  8448                                                       end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8449                                                       num_days = (end_date - start_date).days
  8450                                                       account_specific_iad = generate_date_sequence(a_row['Billing_Start_Date'], num_days, interest_cadence)
  8451                                                       interest_accrual_dates__list_of_lists.append(account_specific_iad)
  8452                                           
  8453                                                   # Generate billing dates
  8454                                                   billing_dates__list_of_lists = []
  8455                                                   billing_dates__dict = {}
  8456                                                   for _, a_row in A_df.iterrows():
  8457                                                       billing_start_date = a_row['Billing_Start_Date']
  8458                                                       if pd.isnull(billing_start_date) or billing_start_date == 'None':
  8459                                                           billing_dates__list_of_lists.append([])
  8460                                                           continue
  8461                                           
  8462                                                       start_date = pd.to_datetime(billing_start_date, format='%Y%m%d')
  8463                                                       end_date = pd.to_datetime(self.end_date_YYYYMMDD, format='%Y%m%d')
  8464                                                       num_days = (end_date - start_date).days
  8465                                                       account_specific_bd = generate_date_sequence(billing_start_date, num_days, 'monthly')
  8466                                                       billing_dates__list_of_lists.append(account_specific_bd)
  8467                                                       billing_dates__dict[a_row['Name']] = account_specific_bd
  8468                                           
  8469                                                   # Mapping of account type combinations to processing functions
  8470                                                   account_type_combinations = {
  8471                                                       frozenset(
  8472                                                           ['checking', 'credit prev stmt bal', 'credit curr stmt bal']): self._propagate_credit_payment_prev_curr,
  8473                                                       frozenset(['checking', 'principal balance', 'interest']): self._propagate_loan_payment_pbal_interest,
  8474                                                       frozenset(['checking', 'principal balance']): self._propagate_loan_payment_pbal_only,
  8475                                                       frozenset(['checking', 'interest']): self._propagate_loan_payment_interest_only,
  8476                                                       frozenset(['checking', 'credit prev stmt bal']): self._propagate_credit_payment_prev_only,
  8477                                                       frozenset(['checking', 'credit curr stmt bal']): self._propagate_credit_curr_only,
  8478                                                       frozenset(['credit curr stmt bal']): self._propagate_credit_curr_stmt_balance,
  8479                                                   }
  8480                                           
  8481                                                   # Assume accounts_df is a DataFrame containing account information
  8482                                                   accounts_df = account_set_before_p2_plus_txn.getAccounts().copy()
  8483                                           
  8484                                                   # Create a Series for account deltas with the same index as accounts_df
  8485                                                   accounts_df['Delta'] = account_deltas_list
  8486                                           
  8487                                                   # Extract base names (before ':') of account names
  8488                                                   accounts_df['Base_Name'] = accounts_df['Name'].str.split(':').str[0]
  8489                                           
  8490                                                   # Select accounts with non-zero deltas
  8491                                                   accounts_with_deltas = accounts_df[accounts_df['Delta'] != 0]
  8492                                           
  8493                                                   # Check if 'checking' account type is involved in the transaction
  8494                                                   checking_in_txn = 'checking' in accounts_with_deltas['Account_Type'].unique()
  8495                                           
  8496                                                   # Get base names of accounts involved in the transaction
  8497                                                   affected_account_base_names = set(accounts_with_deltas['Base_Name'])
  8498                                           
  8499                                                   # Get base names of checking accounts
  8500                                                   checking_base_names = set(accounts_df[accounts_df['Account_Type'] == 'checking']['Base_Name'])
  8501                                           
  8502                                                   # Base names of affected accounts excluding checking accounts
  8503                                                   affected_account_base_names_sans_checking = affected_account_base_names - checking_base_names
  8504                                           
  8505                                                   if checking_in_txn and len(affected_account_base_names_sans_checking) == 0:
  8506                                                       # Only checking accounts are involved in the transaction
  8507                                                       # Update future balances for the checking accounts
  8508                                                       for idx, row in accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking'].iterrows():
  8509                                                           min_balance = row['Min_Balance']
  8510                                                           max_balance = row['Max_Balance']
  8511                                                           relevant_checking_account_name = row['Name']
  8512                                                           checking_delta = row['Delta']
  8513                                                           future_rows_only_df[relevant_checking_account_name] += checking_delta
  8514                                           
  8515                                                       if not future_rows_only_df.empty:
  8516                                                           min_future_acct_bal = min(future_rows_only_df[relevant_checking_account_name])
  8517                                                           max_future_acct_bal = max(future_rows_only_df[relevant_checking_account_name])
  8518                                           
  8519                                                           try:
  8520                                                               assert min_balance <= min_future_acct_bal
  8521                                                           except AssertionError:
  8522                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8523                                                               error_msg += "Account boundaries were violated\n"
  8524                                                               error_msg += "min_balance <= min_future_acct_bal was not True\n"
  8525                                                               error_msg += str(min_balance) + " <= " + str(min_future_acct_bal) + '\n'
  8526                                                               error_msg += future_rows_only_df.to_string()
  8527                                                               raise ValueError(error_msg)
  8528                                           
  8529                                                           try:
  8530                                                               assert max_balance >= max_future_acct_bal
  8531                                                           except AssertionError:
  8532                                                               error_msg = "Failure in propagateOptimizationTransactionsIntoTheFuture\n"
  8533                                                               error_msg += "Account boundaries were violated\n"
  8534                                                               error_msg += "max_balance >= max_future_acct_bal was not True\n"
  8535                                                               error_msg += str(max_balance) + " <= " + str(max_future_acct_bal) + '\n'
  8536                                                               error_msg += future_rows_only_df.to_string()
  8537                                                               raise ValueError(error_msg)
  8538                                                   else:
  8539                                                       # Process each affected base account name excluding checking accounts
  8540                                                       for account_base_name in affected_account_base_names_sans_checking:
  8541                                                           # Select accounts with the current base name
  8542                                                           accounts_with_base_name = accounts_df[accounts_df['Base_Name'] == account_base_name]
  8543                                           
  8544                                                           # Select accounts with non-zero deltas and the current base name
  8545                                                           accounts_with_base_name_and_delta = accounts_with_base_name[accounts_with_base_name['Delta'] != 0]
  8546                                           
  8547                                                           if accounts_with_base_name_and_delta.empty:
  8548                                                               continue
  8549                                           
  8550                                                           # Get the list of account types involved for this base name
  8551                                                           relevant_account_type_list = accounts_with_base_name_and_delta['Account_Type'].unique().tolist()
  8552                                           
  8553                                                           # If checking accounts are involved, include them
  8554                                                           if checking_in_txn:
  8555                                                               checking_accounts_in_txn = accounts_with_deltas[accounts_with_deltas['Account_Type'] == 'checking']
  8556                                                               accounts_with_base_name_and_delta = pd.concat(
  8557                                                                   [accounts_with_base_name_and_delta, checking_accounts_in_txn])
  8558                                                               if 'checking' not in relevant_account_type_list:
  8559                                                                   relevant_account_type_list.append('checking')
  8560                                           
  8561                                                           # Prepare the DataFrame with relevant account information
  8562                                                           relevant_account_info_df = accounts_with_base_name_and_delta
  8563                                           
  8564                                                           # Proceed to handle the transaction based on relevant_account_type_list
  8565                                                           # (Implementation depends on specific business logic)
  8566                                           
  8567                                                           # Identify the appropriate processing function
  8568                                                           account_types_set = frozenset(relevant_account_type_list)
  8569                                                           processing_function = account_type_combinations.get(account_types_set)
  8570                                           
  8571                                                           if processing_function:
  8572                                                               # Call the processing function
  8573                                                               future_rows_only_df = processing_function(
  8574                                                                   relevant_account_info_df,
  8575                                                                   account_deltas_list,
  8576                                                                   future_rows_only_df,
  8577                                                                   forecast_df,
  8578                                                                   account_set_before_p2_plus_txn,
  8579                                                                   billing_dates__dict,
  8580                                                                   date_string_YYYYMMDD,
  8581                                                                   post_txn_row_df
  8582                                                               )
  8583                                                           else:
  8584                                                               print('relevant_account_type_list:', relevant_account_type_list)
  8585                                                               print('affected_account_base_names:', relevant_account_info_df['Name'].unique())
  8586                                                               self.log_stack_depth -= 1
  8587                                                               raise ValueError("Undefined case in process_transactions")
  8588                                           
  8589                                                   if not future_rows_only_df.empty:
  8590                                                       # if not boundary violation
  8591                                                       #todo very slow to do this
  8592                                                       index_of_first_future_day = list(forecast_df.Date).index(future_rows_only_df.head(1).Date.iat[0])
  8593                                                       future_rows_only_df.index = future_rows_only_df.index + index_of_first_future_day
  8594                                                       forecast_df.update(future_rows_only_df)
  8595                                           
  8596                                           
  8597                                                       log_in_color(logger, 'cyan', 'debug', 'future_rows_only_df', self.log_stack_depth)
  8598                                                       log_in_color(logger, 'cyan', 'debug', future_rows_only_df.to_string(), self.log_stack_depth)
  8599                                                       log_in_color(logger, 'cyan', 'debug', 'forecast_df', self.log_stack_depth)
  8600                                                       log_in_color(logger, 'cyan', 'debug', forecast_df.to_string(), self.log_stack_depth)
  8601                                           
  8602                                                   self.log_stack_depth -= 1
  8603                                                   log_in_color(logger, 'cyan', 'debug', 'EXIT propagateOptimizationTransactionsIntoTheFuture', self.log_stack_depth)
  8604                                                   return forecast_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: updateProposedTransactionsBasedOnOtherSets at line 9086

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9086                                               @profile
  9087                                               def updateProposedTransactionsBasedOnOtherSets(self, confirmed_df, proposed_df, deferred_df, skipped_df):
  9088                                                   # update remaining_unproposed_transactions_df based on modifications to other sets made during the last loop
  9089                                                   C = 'C:'+str(confirmed_df.shape[0])
  9090                                                   P = 'P:'+str(proposed_df.shape[0])
  9091                                                   D = 'D:'+str(deferred_df.shape[0])
  9092                                                   S = 'S:'+str(skipped_df.shape[0])
  9093                                                   # log_in_color(logger,'cyan','debug','ENTER updateProposedTransactionsBasedOnOtherSets( '+C+' '+P+' '+D+' '+S+' )', self.log_stack_depth)
  9094                                                   #
  9095                                                   # log_in_color(logger, 'cyan', 'debug', 'confirmed_df:', self.log_stack_depth)
  9096                                                   # log_in_color(logger, 'cyan', 'debug',confirmed_df.to_string(), self.log_stack_depth)
  9097                                                   #
  9098                                                   # log_in_color(logger, 'cyan', 'debug', 'proposed_df:', self.log_stack_depth)
  9099                                                   # log_in_color(logger, 'cyan', 'debug', proposed_df.to_string(), self.log_stack_depth)
  9100                                                   #
  9101                                                   # log_in_color(logger, 'cyan', 'debug', 'deferred_df:', self.log_stack_depth)
  9102                                                   # log_in_color(logger, 'cyan', 'debug', deferred_df.to_string(), self.log_stack_depth)
  9103                                                   #
  9104                                                   # log_in_color(logger, 'cyan', 'debug', 'skipped_df:', self.log_stack_depth)
  9105                                                   # log_in_color(logger, 'cyan', 'debug', skipped_df.to_string(), self.log_stack_depth)
  9106                                           
  9107                                                   self.log_stack_depth += 1
  9108                                                   # log_in_color(logger, 'cyan', 'debug', 'confirmed_df: '+str(confirmed_df))
  9109                                                   # log_in_color(logger, 'cyan', 'debug', 'proposed_df: '+str(proposed_df))
  9110                                                   # log_in_color(logger, 'cyan', 'debug', 'deferred_df: '+str(deferred_df))
  9111                                                   # log_in_color(logger, 'cyan', 'debug', 'skipped_df: '+str(skipped_df))
  9112                                                   #log_in_color(logger, 'cyan', 'debug', 'confirmed_df cols: '+str(confirmed_df.columns))
  9113                                                   #log_in_color(logger, 'cyan', 'debug', 'proposed_df cols: '+str(proposed_df.columns))
  9114                                                   #log_in_color(logger, 'cyan', 'debug', 'deferred_df cols: '+str(deferred_df.columns))
  9115                                                   #log_in_color(logger, 'cyan', 'debug', 'skipped_df cols: '+str(skipped_df.columns))
  9116                                           
  9117                                                   p_LJ_c = pd.merge(proposed_df, confirmed_df, on=['Date', 'Memo', 'Priority'])
  9118                                                   p_LJ_d = pd.merge(proposed_df, deferred_df, on=['Date', 'Memo', 'Priority'])
  9119                                                   p_LJ_s = pd.merge(proposed_df, skipped_df, on=['Date', 'Memo', 'Priority'])
  9120                                           
  9121                                                   not_confirmed_sel_vec = (~proposed_df.index.isin(p_LJ_c))
  9122                                                   not_deferred_sel_vec = (~proposed_df.index.isin(p_LJ_d))
  9123                                                   not_skipped_sel_vec = (~proposed_df.index.isin(p_LJ_s))
  9124                                                   remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9125                                                   remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9126                                           
  9127                                                   ### this code is equivalent. todo Which is more performant?
  9128                                                   # not_confirmed_sel_vec = (~proposed_df.index.isin(confirmed_df.index))
  9129                                                   # not_deferred_sel_vec = (~proposed_df.index.isin(deferred_df.index))
  9130                                                   # not_skipped_sel_vec = (~proposed_df.index.isin(skipped_df.index))
  9131                                                   # remaining_unproposed_sel_vec = (not_confirmed_sel_vec & not_deferred_sel_vec & not_skipped_sel_vec)
  9132                                                   # remaining_unproposed_transactions_df = proposed_df[remaining_unproposed_sel_vec]
  9133                                           
  9134                                                   self.log_stack_depth -= 1
  9135                                                   # log_in_color(logger, 'cyan', 'debug', 'EXIT updateProposedTransactionsBasedOnOtherSets',self.log_stack_depth)
  9136                                                   return remaining_unproposed_transactions_df

Total time: 0 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: assessPotentialOptimizations at line 9279

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9279                                               @profile
  9280                                               def assessPotentialOptimizations(self, forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df, raise_satisfice_failed_exception, progress_bar=None):
  9281                                                   F = 'F:'+str(forecast_df.shape[0])
  9282                                                   C = 'C:'+str(confirmed_df.shape[0])
  9283                                                   P = 'P:'+str(proposed_df.shape[0])
  9284                                                   D = 'D:'+str(deferred_df.shape[0])
  9285                                                   S = 'S:'+str(skipped_df.shape[0])
  9286                                                   log_in_color(logger,'magenta','debug','ENTER assessPotentialOptimizations( '+F+' '+C+' '+P+' '+D+' '+S+' )',self.log_stack_depth)
  9287                                                   self.log_stack_depth += 1
  9288                                                   all_days = forecast_df.Date
  9289                                           
  9290                                                   # log_in_color(logger, 'magenta', 'debug', 'confirmed_df:', self.log_stack_depth)
  9291                                                   # log_in_color(logger, 'magenta', 'debug', confirmed_df.to_string(), self.log_stack_depth)
  9292                                                   #
  9293                                                   # log_in_color(logger, 'magenta', 'debug', 'proposed_df:', self.log_stack_depth)
  9294                                                   # log_in_color(logger, 'magenta', 'debug', proposed_df.to_string(), self.log_stack_depth)
  9295                                                   #
  9296                                                   # log_in_color(logger, 'magenta', 'debug', 'deferred_df:', self.log_stack_depth)
  9297                                                   # log_in_color(logger, 'magenta', 'debug', deferred_df.to_string(), self.log_stack_depth)
  9298                                                   #
  9299                                                   # log_in_color(logger, 'magenta', 'debug', 'skipped_df:', self.log_stack_depth)
  9300                                                   # log_in_color(logger, 'magenta', 'debug', skipped_df.to_string(), self.log_stack_depth)
  9301                                           
  9302                                                   # Schema is: Date, Priority, Amount, Memo, Deferrable, Partial_Payment_Allowed
  9303                                                   full_budget_schedule_df = pd.concat([confirmed_df, proposed_df, deferred_df, skipped_df])
  9304                                                   full_budget_schedule_df.reset_index(drop=True, inplace=True)
  9305                                           
  9306                                                   unique_priority_indices = full_budget_schedule_df.Priority.unique()
  9307                                                   unique_priority_indices.sort()
  9308                                           
  9309                                           
  9310                                                   last_iteration_ts = None #this is here to remove a warning
  9311                                           
  9312                                                   if not raise_satisfice_failed_exception:
  9313                                                       # print('Beginning Optimization.')
  9314                                                       # print(forecast_df.to_string())
  9315                                                       log_in_color(logger, 'white', 'info','Beginning Optimization.')
  9316                                                       # log_in_color(logger, 'white', 'debug', self.start_date_YYYYMMDD + ' -> ' + self.end_date_YYYYMMDD)
  9317                                                       # log_in_color(logger, 'white', 'debug', 'Priority Indices: ' + str(unique_priority_indices))
  9318                                                       last_iteration_ts = datetime.datetime.now()
  9319                                           
  9320                                                   # print('Beginning unique_priority_indices:'+str(unique_priority_indices))
  9321                                                   for priority_index in unique_priority_indices:
  9322                                                       if priority_index == 1:
  9323                                                           continue #because this was handled by satisfice
  9324                                           
  9325                                                       for date_string_YYYYMMDD in all_days:
  9326                                                           if date_string_YYYYMMDD == forecast_df.head(1).Date.iat[0]:
  9327                                                           #if date_string_YYYYMMDD == self.start_date_YYYYMMDD:
  9328                                                               continue  # first day is considered final
  9329                                           
  9330                                           
  9331                                                           if not raise_satisfice_failed_exception:
  9332                                                               if progress_bar is not None:
  9333                                                                   progress_bar.update(1)
  9334                                                                   progress_bar.refresh()
  9335                                           
  9336                                                               iteration_time_elapsed = datetime.datetime.now() - last_iteration_ts
  9337                                                               last_iteration_ts = datetime.datetime.now()
  9338                                                               log_string = str(priority_index) + ' ' + datetime.datetime.strptime(date_string_YYYYMMDD,'%Y%m%d').strftime('%Y-%m-%d')
  9339                                                               log_string += '     ' + str(iteration_time_elapsed)
  9340                                                               # log_in_color(logger, 'white', 'debug', log_string )
  9341                                           
  9342                                                           # log_in_color(logger, 'magenta', 'info', 'p' + str(priority_index) + ' ' + str(date_string_YYYYMMDD),self.log_stack_depth)
  9343                                           
  9344                                                           remaining_unproposed_transactions_df = self.updateProposedTransactionsBasedOnOtherSets(confirmed_df, proposed_df, deferred_df, skipped_df)
  9345                                           
  9346                                                           #todo idk if this is necessary
  9347                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9348                                           
  9349                                                           #todo maybe this could be moved down? not sure
  9350                                                           account_set_before_p2_plus_txn = copy.deepcopy(account_set)
  9351                                           
  9352                                                           #todo not sure if this is necessary
  9353                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9354                                           
  9355                                           
  9356                                           
  9357                                                           forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(account_set=account_set,
  9358                                                                                                                                               forecast_df=forecast_df,
  9359                                                                                                                                               date_YYYYMMDD=date_string_YYYYMMDD,
  9360                                                                                                                                               memo_set=memo_rule_set,
  9361                                                                                                                                               confirmed_df=confirmed_df,
  9362                                                                                                                                               proposed_df=remaining_unproposed_transactions_df,
  9363                                                                                                                                               deferred_df=deferred_df,
  9364                                                                                                                                               skipped_df=skipped_df,
  9365                                                                                                                                               priority_level=priority_index)
  9366                                           
  9367                                                           # log_in_color(logger, 'green', 'info', 'forecast_df after eTFD ('+str(date_string_YYYYMMDD)+'):', self.log_stack_depth)
  9368                                                           # log_in_color(logger, 'green', 'info', forecast_df.to_string(), self.log_stack_depth)
  9369                                           
  9370                                                           # print('assess optimizations case 3 sync')
  9371                                                           account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_string_YYYYMMDD)
  9372                                           
  9373                                                           # this is necessary to make balance deltas propagate only once
  9374                                                           # print('raise_satisfice_failed_exception:'+str(raise_satisfice_failed_exception))
  9375                                                           if raise_satisfice_failed_exception:
  9376                                           
  9377                                                               #regarding why the input params are what they are here:
  9378                                                               # since the budget schedule does not have Account_From and Account_To, we infer which accounts were
  9379                                                               # affected by comparing the before and after, hence this method accepts the prior and current state
  9380                                                               # to modify forecast_df
  9381                                                               # Furthermore, additional loan payments affect the allocation of future minimum loan payments
  9382                                                               # so p1 minimumpayments, which aren't even BudgetItems as of 12/31/23.... must be edited
  9383                                                               # it kind of makes more sense to refactor and have credit card minimum payments and loan minimum
  9384                                                               # # payments as budget items....
  9385                                                               #
  9386                                                               # Doing that though creates a coupling between the AccountSet and BudgetSet classes that I don't like...
  9387                                                               # I only recently got the full detail of what happens into the Memo field, but I think that that is the answer
  9388                                                               # There will be information encoded in the Memo column that will not appear anywhere else
  9389                                                               #
  9390                                                               print('about to propagateOptimizationTransactionsIntoTheFuture')
  9391                                                               print('BEFORE')
  9392                                                               print(forecast_df.to_string())
  9393                                                               forecast_df = self.propagateOptimizationTransactionsIntoTheFuture(account_set_before_p2_plus_txn,forecast_df, date_string_YYYYMMDD)
  9394                                           
  9395                                                               print('AFTER')
  9396                                                               print(forecast_df.to_string())
  9397                                           
  9398                                           
  9399                                                   self.log_stack_depth -= 1
  9400                                                   log_in_color(logger, 'magenta', 'debug', 'EXIT assessPotentialOptimizations() C:'+str(confirmed_df.shape[0])+' D:'+str(deferred_df.shape[0])+' S:'+str(skipped_df.shape[0]),self.log_stack_depth)
  9401                                                   return forecast_df, skipped_df, confirmed_df, deferred_df

Total time: 313.157 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: satisfice at line 9424

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9424                                               @profile
  9425                                               def satisfice(self, list_of_date_strings, confirmed_df, account_set, memo_rule_set, forecast_df,
  9426                                                             raise_satisfice_failed_exception, progress_bar=None):
  9427         1          2.0      2.0      0.0          self.log_stack_depth += 1
  9428         1          0.0      0.0      0.0          all_days = list_of_date_strings  # Rename for clarity
  9429                                           
  9430       324        239.0      0.7      0.0          for date_str in all_days:
  9431       324       1266.0      3.9      0.0              if progress_bar:
  9432       324        674.0      2.1      0.0                  progress_bar.update(1)
  9433       324        422.0      1.3      0.0                  progress_bar.refresh()
  9434                                           
  9435                                                       # Skip the first day, considered as final
  9436       324        323.0      1.0      0.0              if date_str == self.start_date_YYYYMMDD:
  9437                                                           continue
  9438                                           
  9439       324        137.0      0.4      0.0              try:
  9440                                                           # Log transaction details if exception handling is not strict
  9441       324        105.0      0.3      0.0                  if not raise_satisfice_failed_exception:
  9442       324      25562.0     78.9      0.0                      log_string = f"1 {datetime.datetime.strptime(date_str, '%Y%m%d').strftime('%Y-%m-%d')}"
  9443                                           
  9444                                                           # Execute transactions for the day, priority 1 (non-negotiable)
  9445       648  130664111.0 201642.1     41.7                  forecast_df, confirmed_df, deferred_df, skipped_df = self.executeTransactionsForDay(
  9446       324        104.0      0.3      0.0                      account_set=account_set,
  9447       324        131.0      0.4      0.0                      forecast_df=forecast_df,
  9448       324         93.0      0.3      0.0                      date_YYYYMMDD=date_str,
  9449       324        105.0      0.3      0.0                      memo_set=memo_rule_set,
  9450       324        151.0      0.5      0.0                      confirmed_df=confirmed_df,
  9451       324      21952.0     67.8      0.0                      proposed_df=confirmed_df.head(0),  # No proposed transactions in satisfice
  9452       324      13482.0     41.6      0.0                      deferred_df=confirmed_df.head(0),  # No deferred transactions in satisfice
  9453       324      11794.0     36.4      0.0                      skipped_df=confirmed_df.head(0),  # No skipped transactions in satisfice
  9454       324        116.0      0.4      0.0                      priority_level=1
  9455                                                           )
  9456                                           
  9457                                                           # Sync account set after transactions
  9458       323   10231426.0  31676.2      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9459                                           
  9460                                                           # Calculate loan interest accruals for the day
  9461       646   30966671.0  47936.0      9.9                  forecast_df.loc[forecast_df.Date == date_str] = self.calculateLoanInterestAccrualsForDay(account_set,
  9462       646      71906.0    111.3      0.0                                                                                                           forecast_df[
  9463       323      59033.0    182.8      0.0                                                                                                               forecast_df.Date == date_str])
  9464                                           
  9465                                                           # print('POST interest caculation')
  9466                                                           # print(forecast_df.to_string())
  9467                                           
  9468                                                           # Sync again after interest accruals
  9469       323   10051886.0  31120.4      3.2                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9470                                           
  9471                                                           # Execute minimum loan payments
  9472       646   87637091.0 135661.1     28.0                  forecast_df.loc[forecast_df.Date == date_str] = self.executeLoanMinimumPayments(account_set,
  9473       646      72124.0    111.6      0.0                                                                                                  forecast_df[
  9474       323      59602.0    184.5      0.0                                                                                                      forecast_df.Date == date_str])
  9475                                           
  9476                                                           # Sync after loan payments
  9477       323   10351150.0  32046.9      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9478                                           
  9479                                                           # Execute credit card minimum payments
  9480       646   22504668.0  34836.9      7.2                  forecast_df.loc[forecast_df.Date == date_str] = self.executeCreditCardMinimumPayments(forecast_df,
  9481       323        119.0      0.4      0.0                                                                                                        account_set,
  9482       646      72979.0    113.0      0.0                                                                                                        forecast_df[
  9483       323      59317.0    183.6      0.0                                                                                                            forecast_df.Date == date_str])
  9484                                           
  9485                                                           # Final sync for the day
  9486       323   10198894.0  31575.5      3.3                  account_set = self.sync_account_set_w_forecast_day(account_set, forecast_df, date_str)
  9487                                           
  9488         1          1.0      1.0      0.0              except ValueError as e:
  9489         1         10.0     10.0      0.0                  error_message = str(e.args)
  9490                                                           # Handle specific account boundary violations
  9491         3        614.0    204.7      0.0                  if re.search('.*Account boundaries were violated.*',
  9492         2          1.0      0.5      0.0                               error_message) and not raise_satisfice_failed_exception:
  9493         1         78.0     78.0      0.0                      self.end_date = datetime.datetime.strptime(date_str, '%Y%m%d') - datetime.timedelta(days=1)
  9494                                           
  9495         1        365.0    365.0      0.0                      log_in_color(logger, 'cyan', 'error', 'Account Boundaries were violated', self.log_stack_depth)
  9496         1        142.0    142.0      0.0                      log_in_color(logger, 'cyan', 'error', error_message, self.log_stack_depth)
  9497         1        115.0    115.0      0.0                      log_in_color(logger, 'cyan', 'error', 'State at failure:', self.log_stack_depth)
  9498         1      77958.0  77958.0      0.0                      log_in_color(logger, 'cyan', 'error', forecast_df.to_string(), self.log_stack_depth)
  9499                                           
  9500         1          1.0      1.0      0.0                      self.log_stack_depth -= 1
  9501         1         79.0     79.0      0.0                      return forecast_df
  9502                                                           else:
  9503                                                               raise e
  9504                                           
  9505                                                   self.log_stack_depth -= 1
  9506                                                   return forecast_df  # satisfice_success = True

Total time: 313.287 s
File: /Users/hume/Github/expense_forecast/ExpenseForecast.py
Function: computeOptimalForecast at line 9508

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  9508                                               @profile
  9509                                               def computeOptimalForecast(self, start_date_YYYYMMDD, end_date_YYYYMMDD, confirmed_df, proposed_df, deferred_df,
  9510                                                                          skipped_df, account_set, memo_rule_set, raise_satisfice_failed_exception=True,
  9511                                                                          progress_bar=None):
  9512         1          5.0      5.0      0.0          self.log_stack_depth += 1
  9513                                           
  9514                                                   # Reset index for all input DataFrames to ensure clean processing
  9515         5          4.0      0.8      0.0          for df in [confirmed_df, proposed_df, deferred_df, skipped_df]:
  9516         4        231.0     57.8      0.0              df.reset_index(drop=True, inplace=True)
  9517                                           
  9518                                                   # Generate the list of days for the forecast, excluding the first day
  9519         2       1042.0    521.0      0.0          all_days = pd.date_range(
  9520         1        176.0    176.0      0.0              datetime.datetime.strptime(start_date_YYYYMMDD, '%Y%m%d') + datetime.timedelta(days=1),
  9521         1         40.0     40.0      0.0              datetime.datetime.strptime(end_date_YYYYMMDD, '%Y%m%d')
  9522                                                   )
  9523         1       1840.0   1840.0      0.0          all_days = [d.strftime('%Y%m%d') for d in all_days]
  9524                                           
  9525                                                   # Initialize the forecast DataFrame with the first day's account balances
  9526         1      45787.0  45787.0      0.0          forecast_df = self.getInitialForecastRow(start_date_YYYYMMDD, account_set)
  9527                                           
  9528                                                   # Attempt to satisfice (execute priority 1 transactions for each day)
  9529         2  313167011.0    2e+08    100.0          satisfice_df = self.satisfice(
  9530         1          0.0      0.0      0.0              all_days, confirmed_df, account_set, memo_rule_set, forecast_df, raise_satisfice_failed_exception,
  9531         1          1.0      1.0      0.0              progress_bar
  9532                                                   )
  9533                                           
  9534                                                   # Check if satisfice succeeded by verifying the last date in the forecast
  9535         1        244.0    244.0      0.0          satisfice_success = satisfice_df.tail(1)['Date'].iat[0] == end_date_YYYYMMDD
  9536                                           
  9537                                                   # Update forecast DataFrame with the result of satisfice
  9538         1          7.0      7.0      0.0          forecast_df = satisfice_df
  9539                                           
  9540         1          1.0      1.0      0.0          if satisfice_success:
  9541                                                       # Log success message when satisfice completes successfully at the top level
  9542                                                       if not raise_satisfice_failed_exception:
  9543                                                           log_in_color(logger, 'white', 'info', 'Satisfice succeeded.')
  9544                                                           log_in_color(logger, 'white', 'debug', satisfice_df.to_string())
  9545                                           
  9546                                                       # Assess potential optimizations across all transaction levels
  9547                                                       forecast_df, skipped_df, confirmed_df, deferred_df = self.assessPotentialOptimizations(
  9548                                                           forecast_df, account_set, memo_rule_set, confirmed_df, proposed_df, deferred_df, skipped_df,
  9549                                                           raise_satisfice_failed_exception, progress_bar
  9550                                                       )
  9551                                                   else:
  9552                                                       # Handle satisfice failure: clean up unprocessed transactions
  9553         1          1.0      1.0      0.0              if not raise_satisfice_failed_exception:
  9554         1         26.0     26.0      0.0                  log_in_color(logger, 'white', 'debug', 'Satisfice failed.')
  9555                                           
  9556         2      70728.0  35364.0      0.0              confirmed_df, deferred_df, skipped_df = self.cleanUpAfterFailedSatisfice(
  9557         1          1.0      1.0      0.0                  confirmed_df, proposed_df, deferred_df, skipped_df
  9558                                                       )
  9559                                           
  9560                                                   # Decrement the log stack depth as we exit this method
  9561         1          2.0      2.0      0.0          self.log_stack_depth -= 1
  9562                                           
  9563                                                   # Return the forecast and updated DataFrames
  9564         1          1.0      1.0      0.0          return [forecast_df, skipped_df, confirmed_df, deferred_df]

